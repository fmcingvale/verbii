( -- test library functions and other basic things not covered in unittest_core -- )
( -- Copyright (c) 2022 Frank McIngvale, see LICENSE -- )

10 20 30 
depth
. . . . CR
depth

10 20 30 40 50 60
SP 3 + SP!

"Hello world!" . CR
clear

10 20 30
drop
drop
drop

111 222
dup
dup

0
dup?
clear

11 22 33
swap
swap
clear

11 22 33 44
1 pick
drop
2 pick
drop
3 pick
drop
4 pick

clear
10 20 30 40
over

clear
10 20 30 40 50 60
2dup

clear
10 20 30 40
2drop

clear
10 20 30 40 50 60
2over 

clear
10 20 30 40 50 60
2swap

( logical operations )
clear
true
false

clear
true not
false not

clear
true true or
true false or
false true or
false false or

clear
true true and
true false and
false true and
false false and

( stack operations )
clear
11 22 33 44 55 66 77
4 ndrop

clear
111 222 333 444 555
5 ndrop

clear
111 222 333
nip

clear
10 20 30 tuck

clear
10 20 30 40
rot
-rot

( relational operators )
clear
10 20 >=
30 20 >=
40 40 >=

clear
10 20 <
30 10 <
40 40 <

clear
15 20 <=
35 21 <=
40 40 <=

( combinations of rich math operations )
clear
10 20 +
10 #21 +
#11 22 +
#11 #33 +

clear
10 20 -
10 #21 -
#11 20 -
#22 #77 -

clear
10 20 *
10 #21 *
#12 12 *
#10 #40 *

clear
10 20 /
40 #20 /
#30 2 /
#100 #25 /

clear
"hello" " " "world"
+
+

clear
'abc 'def 'ghi
+
+

( more math operations )
clear
123 
neg
-456
neg

clear
123 456 
max
-500 200 
max
300 -44
max
444 444 
max

clear
100 200 
min
-400 500 
min
123 -40 
min
77 77
min

clear
123
abs
-99
abs
0
abs


clear
10 20 30 40
.S 

: foobar 11 22 33 44 ;
'foobar .dumpword

clear
( -- lambdas -- )
{ 4 5 6 }
call
clear
{ 1 2 3 { 7 8 9 } 4 5 6 }
call
3 ndrop
call

clear
{ 111 222 333 }
dup
dup
call
3 ndrop
call
3 ndrop
call

clear

( -- simple example of passing lambdas to another function -- )
def saything ( lambda -- ) dup "The" . 1 swap call "is" . 2 swap call CR ;

( called with cmd on TOS )
{ 1 == if >>one "blue" . return @one "ocean" . }
{ 1 == if >>one "green" . return @one "grass" . }
{ 1 == if >>one "red" . return @one "rose" . }
saything
saything
saything

clear
: zzz { 10 . 20 . "Hello lambda!" . 30 . 40 . } call CR ;
( subtlety here -- have to run zzz at least twice to make sure it's working -- )
( the FIRST time, the { .. } will be parsed and directly pushed as a lambda object ... )
( ... modifying the source to remove the { .. } and replacing it with the lambda object that )
( ... will be pushed as an immediate value on subsequent runs )
( so have to run the SECOND time to make sure the modified wordlist is correct )
zzz
zzz
zzz ( once more for good measure )

( this will fail if comments aren't removed in the syntax layer since the )
( interpreter expects the name immediately after 'var' )
var ( hello ) t33 ( there ) 1
1445 t33 set! 
t33 ref . CR

( make sure saving lambdas to vars works )
clear
{ 133 244 355 } t33 set!
t33 ref call 
t33 ref call

clear
123 ( make sure that ( nested ( comments ) are ) handled ok ) 456

( string parsing )
clear
"hello world here"
. CR
" hello with leading trailing space "
. CR
"oneword"
. CR
"""and some embedded"quote"chars << here"""
. CR

( length operator )
clear
"hello"
length
'bigsymbol
length
var x 123
x length

( lists )
clear
10 20 30 40 
4 make-list
dup length

clear
0 make-list
length

clear
11 22 33 3 make-list
44 55 66 77 4 make-list
+
length

clear
11 22 2 make-list 33 44 55 3 make-list 66 1 make-list 0 make-list 77 88 99 3 make-list
5 make-list
length

clear
"Hello" "world" 123 2 make-list "the end" 3 make-list

( slicing )
clear
"abcdefghijklmnop" 4 5 slice
"abcdefghijklmnop" -5 3 slice
"zooming" 3 100 slice
"hello world" 4 -1 slice
"questionable" 4 0 slice
"________X__________" 8 1 slice

clear
'hello-a-long-symbol 4 3 slice
'short 3 100 slice
'simple -4 2 slice

clear
10 20 30 40 50 60 70 80 90 100 10 make-list
dup 4 3 slice
drop
dup -5 4 slice
drop
dup 3 100 slice
drop
dup 6 -1 slice
drop
dup 7 0 slice
drop
dup 7 1 slice

( string / symbol make/unmake )
clear
65 66 67 68 4 make-string
66 67 68 69 70 5 make-symbol

clear
"Hello world!" unmake
make-symbol
unmake
make-string

clear
{ 10 20 30 40 }
unmake
unmake

( type testing )
clear
123 int?
#123 int?
#446 float?
123 float?
"hello" string?
"there" symbol?
'world symbol?
'foobar string?
true bool?
1 bool?
null null?
0 null?

clear
10 'word #13.425 3 4 5 3 make-list "end" 5 make-list
make-lambda
unmake
unmake

( lists should share same object )
clear
10 20 30 3 make-list
dup dup 
40 append ( all should change )

( array slices )
clear
var Y 4
10 Y set!
20 Y 1 + set!
30 Y 2 + set!
40 Y 3 + set!
'Y .dumpvar
Y 0 -1 slice
Y 2 1 slice
Y -3 2 slice
Y unmake
