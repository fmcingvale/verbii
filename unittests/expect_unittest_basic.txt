>> ( -- test library functions and other basic things not covered in unittest_core -- )
=> 
>> ( -- Copyright (c) 2022 Frank McIngvale, see LICENSE -- )
=> 
>> 10 20 30 
=> 10 20 30 
>> depth
=> 10 20 30 3 
>> . . . . CR
3 30 20 10 
=> 
>> depth
=> 0 
>> 10 20 30 40 50 60
=> 0 10 20 30 40 50 60 
>> SP 3 + SP!
=> 0 10 20 30 
>> "Hello world!" . CR
Hello world! 
=> 0 10 20 30 
>> clear
=> 
>> 10 20 30
=> 10 20 30 
>> drop
=> 10 20 
>> drop
=> 10 
>> drop
=> 
>> 111 222
=> 111 222 
>> dup
=> 111 222 222 
>> dup
=> 111 222 222 222 
>> 0
=> 111 222 222 222 0 
>> dup?
=> 111 222 222 222 0 
>> clear
=> 
>> 11 22 33
=> 11 22 33 
>> swap
=> 11 33 22 
>> swap
=> 11 22 33 
>> clear
=> 
>> 11 22 33 44
=> 11 22 33 44 
>> 1 pick
=> 11 22 33 44 44 
>> drop
=> 11 22 33 44 
>> 2 pick
=> 11 22 33 44 33 
>> drop
=> 11 22 33 44 
>> 3 pick
=> 11 22 33 44 22 
>> drop
=> 11 22 33 44 
>> 4 pick
=> 11 22 33 44 11 
>> clear
=> 
>> 10 20 30 40
=> 10 20 30 40 
>> over
=> 10 20 30 40 30 
>> clear
=> 
>> 10 20 30 40 50 60
=> 10 20 30 40 50 60 
>> 2dup
=> 10 20 30 40 50 60 50 60 
>> clear
=> 
>> 10 20 30 40
=> 10 20 30 40 
>> 2drop
=> 10 20 
>> clear
=> 
>> 10 20 30 40 50 60
=> 10 20 30 40 50 60 
>> 2over 
=> 10 20 30 40 50 60 30 40 
>> clear
=> 
>> 10 20 30 40 50 60
=> 10 20 30 40 50 60 
>> 2swap
=> 10 20 50 60 30 40 
>> ( logical operations )
=> 10 20 50 60 30 40 
>> clear
=> 
>> true
=> true 
>> false
=> true false 
>> clear
=> 
>> true not
=> false 
>> false not
=> false true 
>> clear
=> 
>> true true or
=> true 
>> true false or
=> true true 
>> false true or
=> true true true 
>> false false or
=> true true true false 
>> clear
=> 
>> true true and
=> true 
>> true false and
=> true false 
>> false true and
=> true false false 
>> false false and
=> true false false false 
>> ( stack operations )
=> true false false false 
>> clear
=> 
>> 11 22 33 44 55 66 77
=> 11 22 33 44 55 66 77 
>> 4 ndrop
=> 11 22 33 
>> clear
=> 
>> 111 222 333 444 555
=> 111 222 333 444 555 
>> 5 ndrop
=> 
>> clear
=> 
>> 111 222 333
=> 111 222 333 
>> nip
=> 111 333 
>> clear
=> 
>> 10 20 30 tuck
=> 10 30 20 30 
>> clear
=> 
>> 10 20 30 40
=> 10 20 30 40 
>> rot
=> 10 30 40 20 
>> -rot
=> 10 20 30 40 
>> ( relational operators )
=> 10 20 30 40 
>> clear
=> 
>> 10 20 >=
=> false 
>> 30 20 >=
=> false true 
>> 40 40 >=
=> false true true 
>> clear
=> 
>> 10 20 <
=> true 
>> 30 10 <
=> true false 
>> 40 40 <
=> true false false 
>> clear
=> 
>> 15 20 <=
=> true 
>> 35 21 <=
=> true false 
>> 40 40 <=
=> true false true 
>> ( combinations of rich math operations )
=> true false true 
>> clear
=> 
>> 10 20 +
=> 30 
>> 10 #21 +
=> 30 #31 
>> #11 22 +
=> 30 #31 #33 
>> #11 #33 +
=> 30 #31 #33 #44 
>> clear
=> 
>> 10 20 -
=> -10 
>> 10 #21 -
=> -10 #-11 
>> #11 20 -
=> -10 #-11 #-9 
>> #22 #77 -
=> -10 #-11 #-9 #-55 
>> clear
=> 
>> 10 20 *
=> 200 
>> 10 #21 *
=> 200 #210 
>> #12 12 *
=> 200 #210 #144 
>> #10 #40 *
=> 200 #210 #144 #400 
>> clear
=> 
>> 10 20 /
=> #0.5 
>> 40 #20 /
=> #0.5 #2 
>> #30 2 /
=> #0.5 #2 #15 
>> #100 #25 /
=> #0.5 #2 #15 #4 
>> clear
=> 
>> "hello" " " "world"
=> "hello" " " "world" 
>> +
=> "hello" " world" 
>> +
=> "hello world" 
>> clear
=> 
>> 'abc 'def 'ghi
=> abc def ghi 
>> +
=> abc defghi 
>> +
=> abcdefghi 
>> ( more math operations )
=> abcdefghi 
>> clear
=> 
>> 123 
=> 123 
>> neg
=> -123 
>> -456
=> -123 -456 
>> neg
=> -123 456 
>> clear
=> 
>> 123 456 
=> 123 456 
>> max
=> 456 
>> -500 200 
=> 456 -500 200 
>> max
=> 456 200 
>> 300 -44
=> 456 200 300 -44 
>> max
=> 456 200 300 
>> 444 444 
=> 456 200 300 444 444 
>> max
=> 456 200 300 444 
>> clear
=> 
>> 100 200 
=> 100 200 
>> min
=> 100 
>> -400 500 
=> 100 -400 500 
>> min
=> 100 -400 
>> 123 -40 
=> 100 -400 123 -40 
>> min
=> 100 -400 -40 
>> 77 77
=> 100 -400 -40 77 77 
>> min
=> 100 -400 -40 77 
>> clear
=> 
>> 123
=> 123 
>> abs
=> 123 
>> -99
=> 123 -99 
>> abs
=> 123 99 
>> 0
=> 123 99 0 
>> abs
=> 123 99 0 
>> clear
=> 
>> 10 20 30 40
=> 10 20 30 40 
>> .S 
=> 10 20 30 40 
=> 10 20 30 40 
>> : foobar 11 22 33 44 ;
=> 10 20 30 40 
>> 'foobar .dumpword
=> 10 20 30 40 [ 11 22 33 44 ] 
>> clear
=> 
>> ( -- lambdas -- )
=> 
>> { 4 5 6 }
=> <lambda> 
>> call
=> 4 5 6 
>> clear
=> 
>> { 1 2 3 { 7 8 9 } 4 5 6 }
=> <lambda> 
>> call
=> 1 2 3 <lambda> 4 5 6 
>> 3 ndrop
=> 1 2 3 <lambda> 
>> call
=> 1 2 3 7 8 9 
>> clear
=> 
>> { 111 222 333 }
=> <lambda> 
>> dup
=> <lambda> <lambda> 
>> dup
=> <lambda> <lambda> <lambda> 
>> call
=> <lambda> <lambda> 111 222 333 
>> 3 ndrop
=> <lambda> <lambda> 
>> call
=> <lambda> 111 222 333 
>> 3 ndrop
=> <lambda> 
>> call
=> 111 222 333 
>> clear
=> 
>> ( -- simple example of passing lambdas to another function -- )
=> 
>> def saything ( lambda -- ) dup "The" . 1 swap call "is" . 2 swap call CR ;
=> 
>> ( called with cmd on TOS )
=> 
>> { 1 == if >>one "blue" . return @one "ocean" . }
=> <lambda> 
>> { 1 == if >>one "green" . return @one "grass" . }
=> <lambda> <lambda> 
>> { 1 == if >>one "red" . return @one "rose" . }
=> <lambda> <lambda> <lambda> 
>> saything
The rose is red 
=> <lambda> <lambda> 
>> saything
The grass is green 
=> <lambda> 
>> saything
The ocean is blue 
=> 
>> clear
=> 
>> : zzz { 10 . 20 . "Hello lambda!" . 30 . 40 . } call CR ;
=> 
>> ( subtlety here -- have to run zzz at least twice to make sure it's working -- )
=> 
>> ( the FIRST time, the { .. } will be parsed and directly pushed as a lambda object ... )
=> 
>> ( ... modifying the source to remove the { .. } and replacing it with the lambda object that )
=> 
>> ( ... will be pushed as an immediate value on subsequent runs )
=> 
>> ( so have to run the SECOND time to make sure the modified wordlist is correct )
=> 
>> zzz
10 20 Hello lambda! 30 40 
=> 
>> zzz
10 20 Hello lambda! 30 40 
=> 
>> zzz ( once more for good measure )
10 20 Hello lambda! 30 40 
=> 
>> ( this will fail if comments aren't removed in the syntax layer since the )
=> 
>> ( interpreter expects the name immediately after 'var' )
=> 
>> var ( hello ) t33 ( there ) 1
=> 
>> 1445 t33 set! 
=> 
>> t33 ref . CR
1445 
=> 
>> ( make sure saving lambdas to vars works )
=> 
>> clear
=> 
>> { 133 244 355 } t33 set!
=> 
>> t33 ref call 
=> 133 244 355 
>> t33 ref call
=> 133 244 355 133 244 355 
>> clear
=> 
>> 123 ( make sure that ( nested ( comments ) are ) handled ok ) 456
=> 123 456 
>> ( string parsing )
=> 123 456 
>> clear
=> 
>> "hello world here"
=> "hello world here" 
>> . CR
hello world here 
=> 
>> " hello with leading trailing space "
=> " hello with leading trailing space " 
>> . CR
 hello with leading trailing space  
=> 
>> "oneword"
=> "oneword" 
>> . CR
oneword 
=> 
>> """and some embedded"quote"chars << here"""
=> """and some embedded"quote"chars << here""" 
>> . CR
""and some embedded"quote"chars << here"" 
=> 
>> ( length operator )
=> 
>> clear
=> 
>> "hello"
=> "hello" 
>> length
=> 5 
>> 'bigsymbol
=> 5 bigsymbol 
>> length
=> 5 9 
>> var x 123
=> 5 9 
>> x length
=> 5 9 123 
>> ( lists )
=> 5 9 123 
>> clear
=> 
>> 10 20 30 40 
=> 10 20 30 40 
>> 4 make-list
=> [ 10 20 30 40 ] 
>> dup length
=> [ 10 20 30 40 ] 4 
>> clear
=> 
>> 0 make-list
=> [ ] 
>> length
=> 0 
>> clear
=> 
>> 11 22 33 3 make-list
=> [ 11 22 33 ] 
>> 44 55 66 77 4 make-list
=> [ 11 22 33 ] [ 44 55 66 77 ] 
>> +
=> [ 11 22 33 44 55 66 77 ] 
>> length
=> 7 
>> clear
=> 
>> 11 22 2 make-list 33 44 55 3 make-list 66 1 make-list 0 make-list 77 88 99 3 make-list
=> [ 11 22 ] [ 33 44 55 ] [ 66 ] [ ] [ 77 88 99 ] 
>> 5 make-list
=> [ [ 11 22 ] [ 33 44 55 ] [ 66 ] [ ] [ 77 88 99 ] ] 
>> length
=> 5 
>> clear
=> 
>> "Hello" "world" 123 2 make-list "the end" 3 make-list
=> [ "Hello" [ "world" 123 ] "the end" ] 
>> ( slicing )
=> [ "Hello" [ "world" 123 ] "the end" ] 
>> clear
=> 
>> "abcdefghijklmnop" 4 5 slice
=> "efghi" 
>> "abcdefghijklmnop" -5 3 slice
=> "efghi" "lmn" 
>> "zooming" 3 100 slice
=> "efghi" "lmn" "ming" 
>> "hello world" 4 -1 slice
=> "efghi" "lmn" "ming" "o world" 
>> "questionable" 4 0 slice
=> "efghi" "lmn" "ming" "o world" "" 
>> "________X__________" 8 1 slice
=> "efghi" "lmn" "ming" "o world" "" "X" 
>> clear
=> 
>> 'hello-a-long-symbol 4 3 slice
=> o-a 
>> 'short 3 100 slice
=> o-a rt 
>> 'simple -4 2 slice
=> o-a rt mp 
>> clear
=> 
>> 10 20 30 40 50 60 70 80 90 100 10 make-list
=> [ 10 20 30 40 50 60 70 80 90 100 ] 
>> dup 4 3 slice
=> [ 10 20 30 40 50 60 70 80 90 100 ] [ 50 60 70 ] 
>> drop
=> [ 10 20 30 40 50 60 70 80 90 100 ] 
>> dup -5 4 slice
=> [ 10 20 30 40 50 60 70 80 90 100 ] [ 60 70 80 90 ] 
>> drop
=> [ 10 20 30 40 50 60 70 80 90 100 ] 
>> dup 3 100 slice
=> [ 10 20 30 40 50 60 70 80 90 100 ] [ 40 50 60 70 80 90 100 ] 
>> drop
=> [ 10 20 30 40 50 60 70 80 90 100 ] 
>> dup 6 -1 slice
=> [ 10 20 30 40 50 60 70 80 90 100 ] [ 70 80 90 100 ] 
>> drop
=> [ 10 20 30 40 50 60 70 80 90 100 ] 
>> dup 7 0 slice
=> [ 10 20 30 40 50 60 70 80 90 100 ] [ ] 
>> drop
=> [ 10 20 30 40 50 60 70 80 90 100 ] 
>> dup 7 1 slice
=> [ 10 20 30 40 50 60 70 80 90 100 ] [ 80 ] 
>> ( string / symbol make/unmake )
=> [ 10 20 30 40 50 60 70 80 90 100 ] [ 80 ] 
>> clear
=> 
>> 65 66 67 68 4 make-string
=> "ABCD" 
>> 66 67 68 69 70 5 make-symbol
=> "ABCD" BCDEF 
>> clear
=> 
>> "Hello world!" unmake
=> 72 101 108 108 111 32 119 111 114 108 100 33 12 
>> make-symbol
=> Hello world! 
>> unmake
=> 72 101 108 108 111 32 119 111 114 108 100 33 12 
>> make-string
=> "Hello world!" 
>> clear
=> 
>> { 10 20 30 40 }
=> <lambda> 
>> unmake
=> [ 10 20 30 40 ] 
>> unmake
=> 10 20 30 40 4 
>> ( type testing )
=> 10 20 30 40 4 
>> clear
=> 
>> 123 int?
=> true 
>> #123 int?
=> true false 
>> #446 float?
=> true false true 
>> 123 float?
=> true false true false 
>> "hello" string?
=> true false true false true 
>> "there" symbol?
=> true false true false true false 
>> 'world symbol?
=> true false true false true false true 
>> 'foobar string?
=> true false true false true false true false 
>> true bool?
=> true false true false true false true false true 
>> 1 bool?
=> true false true false true false true false true false 
>> null null?
=> true false true false true false true false true false true 
>> 0 null?
=> true false true false true false true false true false true false 
>> clear
=> 
>> 10 'word #13.425 3 4 5 3 make-list "end" 5 make-list
=> [ 10 word #13.425000000000001 [ 3 4 5 ] "end" ] 
>> make-lambda
=> <lambda> 
>> unmake
=> [ 10 word #13.425000000000001 [ 3 4 5 ] "end" ] 
>> unmake
=> 10 word #13.425000000000001 [ 3 4 5 ] "end" 5 
>> ( lists should share same object )
=> 10 word #13.425000000000001 [ 3 4 5 ] "end" 5 
>> clear
=> 
>> 10 20 30 3 make-list
=> [ 10 20 30 ] 
>> dup dup 
=> [ 10 20 30 ] [ 10 20 30 ] [ 10 20 30 ] 
>> 40 append ( all should change )
=> [ 10 20 30 40 ] [ 10 20 30 40 ] [ 10 20 30 40 ] 
>> ( array slices )
=> [ 10 20 30 40 ] [ 10 20 30 40 ] [ 10 20 30 40 ] 
>> clear
=> 
>> var Y 4
=> 
>> 10 Y set!
=> 
>> 20 Y 1 + set!
=> 
>> 30 Y 2 + set!
=> 
>> 40 Y 3 + set!
=> 
>> 'Y .dumpvar
=> [ 10 20 30 40 ] 
>> Y 0 -1 slice
=> [ 10 20 30 40 ] [ 10 20 30 40 ] 
>> Y 2 1 slice
=> [ 10 20 30 40 ] [ 10 20 30 40 ] [ 30 ] 
>> Y -3 2 slice
=> [ 10 20 30 40 ] [ 10 20 30 40 ] [ 30 ] [ 20 30 ] 
>> Y unmake
=> [ 10 20 30 40 ] [ 10 20 30 40 ] [ 30 ] [ 20 30 ] 10 20 30 40 4 
