\
\ 1-D cellular automata
\
\ current state is given by an arbitrary length list of 1's and 0's
\
\ rules are an 8-element list of 1's and 0's giving next state for a given
\ 3-bit input
\ 
\ next state of i'th list item:
\	1. form 3-bit number from i-1,i,i+1 elements
\	2. use as index into rules table to get next value of i'th element
\

\ uncomment one of these to turn on/off debugging

\ : ddd ( msg -- ; print msg + stack trace ) . .S CR ;
: ddd drop ;

: wrapped-index ( list index -- list adjusted-index; index wraps around )
		"W A" ddd
	dup 0 < if >>negative 
	2dup swap length >= if >>overflow
		"W A OK" ddd
	return ( index is OK )
	@negative
		over length + return
	@overflow
		over length -
		;

\ get 3-bit value (as above) for i'th list entry
: get-encoded-state ( list i -- 3-bit code )
	\ 3-bit value = list[i-1] * 4 + list[i] * 2 + list[i+1]
	\ (the i-1,i+1 are wrapped around as needed)
	2dup 1 - wrapped-index ( list i list [i-1]/wrapped )
		"A" ddd
	get 4 * >L ( list i ; L0=[i-1]*4 )
		"B" ddd
	2dup get 2 * L> + >L ( list i ; L0=[i-1]*4+[i]*2 )
	1 + wrapped-index
	get L> + ( code )
	;

\ given a current state as a list, and a rule set, calculate the next state
: next-state ( state rules -- new-state )
	[ ] >L >L ( L1 = new-state, L0 = rules )
	0
	@loop ( state i )
		2dup swap length >= if >>done
			"NS A" ddd
		2dup get-encoded-state ( state i encoded )
			"NS B" ddd
		L0 ref swap get ( state i rule )
			"NS C" ddd
		L1 ref swap ( state i newstate rule )
			"NS D" ddd
		append ( state i newstate )
			"NS E" ddd
		drop 1 + <<loop

	@done
		2drop L1 ref LP 2 + LP! ( new-state )
		;

: state2diagram ( state -- diagram )
	[ 1 == if >>one " " + return @one "*" + ] "" fold
	;

[ 0 1 0 0 0 0 0 0 ] 1 get-encoded-state . CR
[ 0 1 0 0 1 1 0 0 ] 5 get-encoded-state . CR

[ 1 0 0 0 1 1 0 1 ] 7 get-encoded-state . CR
[ 1 1 0 0 1 1 0 0 ] 0 get-encoded-state . CR

\ state
[ 0 1 1 0 1 ]
\ "rule 90" (Sierpinski triangle)
[ 0 1 0 1 1 0 1 0 ]

next-state dup . CR
state2diagram . CR

\ run nr loops of automata with initial state & rules
: run-automata ( state rules nr -- )
	@loop ( state rules nr )
		dup 0 == if >>done
		-rot ( nr state rules )
		over state2diagram . CR ( print current state )
		tuck next-state ( nr rules newstate )
		swap rot 1 - ( newstate rules nr-1 )
		<<loop
	@done
		drop drop drop
	;

\ make a new state vector with a single 1 in center
\ (returned state will always be odd sized)
: make-new-state ( length )
	2 // >L ( L0 = length//2 )
	
	0 [ dup ] L0 ref 1 - repeat
	1
	0 [ dup ] L0 ref 1 - repeat
	L0 ref 2 * 1 + make-list LP 1 + LP!
	;
	
\ state
80 make-new-state
\ rule 60
\ [ 0 0 1 1 1 1 1 0 ]
\ "rule 90" (Sierpinski triangle)
[ 0 1 0 1 1 0 1 0 ]
\ rule 62
\ [ 0 1 1 1 1 1 0 0 ]
\ rule 129 (inverse Sierpinksi triangle)
\ [ 1 0 0 0 0 0 0 1 ]
\ 45
\ [ 1 0 1 1 0 1 0 0 ]
\ 105 (another semi reverse Sierpinksi)
\ [ 1 0 0 1 0 1 1 0 ]
\ 110
\ [ 0 1 1 1 0 1 1 0 ]
\ 30 ("RNG")
\ [ 0 1 1 1 1 0 0 0 ]

40 run-automata
