\ 128-bit signed numbers.
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
\ Since verbii provides 32-bit unsigned values, I break the 128-bit number up
\ into 16-bit chunks. This allows for a 16x16 multiply without overflow.
\
\ Unlike normal 2's compliment where the 128th bit would be the sign bit, 
\ here I prepend an additional 16-bit value for the sign. This allows for
\ full 2^128 +/- range instead of +/- 2^127 as with normal 2's compliment.
\ (e.g. normally an unsigned 128-bit value would be [0..2^128] and a signed
\ value would be +/- 2^127. Here there is no difference in range for signed
\ vs unsigned ... essentially this is 129 bit math)

\ define shortcuts for direct stack access ... easier than 'pick' and
\ also allows write access with Sn!
\
\ note that the Sn! are +1 more than the Sn to skip over the top of stack
\ item which is the item being set to the stack ... i think this is more intuitive
: S0 SP ref ;
: S0! SP 1 + set! ;
: S1 SP 1 + ref ;
: S1! SP 2 + set! ;
: S2 SP 2 + ref ;
: S2! SP 3 + set! ;
: S3 SP 3 + ref ;
: S3! SP 4 + set! ;
: S4 SP 4 + ref ;
: S4! SP 5 + set! ;
: S5 SP 5 + ref ;
: S5! SP 6 + set! ;

: n128-new ( -- obj ; create a 128 bit number, set to zero )
	[ 0 0 0 0 0 0 0 0 0 ] \ 8 x 16-bit values + 1 extra for sign
	;

: hex-char-to-int ( h -- i ; convert first char of string h from hex to int )
	0 get ( c )
	dup "0" >= 
	over "9" <=
	and if >>digit 

	dup "a" >=
	over "h" <=
	and if >>hexlower 

	dup "A" >= 
	over "H" <=
	and if >>hexupper

	"Bad hex digit: " swap + error

	@digit ord "0" ord - return
	@hexlower ord "a" ord - 10 + return
	@hexupper ord "A" ord - 10 +
	;

: hex-to-int ( s -- i ; parse hex string to integer )
	{ hex-char-to-int swap 16 * + } 0 fold
	;

: n128-add ( a b -- r ; add two 128 bit numbers, producing 128 bit result )
	n128-new >L ( L0 = result )
	8 0
	@addloop ( a b i carry )
		over 0 < if >>done ( stop on i<0 )
		4 pick 3 pick get ( a b i c a[i] )
		4 pick 4 pick get ( a b i c a[i] b[i] )
		+ + ( a b i a[i]+b[i]+c )
		65536 /mod ( a b i sum% sum// )
		-rot ( a b sum// i sum% ; sum// is new carry )
		L0 ref 3 pick rot ( a b sum// i r i sum% )
		put drop ( a b sum// i )
		1 - swap <<addloop ( a b i-1 sum// )
	@done ( a b i c )
		SP 4 + SP! L> ( clear stack and leave r )
		;

"0123456789abcdefABCDEF" { "char:" . dup . "value:" . hex-char-to-int . CR } for-each

"Test hex-to-int ..." . CR
[ 	[ "1234" 4660 ]
	[ "a5b6d3" 10860243 ] 
	[ "E8B3C1A7" 3904094631 ]
	[ "FFFFFFFF" 4294967295 ]
]
	{ unmake drop "Expect:" . . CR "       " . hex-to-int . CR } for-each

: ddd . .S CR  ;

: n128-from-hex ( hex -- n ; parse hex into n128 value )
	\ see if there's a sign
	dup 0 get "-" == if >>negative-sign
	dup 0 get "+" == if >>positive-sign
	\ else no sign == +
	false >L ( L0 == true if negative )
	>>pad
	@negative-sign
		true >L
		1 -1 slice \ remove sign
		>>pad
	@positive-sign
		false >L
		1 -1 slice \ remove sign
		
	\ each digit is 16 bits -- 4 hex chars -- so make sure length is a multiple of 4
	@pad
	dup length 4 mod 0 == if >>ready
	"0" swap + \ prepend "0" until correct
	<<pad
	@ready
		\ "ready" ddd
	[ ] swap ( N hex )
	@loop ( N hex )
		\ "loop" ddd
		dup length 0 == if >>done
		\ "A" ddd
		dup 0 get hex-char-to-int 16 * ( N h h[0]*16 )
		over 1 get hex-char-to-int + 16 * ( N h h[0]*256+h[1]*16 )
		over 2 get hex-char-to-int + 16 * ( N h h[0]*4096+h[1]*256+h[2]*16 )
		over 3 get hex-char-to-int + ( N h h[0]*4096+h[1]*256+h[2]*16+h[3] )
		rot swap append swap ( N h )
		4 -1 slice ( N h[4:] )
		<<loop
	@done ( N hex )
		drop
		\ front-pad to 9 16-bit digits
		[ 0 0 0 0 0 0 0 0 ] swap + -9 -1 slice
		\ if negative, negate
		L> if >>negate
		return
		@negate n128-negate
		;

[ 	[ "1234abcd5678cdef" [ 0 0 0 0 0 4660 43981 22136 52719 ] ]
	[ "1234abcd5678cd" [ 0 0 0 0 0 18 13483 52566 30925 ] ]
	[ "1234abcd5678cdef8765DCBA4321FEDC" [ 0 4660 43981 22136 52719 34661 56506 17185 65244 ] ]
	[ "d" [ 0 0 0 0 0 0 0 0 13 ] ]
]
	{ unmake drop "Expect:" . . CR "       " . n128-from-hex . CR } for-each

: int4-to-hex ( n -- h ; 4-bit value to hex digit )
	dup 9 <= if >>digit 
	dup 16 < if >>hex 
	"Bad value in int4-to-hex:" swap str + error

	@digit "0" ord + chr return
	@hex 10 - "a" ord + chr
	;

: int8-to-hex ( n -- h ; 8-bit value to 2 hex digits )
	16 /mod int4-to-hex swap int4-to-hex +
	;

: int16-to-hex ( n -- h ; 16-bit value to 4 hex digits )
	256 /mod int8-to-hex swap int8-to-hex +
	;

: int32-to-hex ( n -- h ; 32-bit value to 8 hex digits )
	65536 /mod int16-to-hex swap int16-to-hex +
	;

\ get hex string for n128 value:
\	* assumes value is positive and prints as-is
\	* does NOT include leading sign value
: n128-to-hex-raw ( n -- hex )
	1 -1 slice { swap "." + swap int16-to-hex + } "" fold \ put dots between each 16-bits for readability
	1 -1 slice ( remove leading . )
	;

\ nice printing of n128 values with raw value included for debugging
: n128-to-hex ( n -- hex )
		\ "n128-to-hex" ddd
	\ first print as +/- value
	dup 0 get 0 == if >>positive
	n128-negate dup n128-to-hex-raw "-" swap + over n128-negate drop >>next ( n "-h" )
		\ "after -" ddd
	@positive
	dup n128-to-hex-raw "+" swap + ( n "+h" )
		\ "after +" ddd
	@next
	" [ " + ( n "+h [ " )
		\ "[" ddd
	over 0 get int16-to-hex + "|" + ( n "h|" )
		\ "|" ddd
	over n128-to-hex-raw + " ]" +
		\ "EXIT" ddd
	nip
	;


[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ]
	{ "Value:" . dup . "hex:" . int4-to-hex . CR } for-each

[ [ 104 "68" ] [ 143 "8f" ] [ 12 "0c" ] ]
	{ unmake drop "Expect:" . . CR "       " . int8-to-hex . CR } for-each

[ [ 41412 "a1c4" ] [ 36515 "8ea3" ] ]
	{ unmake drop "Expect:" . . CR "       " . int16-to-hex . CR } for-each

[ "abcDEf" "1234abcd5678cdef" "1234abcd5678cdef3210DCBA9876FEDC" ]
	{ dup . CR n128-from-hex n128-to-hex . CR } for-each
 
 \ test adding
 \ checked in python
 [ 	[ "12345678" "abcdef98" "0000|0000.0000.0000.0000.0000.0000.be02.4610" ] 
	[ "a58d3c2f52bedf65" "83bcda51a4ebf987" "0000|0000.0000.0000.0001.294a.1680.f7aa.d8ec" ] 
	[ "0a91b7703990df1f6847c0c0fe054e2a" "0ee9071bca817da22d26d97aa4cb54d0" "0000|197a.be8c.0412.5cc1.956e.9a3b.a2d0.a2fa" ]
	]
	{ unmake drop "Expect:" . . CR "       " . n128-from-hex swap n128-from-hex n128-add n128-to-hex . CR }
	for-each

\ left shift in multiples of 16-bits
\
\ assumes that n is unsigned and sets sign to 0000 (i.e. bits are NOT shifted out of
\ MSB into sign), so caller should only pass positive values
: n128-shl-x16 ( n i -- n<<(i*16) )
	swap deepcopy swap \ shift a copy not original
	tuck
	@loop ( i n i )
		dup 0 == if >>slice
		swap 0 append swap ( i n i )
		1 - <<loop
	@slice ( i n 0 )
		drop swap -1 slice
		0 0 put \ set first word (sign) to 0
	;

\ shift n << i*16 and put v in low word of result
: n128-shl-x16-in ( n i v -- (n<<(i*16)) | v - IN PLACE )
	-rot ( v n i )
	n128-shl-x16 swap ( n<<i*16 v )
	8 swap put ( put v into n[8] )
	;

"*** Test Left-Shift ********************" . CR

"abcd" n128-from-hex 0 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 1 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 2 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 3 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 4 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 5 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 6 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 7 n128-shl-x16 n128-to-hex . CR
"abcd" n128-from-hex 8 n128-shl-x16 n128-to-hex . CR

\ negate n128 value *IN PLACE*
: n128-negate ( n -- n )
	\ invert all bits first (including sign value)
		\ "Inverting" ddd
	8
	@notloop ( n i )
		dup 0 < if >>add1 ( loop until i<0 )
		2dup 2dup get bit-not 65535 bit-and put drop ( n i )
		1 - <<notloop
	@add1
	drop ( n )
	\ "ready add 1" ddd
	\ add 1 in-place (do it here instead of modifying main add function)
	8 1
	@addloop ( n i carry )
			\ "addloop" ddd
		over 0 < if >>done
		3 pick 3 pick get + ( n i c+n[i] )
			\ "n i c+n[i]" ddd
		65536 /mod ( n i c+n[i]%65536 c+n[i]//65536 )
			\ "n i sum% sum//" ddd
		>L ( n i sum% ; L0=carry )
			\ "n i sum%" ddd
		3 pick 3 pick rot put drop ( n i )
			\ "n i" ddd
		1 - L> <<addloop ( n i-1 sum// )
	@done ( n i carry )
		drop drop
		;

"*** Test Negate ****************************" . CR

: testNegate ( ASTR )
	"ASTR = " . dup . CR
	dup n128-from-hex ( ASTR a )
	swap n128-from-hex ( a a )
	n128-negate ( a -a )
	"  A = " . swap dup n128-to-hex . CR ( -a a )
	" -A = " . swap dup n128-to-hex . CR ( a -a )
	"SUM = " . n128-add n128-to-hex . CR
	;

[ "a" "1" "90000000000000000000000000000000" "12345678abcdef01" 
	"9876543210abcdef9876543210abcdef" ]
	{ testNegate } for-each
	
: n128-subtract ( a b - a-b )
	tuck n128-negate ( -b a -b )
	n128-add ( -b sum )
	swap n128-negate drop ( restore b since caller probably has a reference )
	;

: testSubtract ( ASTR BSTR )
	" ASTR = " . over . CR
	" BSTR = " . dup . CR
	n128-from-hex swap n128-from-hex ( b a )
	"    A = " . dup n128-to-hex . CR ( b a )
	"    B = " . over n128-to-hex . CR ( b a )
	over n128-subtract ( b a-b )
	"  A-B = " . dup n128-to-hex . CR ( b a-b )
	"A-B+B = " . n128-add n128-to-hex . CR 
	;

"**** Test Subtract **************************" . CR
[ [ "128" "96" ] 
	[ "abcdef0123456789ABCDEF" "88776655443322" ] 
	[ "1122334455" "abcdefABCDEF0123456789" ]

	]
	{ unmake drop testSubtract } for-each

\ n128 x 16-bit multiply
\
\ a is n128, b is 16-bit value - both are assumed to be positive so
\ caller should negate if needed and adjust afterwards
: n128-mul-16 ( a b -- a*b ; )
	\ sanity check a
	over 0 get 0 != if >>badA
	\ sanity check b
	dup dup 0 <
	swap 65535 > 
	or if >>badB

		\ "e" ddd
	\ to hold result
	n128-new >L ( a b ; L0=result )

	\ multiply b across all digits of a
	8 0
	@loop ( a b i carry )
			\ "loop" ddd
		over 0 < if >>done ( loop until i<0 )
		4 pick 3 pick get ( a b i c a[i] )
			\ "before mul" ddd
		4 pick * + ( a b i a[i]*b+c )
			\ "after * +" ddd
		\ split into 16-bit digit + carry
		65536 /mod ( a b i sum% sum// )
			\ "split" ddd
		-rot ( a b sum// i sum% )
		2dup L0 ref -rot ( a b sum// i sum% r i sum% )
			\ "before put" ddd
		put 
			\ "after put" ddd
			drop drop ( a b sum// i )
			\ "after drops" ddd
		1 - swap ( a b i-1 sum// )
		<<loop

	@badA ( a b )
		drop n128-to-hex
		"Negative A not allowed in n128-mul-16: " swap + error

	@badB ( a b )
		"B is > 16-bits in n128-mul-16: " swap str + error

	@done ( a b i c )
		SP 4 + SP! \ clear stack
		L> ( r )
		;

\ a*b where a & b are both n128. a & b are assumed to be positive, and result will always
\ have sign word set to 0000
: n128-mul ( a b -- a*b )
	n128-new >L ( L0 = result )
	8
	\ multiply each 16-bit word of b against a, shifting and summing into result
	@loop ( a b i )
		dup 1 < if >>done ( only have to multiply b[1:8], not sign digit since assumed >0 )
		2dup get ( a b i b[i] )
		4 pick swap ( a b i a b[i] )
		n128-mul-16 ( a b i a*b[i] )
			\ "after mul-16" ddd
		\ shift left by (8-i)*16-bits and add to result
		8 3 pick - ( a b i a*b[i] 8-i )
		n128-shl-x16 ( a b i (a*b[i])<<(8-i)*16 )
			\ "after shift" ddd
		L0 ref swap n128-add L0 set! ( a b i ) 
			\ "@ 1-" ddd
		1 - <<loop
	@done ( a b i )
		SP 3 + SP! ( clean stack )
		L> ( get result )
		0 0 put ( set sign to 0, per assumption at top )
		;

: testMul16 ( ASTR b )
	"ASTR = " . over . CR
	"b = " . dup . CR

	swap n128-from-hex dup "A:" . n128-to-hex . CR swap ( a b )
	n128-mul-16 ( r )
	"a*b = " . n128-to-hex . CR
	;

\ "abc" 4 testMul16
\ "abcdef0123456789ABC" 14563 testMul16

"**** 128 x 16 multiply test ..." . CR

\ values checked in Python
[ [ "abcd" 78 "0034.5876" ] 
	[ "8127bdce3841aff3" 14382 "1c57.e6a9.375c.7a4a.c5aa" ]
	\ this overflows into the sign digit but thats ok for testing
	[ "a74bc13e7f438129eeabcd3fa3847565" 61387 "9cb4.627b.955e.f01d.9212.a6da.2b1f.53a2.6217" ] ]
	{ unmake drop "Expect " . . CR testMul16 } for-each
		

\ error cases - uncomment to test
\
\ [ 123 123 123 123 123 123 123 123 123 ] 123 n128-mul-16
\
\ [ 0 0 0 0 0 0 0 0 0 ] 128237 n128-mul-16

"**** 128 x 128 multiply test ..." . CR

\ values checked in Python
[
	[ "abcd" "1234" "0000.0000.0000.0000.0000.0000.0c37.4fa4" ]
	[ "93be8ac3" "a37b1ced" "0000.0000.0000.0000.5e59.5f98.7344.ca87" ]
	[ "9dbe5af3b127da9c73bd" "5bd7aecd" "0000.3897.90e8.b5e3.6abc.2a09.c8ae.2459" ]
	[ "b1a7cd4fe8945e3c612a473b" "f48123bc" "a9ad.8e0b.073e.5010.1ee0.b7d2.4384.6054" ]
	[ "f48123bc" "b1a7cd4fe8945e3c612a473b" "a9ad.8e0b.073e.5010.1ee0.b7d2.4384.6054" ]
	\ overflow case
	[ "730192be0a3ebcfac12398eb" "9012834ebfae3acb31809234" "baa2.bff6.e0b5.aa78.d577.477f.f8f1.15bc" ]
]
	{ unmake drop "Expect " . . CR "      " . n128-from-hex swap n128-from-hex swap 
		n128-mul n128-to-hex . CR } for-each
		
\
\ FNV-1a 128-bit hash function
\
\ Constants from https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
var FNV128-PRIME 1
var FNV128-OFFSET 1
"6c62272e07bb014262b821756295c58d" n128-from-hex FNV128-OFFSET set!
"0000000001000000000000000000013B" n128-from-hex FNV128-PRIME set!

: fnv-128 ( text -- hash, as n128 )
	\ for each byte:
	\	hash = hash XOR byte (i.e. XOR against low word of n128 only)
	\	hash = hash * FNV128-PRIME

	\ called with stack: [ hash char ]
	[ 
		ord over 8 get ( hash c hash[8] )
		bit-xor ( hash c^hash[8] )
		8 swap put ( hash )
		FNV128-PRIME ref n128-mul ( hash*prime )
	]
	\ init hash = FNV128-OFFSET
	FNV128-OFFSET ref deepcopy \ deepcopy, otherwise FNV128-OFFSET would be modified
	fold
	;

"*** FNV hashing ..." . CR 
[
	\ test cases generated at: https://www.toolkitbay.com/tkb/tool/FNV-1
	[ "The quick brown fox jumped over the lazy dog."
		"0689.f441.3f88.2750.6b0b.00b3.c261.159a" ]
	[ "The quick brown fOX jumpeD over the lAzy doG!"
		"6aff.893c.2a2c.dc86.c696.3d5e.89f8.fefb" ]
	[ "Hello world!"
		"3c94.fff9.ede8.7203.1d95.566a.4577.0eb2" ]
	[ "Hello World!"
		"d2d4.2892.ede8.7203.1d25.9336.6229.c2d2" ]
	\ https://lipsum.com/feed/html
	[ "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec ac libero eu orci efficitur ultricies."
		"09f5.c1ae.a03c.ee13.7c76.3a31.881f.e3f7" ]
]
{ unmake drop "Text:   " . over . CR "Expect: " . . CR "       " . 
	fnv-128 n128-to-hex . CR } for-each
	
\
\ FNV-1a 32-bit hash function
\
\ This is much faster than fnv-128 since it uses native 32-bit integers.
\
\ Constants from https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
var FNV32-PRIME 1
var FNV32-OFFSET 1
2166136261 FNV32-OFFSET set!
16777619 FNV32-PRIME set!

: fnv-32 ( text -- hash, as integer, 32-bits )
	\ for each byte:
	\	hash = hash XOR byte
	\	hash = hash * FNV32-PRIME

	\ called with stack: [ hash char ]
	[ 
		ord bit-xor ( hash^c )
		FNV32-PRIME ref * ( hash*prime )
	]
	\ init hash = FNV32-OFFSET
	FNV32-OFFSET ref
	fold
	\ keep 32-bits only
	4294967295 bit-and ( (hash*prime)&0xffffffff )
	;

"*** FNV-32 tests ..." . CR
[
	[ "Hello world!" "7a78f512" ]
	[ "Hello World!" "b1ea4872" ]
	[ "The quick brown fox jumped over the lazy dog." "47998ae2" ]
	[ "The quick brown fOX jumpeD over the lAzy doG!" "6827f8fb" ]
	[ "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec ac libero eu orci efficitur ultricies."
		"1ef89e37" ]
]
{ unmake drop "Text:   " . over . CR "Expect: " . . CR "        " . 
	fnv-32 int32-to-hex . CR } for-each

\ find: ( list test ) return index of first element of list that satisfies test.
\       returns -1 if none found
: find ( list test -- index )
	0
	@loop ( list test i )
		dup 4 pick length >= if >>notfound ( loop until i >= len(list) )
		3 pick 2 pick get ( list test i list[i] )
		3 pick call ( list test i result )
		if >>found
		1 + <<loop ( list test i+1 )
	@found ( list test i )
		nip nip return
	@notfound
		drop drop drop -1
		;

"*** test find" . CR
"Expect 7: " . 
[ -4 -3 -2 -1 0 1 2 3 4 5 6 ] { 2 > } find . CR
"Expect 0: " .
[ -4 -3 -2 -1 0 1 2 3 4 5 6 ] { -3 < } find . CR
"Expect 10: " .
[ -4 -3 -2 -1 0 1 2 3 4 5 6 ] { 5 > } find . CR
"Expect -1: " .
[ -4 -3 -2 -1 0 1 2 3 4 5 6 ] { 10 > } find . CR

: n128-compare ( a b -- -1,0 or 1 ; -1: a<b 0: a==b 1: a>b )
		\ "cmp" ddd
	2dup 0 get swap 0 get ( a b b[0] a[0] )
		\ "B" ddd
	2dup 0 == swap 0 != ( a b b[0] a[0] a[0]==0 b[0]!=0 )
		\ "C" ddd
	and if >>greater-sign ( true if a>=0 && b<0 )
		\ "D" ddd
	0 != swap 0 == ( a b a[0]!=0 b[0]==0 )
		\ "E" ddd
	and if >>less ( true if b>=0 && a<0 )
	\ else signs are equal so test magnitudes
		\ "test mag" ddd
	2dup == if >>equal
	> if >>greater
		\ not greater and not equal, so ...
		-1 return ( a<b )
	@greater-sign ( a b b[0] a[0] )
		SP 4 + SP! 1 return ( a>b )
	@less ( a b )
		drop drop -1 return ( a<b )
	@equal ( a b )
		drop drop 0 return ( a==b )
	@greater (  )
		1 return ( a>b )
	;

\ for readability ...
: n128-greater? ( a b -- a>b )
	n128-compare 1 ==
	;

: n128-equal? ( a b -- a==b )
	n128-compare 0 == 
	;

: n128-less? ( a b -- a<b )
	n128-compare -1 ==
	;

"** n128-equal" . CR
"Expect <true>: " . "abcdef12" n128-from-hex "abcdef12" n128-from-hex n128-equal? . CR
"Expect <false>: " . "abcdef12" n128-from-hex "abcde012" n128-from-hex n128-equal? . CR
"Expect <false>: " . "abcdcf12" n128-from-hex "abcdef12" n128-from-hex n128-equal? . CR

"** n128-greater, # >0" . CR
"Expect <false>: " . "12345678abcd" n128-from-hex "12345678abcd" n128-from-hex n128-greater? . CR
"Expect <true>: " . "12345678bbcd" n128-from-hex "12345678abcd" n128-from-hex n128-greater? . CR
"Expect <false>: " . "12345678abcd" n128-from-hex "12345678bbcd" n128-from-hex n128-greater? . CR

"** n128-greater, # < 0" . CR
"Expect <false>: " . "-12345678abcd" n128-from-hex "-12345678abcd" n128-from-hex n128-greater? . CR
"Expect <false>: " . "-12345678bbcd" n128-from-hex "-12345678abcd" n128-from-hex n128-greater? . CR
"Expect <true>: " . "-12345678abcd" n128-from-hex "-12345678bbcd" n128-from-hex n128-greater? . CR

"** n128-greater, opposite signs" . CR
"Expect <false>: " . "-12345678abcd" n128-from-hex "12345678abcd" n128-from-hex n128-greater? . CR
"Expect <true>: " . "12345678abcd" n128-from-hex "-12345678abcd" n128-from-hex n128-greater? . CR

"** n128-less, # > 0" . CR
"Expect <false>: " . "12345678abcd" n128-from-hex "12345678abcd" n128-from-hex n128-less? . CR
"Expect <false>: " . "12345678bbcd" n128-from-hex "12345678abcd" n128-from-hex n128-less? . CR
"Expect <true>: " . "12345678abcd" n128-from-hex "12345678bbcd" n128-from-hex n128-less? . CR

"** n128-less, # < 0" . CR
"Expect <false>: " . "-12345678abcd" n128-from-hex "-12345678abcd" n128-from-hex n128-less? . CR
"Expect <true>: " . "-12345678bbcd" n128-from-hex "-12345678abcd" n128-from-hex n128-less? . CR
"Expect <false>: " . "-12345678abcd" n128-from-hex "-12345678bbcd" n128-from-hex n128-less? . CR

"** n128-less, opposite signs" . CR
"Expect <true>: " . "-12345678abcd" n128-from-hex "12345678abcd" n128-from-hex n128-less? . CR
"Expect <false>: " . "12345678abcd" n128-from-hex "-12345678abcd" n128-from-hex n128-less? . CR
	
"Expect ffff.ffff.ffff.ffff.ffff.5432.fedc.789b" . CR
"-abcd01238765" n128-from-hex n128-to-hex "     " . . CR

"-abcd01238765fedc6543dcba3210cdef" n128-from-hex n128-to-hex "     " . . CR

"Expect 0:" . CR
"83bd82abcde09076b31cabefd8493021" n128-from-hex 
"-83bd82abcde09076b31cabefd8493021" n128-from-hex
n128-add n128-to-hex . CR

: n128-zero? ( a -- a==0? )
	{ 0 != } find -1 == 
	;

"Expect true:" . CR
"0" n128-from-hex n128-zero? . CR

"Expect false:" . CR
"1" n128-from-hex n128-zero? . CR

\ get i'th most significant word from n128
\ *assumes a is > 0*
\ ex: [ 0 0 0 123 456 ] -- msw[0] == 123, msw[1] == 456
: n128-get-msw ( a i -- get i'th most significant word )
	\ find first nonzero word
	over { 0 > } find
	\ check for errors
	dup 0 == if >>got-negative
	dup -1 == if >>not-found
	+ \ a msw+i
	2dup over length >= ( a m+i a m+i>=len[a] )
	if >>out-of-bounds
	drop get return ( a[m+i] )

	@got-negative "Negative value in n128-get-msw not allowed" error
	@not-found "Zero not allowed in n128-get-msw" error
	;

"** n128-get-msw:" . CR
"12345678abcd" n128-from-hex 
"Expect 4660:" .
dup 0 n128-get-msw . CR
"Expect 22136:" . 
dup 1 n128-get-msw . CR
"Expect 43981:" .
dup 2 n128-get-msw . CR
drop

\ 'significant' meaning the number of words starting at the first nonzero word from the left side
\ 'a' must be > 0
\ in this context, trailing zeros are still considered significant
: n128-nr-sigwords ( a -- #significant words in a )
		\ "count sigwords" ddd
	{ 0 > } find
		\ "find result" ddd
	dup -1 == if >>not-found
	9 swap - return ( 9-i )

	@not-found "Zero not allowed in n128-nr-sigwords" error
	;

"Expect 2:" . 
"12345678" n128-from-hex n128-nr-sigwords . CR
"Expect 3:" . 
"123456780" n128-from-hex n128-nr-sigwords . CR
"Expect 4:" .
"abcd01234567cdef" n128-from-hex n128-nr-sigwords . CR
"Expect 5:" .
"abcd01234567cdef123" n128-from-hex n128-nr-sigwords . CR