 
\ Various numeric functions
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE

\ ======================================================================
\ Constants
\ ======================================================================
'PI    3.141592653589793 make-const \ to limit of double precision
'E-VAL 2.718281828459045 make-const

\ max unsigned 32-bit value
'MAX-INT32 4294967295 make-var

\ FLOAT-MAX SHOULD BE: 1.7976931348623157E+308
\ however, chicken seems to not be able to print this and rounds it to 1.79769313486232E+308,
\ which is too large for a double. so if the chicken port creates a .b file containing 1.7976931348623157E+308,
\ it will be serialized as an invalid value and crash the other ports when they try to load it.
\ so the FLOAT-MAX below is the highest exact value that chicken will print correctly.
\
\ random trivia: the real value of FLOAT-MAX, in hex, is 0x7fefffffffffffff
\ so i decremented that until i got a value that ended in 14x instead of 15x.
\ the hex value of the number below is 0x7feffffffffffffb
'FLOAT-MAX 1.7976931348623149E+308 make-const
'FLOAT-MIN -1.7976931348623149E+308 make-const

\ ( n -- ; get n as binary string )
: str.bin
	32 "" -rot
	@loop ( s n i )
		dup 0 == if >>done ( i==0? )
		over 1 bit-and 0 == if >>zero
			rot "1" swap + -rot >>next ( prepend 1 )
		@zero
			rot "0" swap + -rot ( prepend 0 )
		@next ( s n i )
			swap 1 bit-shr swap 1 - ( s n>>1 --i )
			<<loop
	@done
		drop drop ( leave string on stack )
		\ put in dotted form for readability
		dup 0 8 slice "." + swap
		dup 8 8 slice "." + swap 
		dup 16 8 slice "." + swap 
		24 8 slice
		+ + + 
		;

\ ======================================================================
\ Parsing & printing of hex values
\ ======================================================================

\ convert char h from hex to int
: hex-char-to-int ( h -- i )
	h "0" >= 
	h "9" <=
	and if >>digit 

	h "a" >=
	h "h" <=
	and if >>hexlower 

	h "A" >= 
	h "H" <=
	and if >>hexupper

	"Bad hex digit: " h + error

	@digit h ord "0" ord - return
	@hexlower h ord "a" ord - 10 + return
	@hexupper h ord "A" ord - 10 + return
	;

\ parse hex string to integer -- hex must NOT have leading "0x"; ONLY hex digits
: parse-hex ( hex -- i )
	\ fold
	hex
	{ ( accum h ) 
		h hex-char-to-int 
		accum 16 * + 
	} 0 fold
	;

\ 4-bit value to hex digit
\ ( n -- h )
: int4-to-hex 
	dup 9 <= if >>digit 
	dup 16 < if >>hex 
	"Bad value in int4-to-hex:" swap str + error

	@digit "0" ord + chr return
	@hex 10 - "a" ord + chr
	;

\ 8-bit value to 2 hex digits )
\ ( n -- h )
: int8-to-hex 
	16 /mod int4-to-hex swap int4-to-hex +
	;

\ 16-bit value to 4 hex digits
\ ( n -- h )
: int16-to-hex
	256 /mod int8-to-hex swap int8-to-hex +
	;

\ 32-bit value to 8 hex digits )
\ ( n -- h )
: int32-to-hex
	65536 /mod int16-to-hex swap int16-to-hex +
	;

\ shortcut - int to hex string
\ - always unsigned
\ - does NOT prepend "0x", only returns the hex digits
\
\ ( val -- hexstring )
: str.hex int32-to-hex ;

\ ======================================================================
\ More bit operations (all 32-bit)
\ ======================================================================

\ rotate X left by K bits
: bit-rotl ( x k )
	\ (x << k) | (x >> (32 - k))
	x k bit-shl
	x 32 k - bit-shr
	bit-or
	;
	
\ rotate Y right by K bits
: bit-rotr ( x k )
	\ (x >> k) | (x << (32 - k)) 
	x k bit-shr 
	x 32 k - bit-shl 
	bit-or
	;
	
\ takes any integer and returns lower 32 bits
: bit-low32 ( val ) val 4294967295 bit-and ;

\ count number of 1 bits in low 32 bits of x (slow version, meant for generating lookup table)
: bit-count-ones-slow ( x -- count )
	@locals [ n ]
	32 n!
	0 count!
	@loop
		n 0 == if >>done 
		x 1 bit-and 0 == if >>next 
		count 1 + count!
	@next
		x 1 bit-shr x!
		n 1 - n! <<loop
	@done
		count
	;

\ generated table for fast counting of 1's
'BIT-COUNT-ONES-LOOKUP-TABLE null make-var 

\ generate the above table for all 8 bit values
: generate-bit-count-ones-lookup-table 
	@locals [ list ]
	[ ] list!
	{ ( x )
		list
			x bit-count-ones-slow append!
	} 0 1 256 for-count 
	
	list BIT-COUNT-ONES-LOOKUP-TABLE!
	;
	
\ count number of 1 bits in low 32 bits of x (fast version)
: bit-count-ones ( x -- count )
	BIT-COUNT-ONES-LOOKUP-TABLE null? not if >>ok
	generate-bit-count-ones-lookup-table 
	@ok
	0 count!
	\ count each 8-bit segment of x and sum
	count BIT-COUNT-ONES-LOOKUP-TABLE x 255 bit-and get + count!
	count BIT-COUNT-ONES-LOOKUP-TABLE x 8 bit-shr 255 bit-and get + count!
	count BIT-COUNT-ONES-LOOKUP-TABLE x 16 bit-shr 255 bit-and get + count!
	count BIT-COUNT-ONES-LOOKUP-TABLE x 24 bit-shr 255 bit-and get + count!
	count
	;
	
\ find first (leftmost) 1 bit in low 32 bits of x (slow version meant for pregenerating table)
\ returns as index from left side (so high bit == index 0, lowest bit == index 31)
\
\ return void if no 1 bits
: bit-first-one-slow ( x -- index )
	@locals [ nr ]
	\ quick test first then don't have to count bits later
	x bit-low32 0 == if >>zero
	\ now i know the loop below will end
	0 index!
	@loop
		x 2147483648 bit-and 0 != if >>found 
		x 1 bit-shl x!
		index 1 + index!
		<<loop
	@found
		index return
	@zero 
		void 
	;
		
\ pregenerated lookup table for all 8 bit values
'BIT-FIRST-ONE-LOOKUP-TABLE null make-var

\ create lookup table
: generate-bit-first-one-lookup-table 
	@locals [ list ]
	[ ] list!
	{ ( x ) list
			x 24 bit-shl bit-first-one-slow append!
	} 0 1 256 for-count 
	
	list BIT-FIRST-ONE-LOOKUP-TABLE!
	\ "TABLE:" . list . CR
	;
	
\ find first (leftmost) 1 bit in low 32 bits of x (fast version)
\ returns as index from left side (so high bit == index 0, lowest bit == index 31)
\
\ return void if no 1 bits
: bit-first-one ( x )
	@locals [ i ]
	\ generate table if needed
	BIT-FIRST-ONE-LOOKUP-TABLE null? not if >>ok 
	generate-bit-first-one-lookup-table
	@ok
	\ check from high byte to low byte 
	BIT-FIRST-ONE-LOOKUP-TABLE x 24 bit-shr 255 bit-and get i!
	i void != if >>found1
	BIT-FIRST-ONE-LOOKUP-TABLE x 16 bit-shr 255 bit-and get i!
	i void != if >>found2
	BIT-FIRST-ONE-LOOKUP-TABLE x 8 bit-shr 255 bit-and get i!
	i void != if >>found3
	BIT-FIRST-ONE-LOOKUP-TABLE x 255 bit-and get i!
	i void != if >>found4
	\ no 1 bits
	void return
	@found1 i return
	@found2 i 8 + return
	@found3 i 16 + return
	@found4 i 24 + return
	;	
	
\ ======================================================================
\ Statistics
\ ======================================================================

\ calculate average of a list of numbers
: average ( numbers -- avg )
	@locals [ sum i ]
	0 i!
	0.0 sum!
	@loop
		numbers i get void? if >>done 
		numbers i get sum + sum!
		i 1 + i! <<loop
	@done
		sum numbers length /
	;

: *stddev.generic ( numbers NRDIV -- s )
	@locals [ mean sum i ]
	numbers average mean!
	0 sum!
	0 i!
	@loop
		numbers i get void? if >>done-sum
		numbers i get mean - 2 pow sum + sum!
		i 1 + i! <<loop
	@done-sum
		sum NRDIV / sqrt
	;
	
\ calculate standard deviation (total population) of a list of numbers
: stddev.p ( numbers -- s )
	numbers numbers length *stddev.generic
	;
	
\ calculate standard deviation (sample) of a list of numbers
: stddev.s ( numbers -- s )
	numbers length 2 < if >>error
	numbers numbers length 1 - *stddev.generic
	return
	@error "Need at least 2 values in stddev.s, got: " numbers repr + error
	;
	
	
	
		
		
		
		