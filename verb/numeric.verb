 
\ Various numeric functions
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE

\ ======================================================================
\ Constants
\ ======================================================================
'PI    3.141592653589793 make-const \ to limit of double precision
'E-VAL 2.718281828459045 make-const

\ FLOAT-MAX SHOULD BE: 1.7976931348623157E+308
\ however, chicken seems to not be able to print this and rounds it to 1.79769313486232E+308,
\ which is too large for a double. so if the chicken port creates a .b file containing 1.7976931348623157E+308,
\ it will be serialized as an invalid value and crash the other ports when they try to load it.
\ so the FLOAT-MAX below is the highest exact value that chicken will print correctly.
\
\ random trivia: the real value of FLOAT-MAX, in hex, is 0x7fefffffffffffff
\ so i decremented that until i got a value that ended in 14x instead of 15x.
\ the hex value of the number below is 0x7feffffffffffffb
'FLOAT-MAX 1.7976931348623149E+308 make-const
'FLOAT-MIN -1.7976931348623149E+308 make-const

\ ( n -- ; get n as binary string )
: str.bin
	32 "" -rot
	@loop ( s n i )
		dup 0 == if >>done ( i==0? )
		over 1 bit-and 0 == if >>zero
			rot "1" swap + -rot >>next ( prepend 1 )
		@zero
			rot "0" swap + -rot ( prepend 0 )
		@next ( s n i )
			swap 1 bit-shr swap 1 - ( s n>>1 --i )
			<<loop
	@done
		drop drop ( leave string on stack )
		\ put in dotted form for readability
		dup 0 8 slice "." + swap
		dup 8 8 slice "." + swap 
		dup 16 8 slice "." + swap 
		24 8 slice
		+ + + 
		;

\ ======================================================================
\ Parsing & printing of hex values
\ ======================================================================

\ convert char h from hex to int
: hex-char-to-int ( h -- i )
	h "0" >= 
	h "9" <=
	and if >>digit 

	h "a" >=
	h "h" <=
	and if >>hexlower 

	h "A" >= 
	h "H" <=
	and if >>hexupper

	"Bad hex digit: " h + error

	@digit h ord "0" ord - return
	@hexlower h ord "a" ord - 10 + return
	@hexupper h ord "A" ord - 10 + return
	;

\ parse hex string to integer -- hex must NOT have leading "0x"; ONLY hex digits
: parse-hex ( hex -- i )
	\ fold
	hex
	{ ( accum h ) 
		h hex-char-to-int 
		accum 16 * + 
	} 0 fold
	;

\ 4-bit value to hex digit
\ ( n -- h )
: int4-to-hex 
	dup 9 <= if >>digit 
	dup 16 < if >>hex 
	"Bad value in int4-to-hex:" swap str + error

	@digit "0" ord + chr return
	@hex 10 - "a" ord + chr
	;

\ 8-bit value to 2 hex digits )
\ ( n -- h )
: int8-to-hex 
	16 /mod int4-to-hex swap int4-to-hex +
	;

\ 16-bit value to 4 hex digits
\ ( n -- h )
: int16-to-hex
	256 /mod int8-to-hex swap int8-to-hex +
	;

\ 32-bit value to 8 hex digits )
\ ( n -- h )
: int32-to-hex
	65536 /mod int16-to-hex swap int16-to-hex +
	;

\ shortcut - int to hex string
\ - always unsigned
\ - does NOT prepend "0x", only returns the hex digits
\
\ ( val -- hexstring )
: str.hex int32-to-hex ;

\ ======================================================================
\ More bit operations (all 32-bit)
\ ======================================================================

\ rotate X left by K bits
: bit-rotl ( x k )
	\ (x << k) | (x >> (32 - k))
	x k bit-shl
	x 32 k - bit-shr
	bit-or
	;
	
: bit-low32 ( val ) val 4294967295 bit-and ;

