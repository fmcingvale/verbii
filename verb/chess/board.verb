\ Simple chess engine - purely for fun, not practicality :-)
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
	
\ chess code starts here
	
\ pieces
: P_PAWN 0 ;
: P_KNIGHT 1 ;
: P_BISHOP 2 ;
: P_ROOK 3 ;
: P_QUEEN 4 ;
: P_KING 5 ;
: P_NONE 6 ;

'PIECE-CHARS [ "P" "N" "B" "R" "Q" "K" "." ] make-var

\ sides
: WHITE 0 ;
: BLACK 1 ;
: other ( side -- other ) 1 + 2 mod ;

\ ------ board state -------

\ coordinates: row=0,col=0 is a1; row=0,col=7 is h1; row=7,col=7 is h8

\ pieces list (P_*), 1 for each square
'PIECES null make-var
	
\ colors list (WHITE|BLACK), 1 for each square
'COLORS null make-var

\ must call this at least once to init board state
: clear-board ( -- ) 
	[ ] PIECES!
	{ PIECES P_NONE append drop } 0 1 64 for-range
	[ ] COLORS!
	{ COLORS WHITE append drop } 0 1 64 for-range
	;
	
\ get square (0..63) given row,col
: square-index ( row col -- square )
	swap 8 * + 
	;
	
\ get printable char for piece at square
: piece-char-at @( square -- char )
	COLORS square get WHITE == if >>white
	PIECE-CHARS PIECES square get get tolower return \ black = lowercase
	@white PIECE-CHARS PIECES square get get
	;

\ parse a piece char into its P_* and color	
: char-to-piece @( char -- piece color )
	@locals [ ip ]
	PIECE-CHARS @{ char toupper == } find ip! \ find index into PIECE_CHARS
	ip void? if >>bad-char
	char upper? if >>white
	ip BLACK return 
	@white ip WHITE return
	@bad-char "Bad piece character:" char str + error
	;

: print-board ( -- )
	@locals [ row col ]
	0 row!
	@loop-row
		row 8 >= if >>done-board
		0 col!
		@loop-col
			col 8 >= if >>done-row
			7 row - col square-index piece-char-at .
			col 1 + col! <<loop-col
		@done-row
			CR
			row 1 + row! <<loop-row
	@done-board
	;
	
: put-piece @( square piece color -- )
	PIECES square piece put 
	COLORS square color put 
	;
	
\ set board state from a FEN string
: fen-parse-string @( fen -- )
	@locals [ parts row col c i ]
	clear-board
	\ split string into its fields
	fen " " string-split parts!
		"FEN PARTS:" . parts . CR
		
	\ parse pieces, e.g. "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"
	7 row!
	0 col!
	0 i!
	@pieces-loop
		parts 0 get i get c! \ next char of string
			"ROW=" . row . "COL=" . col . "CHAR:" . c . CR
		c void? if >>pieces-end-string 
		c digit? if >>pieces-blanks \ got # for blank squares
		c "/" == if >>pieces-slash
		\ else it must be a piece for (row,col)
		row col square-index c char-to-piece 
			"CHAR TO PIECE:" . dup . CR 
			put-piece
		col 1 + col! >>pieces-next
	@pieces-blanks
		c parse-int col + col! \ skip # blanks
		>>pieces-next
	@pieces-slash
		row 1 - row! 0 col! >>pieces-next
	@pieces-next
		i 1 + i! <<pieces-loop
	@pieces-end-string
		row 0 == col 8 == and if >>pieces-ok
		"Pieces string too short in FEN:" parts 0 get + error
		
	@pieces-ok
	;
	
clear-board
"PIECES:" . PIECES . CR
"COLORS:" . COLORS . CR

31 P_BISHOP WHITE put-piece 
19 P_ROOK BLACK put-piece

4 "K" char-to-piece put-piece

print-board

"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" fen-parse-string

print-board

"rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2" fen-parse-string
print-board

'FOO 123 make-var
"WORDS:" . CR
"FOO:" . 'FOO .dumpword . CR
"FOO!:" . 'FOO! .dumpword . CR

"FOO IS:" . FOO . CR
"SET FOO TO 'abcde'" . CR
"abcde" FOO!
"FOO IS:" . FOO . CR

	
			
			
			
