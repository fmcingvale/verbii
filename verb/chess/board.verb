\ Simple chess engine - purely for fun, not practicality :-) Very simple & slow design.
\ Also this is a semi-real app so makes a better excercise for programming in verbii
\ versus the shorter demos.
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
	
\ chess code starts here
	
\ pieces
: P-PAWN 0 ;
: P-KNIGHT 1 ;
: P-BISHOP 2 ;
: P-ROOK 3 ;
: P-QUEEN 4 ;
: P-KING 5 ;
: P-NONE 6 ;

'PIECE-CHARS [ "P" "N" "B" "R" "Q" "K" "." ] make-var

\ sides
: WHITE 0 ;
: BLACK 1 ;
( side -- other )
: other 1 + 2 mod ;

\ ------ board state -------

\ coordinates: row=0,col=0 is a1; row=0,col=7 is h1; row=7,col=7 is h8

\ pieces list (P-*), 1 for each square
'PIECES null make-var
	
\ colors list (WHITE|BLACK), 1 for each square
'COLORS null make-var

\ side to move next - WHITE or BLACK
'SIDE-TO-MOVE WHITE make-var

\ castling availability as bools
'CASTLING_W_OO false make-var
'CASTLING_W_OOO false make-var
'CASTLING_B_OO false make-var
'CASTLING_B_OOO false make-var

\ en-passant target square [0-63] or -1
\ this is the square directly BEHIND (relative to its kindside) 
\ the pawn that just jumped two squares
'EPSQUARE -1 make-var

\ halfmove number for 50-move rule
'HALFMOVE 0 make-var

\ fullmove number
'FULLMOVE 0 make-var

\ epsquare, halfmove and castling status are difficult or not possible
\ to reconstruct from just the previous move, so save them on an undo stack
'UNDO-STACK [ ] make-var

\ track king squares
'KING-SQUARE-W -1 make-var
'KING-SQUARE-B -1 make-var 

\ must call this at least once to init board state
: clear-board ( -- ) 
	[ ] PIECES!
	{ ( i ) PIECES P-NONE append! } 0 1 64 for-count
	[ ] COLORS!
	{ ( i ) COLORS WHITE append! } 0 1 64 for-count
	WHITE SIDE-TO-MOVE!
	true CASTLING_W_OO!
	true CASTLING_W_OOO!
	true CASTLING_B_OO!
	true CASTLING_B_OOO!
	-1 EPSQUARE!
	\ set these to invalid
	-1 KING-SQUARE-W!
	-1 KING-SQUARE-B!
	;
	
\ get square (0..63) given row,col
\ ( row col -- square )
: square-index
	swap 8 * + 
	;
	
\ get row,col from square index
\ ( square -- row col )
: square-to-rowcol 
	8 /mod swap
	;
	
\ get piece at square
: piece-at ( square )
	PIECES square get
	;
	
\ get color at square (only valid if piece != P-NONE)
: color-at ( square )
	COLORS square get
	;
	
\ get printable char for given piece & color
: piece-char ( piece color -- char )
	color WHITE == if >>white
	PIECE-CHARS piece get tolower return \ black = lowercase
	@white PIECE-CHARS piece get
	;
	
\ get printable char for piece at square
: piece-char-at ( square -- char )
	PIECES square get
	COLORS square get
		piece-char
	;

\ parse a piece char into its P-* and color	
: char-to-piece ( char -- piece color )
	@locals [ ip ]
	PIECE-CHARS { char toupper == } find ip! \ find index into PIECE_CHARS
	ip void? if >>bad-char
	char upper? if >>white
	ip BLACK return 
	@white ip WHITE return
	@bad-char "Bad piece character:" char str + error
	;

\ convert square (0..63) to algebraic notation
: square-to-algebraic ( square )
	square 8 /mod ( remainder quot )
	swap "a" ord + chr
	swap "1" ord + chr +
	;

\ convert algebraic notation (a1..h8) to square (0..63)
: algebraic-to-square ( alg )
	alg string? not if >>bad-alg
	alg length 2 != if >>bad-alg
	"abcdefgh" { alg 0 get == } find void? if >>bad-alg
	"12345678" { alg 1 get == } find void? if >>bad-alg
	alg 1 get ord "1" ord - 8 * 
	alg 0 get ord "a" ord - +
	return

	@bad-alg
		"Bad algebraic coordinate:" alg str + error
	;

: print-board ( -- )
	@locals [ row col ]
	0 row!
	@loop-row
		row 8 >= if >>done-board
		0 col!
		@loop-col
			col 8 >= if >>done-row
			7 row - col square-index piece-char-at .
			col 1 + col! <<loop-col
		@done-row
			CR
			row 1 + row! <<loop-row
	@done-board

	\ side to move
	"Side to move:" .
	SIDE-TO-MOVE WHITE == 
		{ "white" . CR } { "black" . CR } ifelse

	\ castling status
	"Castling:" .
	CASTLING_W_OO { "K" puts } ifthen
	CASTLING_W_OOO { "Q" puts } ifthen
	CASTLING_B_OO { "k" puts } ifthen
	CASTLING_B_OOO { "q" puts } ifthen
	\ if no castling available, print - 
	CASTLING_W_OO 
	CASTLING_W_OOO
	CASTLING_B_OO 
	CASTLING_B_OOO
		or or or not { "-" . } ifthen
	CR
	
	"Ep-Target:" . 
	EPSQUARE -1 ==
		{ "None" . }
		{ EPSQUARE square-to-algebraic . }
		ifelse CR	
	
	"Halfmove:" . HALFMOVE .. ", Fullmove:" . FULLMOVE . CR
	;
	
: put-piece ( square piece color -- )
	PIECES square piece put!
	COLORS square color put!
	piece P-KING != if >>done
	\ update king square
	WHITE color == if >>white
	\ black
	square KING-SQUARE-B! >>done
	@white square KING-SQUARE-W!
	@done
	;

: square-empty? ( square -- result )
	PIECES square get P-NONE ==
	;
	
\ put & drop result, since normally putting into an object that
\ code has saved a ref to
: put! put drop ;
\ same for append
: append! append drop ;
\ and for extend
: extend! extend drop ;

\ set board state from a FEN string
: set-from-fen ( fen -- )
	@locals [ parts row col c i ]
	clear-board
	\ split string into its fields
	fen " " string-split parts!
		\ "FEN PARTS:" . parts . CR
		
	\ parse pieces, e.g. "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"
	7 row!
	0 col!
	0 i!
	@pieces-loop
		parts 0 get i get c! \ next char of string
			\ "ROW=" . row . "COL=" . col . "CHAR:" . c . CR
		c void? if >>pieces-end-string 
		c digit? if >>pieces-blanks \ got # for blank squares
		c "/" == if >>pieces-slash
		\ else it must be a piece for (row,col)
		row col square-index c char-to-piece 
			\ "CHAR TO PIECE:" . dup . CR 
			put-piece
		col 1 + col! >>pieces-next
	@pieces-blanks
		c parse-int col + col! \ skip # blanks
		>>pieces-next
	@pieces-slash
		row 1 - row! 0 col! >>pieces-next
	@pieces-next
		i 1 + i! <<pieces-loop
	@pieces-end-string
		row 0 == col 8 == and if >>pieces-ok
		"Pieces string too short in FEN:" parts 0 get + error
		
	@pieces-ok

	\ parts[1] is "w" or "b" to move next
	parts 1 get
	[
		[ [ "w" ] { WHITE SIDE-TO-MOVE! } ]
		[ [ "b" ] { BLACK SIDE-TO-MOVE! } ]
		[ else { "Bad side to move in FEN string" error } ]
	]
	case

	\ parts[2] is castling availability - any of KQkq-
	\ set initially to none
	false CASTLING_W_OO!
	false CASTLING_W_OOO!
	false CASTLING_B_OO!
	false CASTLING_B_OOO!
		\ K?
		parts 2 get { "K" == } find void? if >>check-W-OOO
		true CASTLING_W_OO!
	@check-W-OOO
		\ Q?
		parts 2 get { "Q" == } find void? if >>check-B-OO
		true CASTLING_W_OOO!
	@check-B-OO
		\ k?
		parts 2 get { "k" == } find void? if >>check-B-OOO
		true CASTLING_B_OO!
	@check-B-OOO
		\ q?
		parts 2 get { "q" == } find void? if >>castling-done
		true CASTLING_B_OOO!
	@castling-done

	\ parts[3] is en-passant target square or '-' if none
	parts 3 get "-" == 
		{ -1 EPSQUARE! }
		{ parts 3 get algebraic-to-square EPSQUARE! }
		ifelse
	
	\ parts[4] is halfmove number
	parts 4 get parse-int HALFMOVE!
		
	\ parts[5] is fullmove
	parts 5 get parse-int FULLMOVE!
	;

clear-board

: valid-rowcol? ( row col )
	row 0 >=
	row 8 <
	col 0 >=
	col 8 <
	and and and
	;
	
\ for pieces that have fixed attack spaces relative to their position (kings, knights)
\
\ square = square that piece is assumed to be on
\ moves = list of [ dRow dCol ] (delta row/col) to move from square
\
\ this only returns squares that the piece COULD attack; caller must still check if there
\ is a piece on the square or not
: gen-fixed-attacks ( square moves -- attacks )
	@locals [ row col row+ col+ ]
	[ ] attacks!
	square square-to-rowcol col! row!
	moves
	{ ( move )
		\ calc row+dRow, col+dCol and see if that is a valid square
		row move 0 get + row+!
		col move 1 get + col+!
		row+ col+ valid-rowcol? not if >>done
		\ valid, so add square to attacks
		attacks row+ col+ square-index append attacks!
		@done
	} for-each
	
	attacks
	;

\ generate a table of all fixed attacks for a piece at each square
: gen-all-fixed-attacks ( moves -- attack-table ) 
	[ ] attack-table!
	{ ( square )
		attack-table
			square moves gen-fixed-attacks
			append attack-table!
	} 0 1 64 for-count
	attack-table
	;
	
\ generate attack squares for sliding pieces - pieces moves from square along (dRow,dCol) direction
\
\ squares are returned as a list of empty squares + the final blocked square, or void if all are empty
: gen-sliding-attacks ( square dRow dCol -- attacks blocked )
	@locals [ row col ]
	[ ] attacks!
	square square-to-rowcol col! row!
	@loop
		row dRow + row!
		col dCol + col!
		row col valid-rowcol? not if >>off-board 
		row col square-index square!
		square piece-at P-NONE != if >>blocked 
		\ valid & empty -- add to attacks
		attacks square append! <<loop
	@off-board
		\ all were empty and i went off side of board, so
		\ no square was blocked
		attacks void return
	@blocked
		\ square is blocked (be either side) so stop & return
		attacks square return
	;

\ generate sliding attacks for multiple direction vectors
\	movedirs is list of [ dRow dCol ]		
\
\ here, blockers is always a list (can be empty)
: gen-all-sliding-attacks ( square movedirs -- attacks blockers )
	[ ] attacks!
	[ ] blockers!
	movedirs
	{ ( dir )
		square dir unmake drop gen-sliding-attacks \ ( attacks blocked )
		\ if blocked is not void, add to blockers list
		dup void? not
			{ blockers swap append blockers! }
			{ drop } ifelse
			
		\ add attacks to list (use extend so i don't change object identity vs attacks
		\ defined in outer scope!)
		attacks swap extend attacks!
	} for-each
	
	attacks blockers
	;
	
\ generate attacks for king of given side at square (king does not have
\ to actually be there); these will be ALL squares the king can reach,
\ regardless of whether something is on the destination square
'KING-MOVEDIRS [ [ 1 0 ] [ -1 0 ] [ 0 1 ] [ 0 -1 ] [ 1 1 ] [ 1 -1 ] [ -1 1 ] [ -1 -1 ] ] make-var

\ pregenerated list of king attacks indexed by square
'KING-ATTACKS-BY-SQUARE [ ] make-var

\ pregenerate KING-ATTACKS-BY-SQUARE
: gen-all-king-attacks ( -- ) 
	KING-MOVEDIRS gen-all-fixed-attacks
		KING-ATTACKS-BY-SQUARE!
	;
	
\ generate attacks for knight of given side at square (knight does not have
\ to actually be there); these will be ALL squares the knight can reach,
\ regardless of whether something is on the destination square
'KNIGHT-MOVEDIRS [ [ 2 1 ] [ 2 -1 ] [ -2 1 ] [ -2 -1 ] [ 1 2 ] [ 1 -2 ] [ -1 2 ] [ -1 -2 ] ] make-var

\ pregenerated list of knight attacks indexed by square
'KNIGHT-ATTACKS-BY-SQUARE [ ] make-var

\ pregenerate KNIGHT-ATTACKS-BY-SQUARE
: gen-all-knight-attacks ( -- ) 
	KNIGHT-MOVEDIRS gen-all-fixed-attacks
		KNIGHT-ATTACKS-BY-SQUARE!
	;

\ make list of squares a pawn at square of given side can attack
\ (a piece must be at the destination square)
\ en-passant is NOT checked here -- it is not an attack that can attack
\ the king which is a primary use of the attacks lists.
: gen-pawn-attacks ( square side -- attacks )
	@locals [ row col ]
	[ ] attacks!
	
	side BLACK == if >>black
	\ gen for white pawn
	square square-to-rowcol col! row!
	row 7 >= if >>no-attacks \ pawn on last row?? anyways, cannot attack
	\ attack left?
	col 1 >=
	square 7 + piece-at P-NONE !=
	square 7 + color-at BLACK ==
		and and not if >>check-w-cap-right
		attacks square 7 + append attacks!
		
	@check-w-cap-right
	col 7 <
	square 9 + piece-at P-NONE !=
	square 9 + color-at BLACK ==
		and and not if >>done
		attacks square 9 + append attacks!
		>>done
	
	@black
	\ gen for black pawn
	square square-to-rowcol col! row!
	row 0 <= if >>no-attacks \ pawn on last row?? anyways, cannot attack
	\ attack left?
	col 1 >=
	square 9 - piece-at P-NONE !=
	square 9 - color-at WHITE ==
		and and not if >>check-b-cap-right
		attacks square 9 - append attacks!
		
	@check-b-cap-right
	col 7 <
	square 7 - piece-at P-NONE !=
	square 7 - color-at WHITE ==
		and and not if >>done
		attacks square 7 - append attacks!
	
	@done
		attacks return
		
	@no-attacks [ ] return
	;
	
\ move object
: new-move ( piece side squareFrom squareTo )
	\ fields: 
	\	tag 
	\	piece
	\	side
	\	squareFrom 
	\	squareTo
	\	pieceCaptured
	\	squareCaptured
	\	piecePromotion
	'move piece side squareFrom squareTo P-NONE null P-NONE
	8 make-list
	;
	
\ is obj a move object?
: move? ( obj )
	obj list? not if >>no 
	obj 0 get 'move == if >>yes
	@no false return
	@yes true return
	;

\ get printable move, long version
: move-to-str-long ( move -- s )
	""
		move move-piece move move-side piece-char "-" + +
		move move-squareFrom square-to-algebraic +
		move move-isCapture? not if >>skip
		"x" +
		@skip
		move move-squareTo square-to-algebraic +
		\ append -ep-target for en-passant
		move move-isEnPassant? not if >>promotion
		"-ep-" +
		move move-squareCaptured square-to-algebraic +
		@promotion
		move move-piecePromotion P-NONE == if >>done
		"=" + move move-piecePromotion move move-side piece-char +
		@done
	;
	
\ print a move verbosely
: print-move-long ( move )
	move move-to-str-long .
	;
	
\ setters/getters -- for efficiency these assume move is valid - caller should
\ check with move? if unsure before calling these
\
\ the setters leave the move on the stack so these can be chained together
: move-piece ( move -- piece ) move 1 get ;
: move-piece! ( move piece -- move ) move 1 piece put ;

: move-side ( move -- side ) move 2 get ;
: move-side! ( move side -- move ) move 2 piece put ;

: move-squareFrom ( move -- square ) move 3 get ;
: move-squareFrom! ( move square -- move' ) move 3 square put ;

: move-squareTo ( move -- square ) move 4 get ;
: move-squareTo! ( move square -- move' ) move 4 square put ;

: move-pieceCaptured ( move -- piece ) move 5 get ;
: move-pieceCaptured! ( move piece -- move' ) move 5 piece put ;

: move-squareCaptured ( move -- square ) move 6 get ;
: move-squareCaptured! ( move square -- move' ) move 6 square put ;

: move-piecePromotion ( move -- piece ) move 7 get ;
: move-piecePromotion! ( move piece -- move' ) move 7 piece put ;
	
: move-isCapture? ( move -- result ) move move-pieceCaptured P-NONE != ;

\ e.p. is the only time that squareTo != squareCaptured, when not null
: move-isEnPassant? ( move -- result )
	move move-squareCaptured null? not 
	move move-squareCaptured move move-squareTo !=
	and
	;
	
"Making king attack table ..." . CR	
gen-all-king-attacks

"Making knight attack table ..." . CR	
gen-all-knight-attacks

\ attacks is from gen-fixed-attacks
: gen-fixed-moves ( piece square attacks side -- moves )
	[ ] moves!
	attacks
	{ ( squareTo )
		\ see what is at squareTo
		squareTo piece-at P-NONE == if >>empty
		\ not empty - see if its opposing color
		squareTo color-at side other == if >>capture
		\ my own piece is on squareTo, so no move generated
		return
		@empty
			\ move to empty square
			moves
				piece side square squareTo new-move append moves!
			return
		@capture
			\ gen capture
			moves
				piece side square squareTo new-move
				squareTo piece-at move-pieceCaptured!
				squareTo move-squareCaptured!
				append moves!
			return
	} for-each
	moves
	;
	
\ (attacks,blockers) is from gen-all-sliding-attacks
: gen-sliding-moves ( piece square attacks blockers side -- moves )
	[ ] moves!
	\ all the squares in attacked are empty, so make those first
	attacks
	{ ( squareTo )
		\ always non-capturing move
		moves
			piece side square squareTo new-move append moves!
	} for-each
	
	\ now i have to check if blockers are opposite side (voids were already
	\ filtered out in gen-all-sliding-squares)
	blockers
	{ ( squareTo )
		squareTo color-at side == if >>done \ blocked by my piece, so i'm done
		\ else its a capture
		moves
			piece side square squareTo new-move
			squareTo piece-at move-pieceCaptured!
			squareTo move-squareCaptured!
			append moves!
		@done
	} for-each
	moves
	;
	
\ NOTE - all the gen-PIECE-moves functions are pseudo-legal - they are the literal moves
\ the piece can make, regardless of whether they put/leave their king in check

: gen-king-moves ( square side -- moves )
	P-KING square KING-ATTACKS-BY-SQUARE square get side gen-fixed-moves
	;
	
: gen-knight-moves ( square side -- moves )
	P-KNIGHT square KNIGHT-ATTACKS-BY-SQUARE square get side gen-fixed-moves
	;
	
'ROOK-MOVEDIRS [ [ 1 0 ] [ -1 0 ] [ 0 1 ] [ 0 -1 ] ] make-var

\ piece is a parameter since this is used for both queen and rook generation
: gen-rook-moves ( square side piece -- moves )
	@locals [ attacks blockers ]
	\ gen attacks & blocked squares
	square ROOK-MOVEDIRS gen-all-sliding-attacks blockers! attacks!
	piece square attacks blockers side gen-sliding-moves
	\ return moves
	;

'BISHOP-MOVEDIRS [ [ 1 1 ] [ -1 1 ] [ 1 -1 ] [ -1 -1 ] ] make-var

\ piece is a parameter since this is used for both queen and bishop generation
: gen-bishop-moves ( square side piece -- moves )
	@locals [ attacks blockers ]
	\ gen attacks & blocked squares
	square BISHOP-MOVEDIRS gen-all-sliding-attacks blockers! attacks!
	piece square attacks blockers side gen-sliding-moves
	\ return moves
	;
	
: gen-queen-moves ( square side -- moves )
	square side P-QUEEN gen-bishop-moves
	square side P-QUEEN gen-rook-moves
	extend
	;
	
: gen-pawn-moves ( square side -- moves )
	@locals [ attacks move row col ]
	[ ] moves!
	\ find squares i can attack
	square side gen-pawn-attacks
	\ make these into moves
	{ ( squareTo )
		moves
		P-PAWN side square squareTo new-move
			squareTo piece-at move-pieceCaptured!
			squareTo move-squareCaptured!
			append moves!
	} for-each
	
	square square-to-rowcol col! row!
	
	side BLACK == if >>b-forw-1
	\ white forward 1
	row 7 >= if >>w-forw-2
	square 8 + piece-at P-NONE != if >>w-forw-2 \ occupied?
		P-PAWN side square square 8 + new-move move!
		moves move append moves!
	\ promotions?
	square 8 + 56 < if >>w-forw-2
	\ add all possible promotions
	\ overwrite move already in list for first one
	move P-KNIGHT move-piecePromotion! move!
	\ now deepcopy & adjust promotion for others	
	moves
	 	move deepcopy P-BISHOP move-piecePromotion! append
		move deepcopy P-ROOK move-piecePromotion! append
		move deepcopy P-QUEEN move-piecePromotion! append!
		
	@w-forw-2 
	row 1 != if >>w-ep
	square 8 + piece-at P-NONE != if >>w-ep
	square 16 + piece-at P-NONE != if >>w-ep
		moves
		P-PAWN side square square 16 + new-move 
		append moves! >>w-ep
		
	@b-forw-1
	row 1 < if >>b-forw-2
	square 8 - piece-at P-NONE != if >>b-forw-2 \ occupied?
		P-PAWN side square square 8 - new-move move!
		moves move append moves!
	\ promotions?
	square 8 - 7 > if >>b-forw-2
	\ add all possible promotions
	\ overwrite move already in list for first one
	move P-KNIGHT move-piecePromotion! move!
	\ now deepcopy & adjust promotion for others	
	moves
	 	move deepcopy P-BISHOP move-piecePromotion! append
		move deepcopy P-ROOK move-piecePromotion! append
		move deepcopy P-QUEEN move-piecePromotion! append!
	
	@b-forw-2 
	row 6 != if >>b-ep
	square 8 - piece-at P-NONE != if >>b-ep \ occupied?
	square 16 - piece-at P-NONE != if >>b-ep \ occupied?
		moves
		P-PAWN side square square 16 - new-move 
		append moves! >>b-ep
		
	\ en-passant, white
	@w-ep 
	\ check left
	col 0 >
	square 7 + EPSQUARE ==
		and not if >>w-ep-right 
		moves
		P-PAWN side square square 7 + new-move
		square 1 - move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
	
	@w-ep-right
	\ check right
	col 7 <
	square 9 + EPSQUARE ==
		and not if >>done
		moves
		P-PAWN side square square 9 + new-move
		square 1 + move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
		>>done 
	
	\ en-passant, black
	@b-ep 
	\ check left
	col 0 >
	square 9 - EPSQUARE ==
		and not if >>b-ep-right 
		moves
		P-PAWN side square square 9 - new-move
		square 1 - move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
	
	@b-ep-right
	\ check right
	col 7 <
	square 7 - EPSQUARE ==
		and not if >>done
		moves
		P-PAWN side square square 7 - new-move
		square 1 + move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
		>>done 
		
	@done
		moves return
	;
	
\ generate pseudolegal moves for side (moves are not checked to see if they
\ put the king into/leave the king in check)
: gen-pseudo-moves ( side -- moves )
	@locals [ piece ]
	[ ] moves!
	\ for each square ...
	{ ( i )
		i piece-at piece!
		piece P-NONE == if >>done \ empty square, skip
		i color-at side != if >>done \ wrong color piece

		\ generate moves for piece
		piece P-PAWN == if >>pawn
		piece P-ROOK == if >>rook 
		piece P-BISHOP == if >>bishop 
		piece P-KNIGHT == if >>knight 
		piece P-QUEEN == if >>queen
		piece P-KING == if >>king 
		"Unknown piece:" piece str + error
		
		@pawn moves i side gen-pawn-moves extend moves! >>done
		@rook  moves i side P-ROOK gen-rook-moves extend moves! >>done
		@bishop moves i side P-BISHOP gen-bishop-moves extend moves! >>done
		@knight moves i side gen-knight-moves extend moves! >>done
		@queen moves i side gen-queen-moves extend moves! >>done
		@king moves i side gen-king-moves extend moves! >>done
		@done
	} 0 1 64 for-count
	moves
	;

\ get a list of all squares attacked by side
\ does NOT include:
\	* en-passant moves - those cannot attack king and that is the
\     primary use for this function
\	* castling moves, since those are not attacks
: gen-attacks ( side -- attacks )
	@locals [ piece blockers sub-attacks ]
	[ ] attacks!
	\ for each square ...
	{ ( i )
		i piece-at piece!
		piece P-NONE == if >>done \ empty square, skip
		i color-at side != if >>done \ wrong color piece

		\ generate moves for piece
		piece P-PAWN == if >>pawn
		piece P-ROOK == if >>rook 
		piece P-BISHOP == if >>bishop 
		piece P-KNIGHT == if >>knight 
		piece P-QUEEN == if >>queen
		piece P-KING == if >>king 
		"Unknown piece:" piece str + error
		
		@pawn attacks i side gen-pawn-attacks extend attacks! >>done 
		@rook 
			\ gen attacks & blocked squares
			i ROOK-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks! >>done
		@bishop
			\ gen attacks & blocked squares
			i BISHOP-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks! >>done
		@queen 
			\ gen attacks & blocked squares
			i ROOK-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks!
			\ gen attacks & blocked squares
			i BISHOP-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks! >>done
		@knight
			attacks KNIGHT-ATTACKS-BY-SQUARE i get extend attacks! >>done
		@king
			attacks KING-ATTACKS-BY-SQUARE i get extend attacks! >>done
		@done
	} 0 1 64 for-count
	attacks
	;		

\ make move -- assumes move is valid
: make-move ( move -- )
	\ save extra state to undo stack first
	\ **TODO** this is a reason that globals should be treated more like args/locals,
	\ the globals here would be saved as symbols not as values if i used literal list
	\ notations, but with args/locals it would have the expected behavior
	\ ... so just make the list manually
	UNDO-STACK
		EPSQUARE HALFMOVE CASTLING_W_OO CASTLING_W_OOO CASTLING_B_OO CASTLING_B_OOO
		6 make-list append!
		
	\ remove from squareFrom
	move move-squareFrom P-NONE WHITE put-piece 
	\ if capture, remove
	move move-isCapture? not if >>skip-cap
	move move-squareCaptured P-NONE WHITE put-piece 
	@skip-cap
	\ place on squareTo
	move move-squareTo move move-piece move move-side put-piece
	\ promotion?
	move move-piecePromotion P-NONE == if >>epsquare
	\ put promoted piece at squareTo instead
	move move-squareTo move move-piecePromotion move move-side put-piece
	
	@epsquare
	\ see if it was a double pawn jump and set epsquare to square behind pawn
	-1 EPSQUARE!
	move move-piece P-PAWN != if >>skip-ep
	move move-squareTo move move-squareFrom - 16 == if >>set-w-ep
	move move-squareTo move move-squareFrom - -16 == if >>set-b-ep
	>>skip-ep
	@set-w-ep move move-squareTo 8 - EPSQUARE! >>skip-ep
	@set-b-ep move move-squareTo 8 + EPSQUARE!
	@skip-ep
	
	\ see if it's castling (did king move 2 squares left/right)
	move move-piece P-KING != if >>done-castling
	move move-squareFrom 4 == 
		move move-squareTo 6 == and if >>w-oo 
	move move-squareFrom 4 == 
		move move-squareTo 2 == and if >>w-ooo 
	move move-squareFrom 60 == 
		move move-squareTo 62 == and if >>b-oo 
	move move-squareFrom 60 == 
		move move-squareTo 58 == and if >>b-ooo
	>>done-castling
	@w-oo
		\ move rook
		7 P-NONE WHITE put-piece 
		5 P-ROOK WHITE put-piece
		\ no castling available now
		false CASTLING_W_OO!
		false CASTLING_W_OOO!
		>>done-castling
	@w-ooo
		\ move rook
		0 P-NONE WHITE put-piece 
		3 P-ROOK WHITE put-piece
		\ no castling available now
		false CASTLING_W_OO!
		false CASTLING_W_OOO!
		>>done-castling
	@b-oo
		\ move rook
		63 P-NONE BLACK put-piece 
		61 P-ROOK BLACK put-piece
		\ no castling available now
		false CASTLING_B_OO!
		false CASTLING_B_OOO!
		>>done-castling
	@b-ooo
		\ move rook
		56 P-NONE WHITE put-piece 
		59 P-ROOK BLACK put-piece
		\ no castling available now
		false CASTLING_B_OO!
		false CASTLING_B_OOO!
		>>done-castling
	
	@done-castling
	\ update castling availability based on pieces leaving squares
	\ i don't have to check colors since even if the piece leaves its starting
	\ square for 1 move, that is enough to turn off the flag permanently
	CASTLING_W_OO
		4 piece-at P-KING ==
		7 piece-at P-ROOK == and and
			CASTLING_W_OO!
	CASTLING_W_OOO
		4 piece-at P-KING ==
		0 piece-at P-ROOK == and and
			CASTLING_W_OOO!
	CASTLING_B_OO
		60 piece-at P-KING ==
		63 piece-at P-ROOK == and and
			CASTLING_B_OO!
	CASTLING_B_OOO
		60 piece-at P-KING ==
		56 piece-at P-ROOK == and and
			CASTLING_B_OOO!			
	;

\ unmake move -- assumes move is valid AND that move was just made	
: unmake-move ( move -- )
	\ remove from squareTo
	move move-squareTo P-NONE WHITE put-piece
	\ place on squareFrom
	move move-squareFrom move move-piece move move-side put-piece
	\ if capture, replace captured piece
	move move-isCapture? not if >>skip
	move move-squareCaptured move move-pieceCaptured move move-side other put-piece
	@skip
	
	\ see if it's castling (did king move 2 squares left/right)
	move move-piece P-KING != if >>done-castling
	move move-squareFrom 4 == 
		move move-squareTo 6 == and if >>w-oo 
	move move-squareFrom 4 == 
		move move-squareTo 2 == and if >>w-ooo 
	move move-squareFrom 60 == 
		move move-squareTo 62 == and if >>b-oo 
	move move-squareFrom 60 == 
		move move-squareTo 58 == and if >>b-ooo
	>>done-castling
	@w-oo
		\ move rook
		5 P-NONE WHITE put-piece 
		7 P-ROOK WHITE put-piece
		>>done-castling
	@w-ooo
		\ move rook
		3 P-NONE WHITE put-piece 
		0 P-ROOK WHITE put-piece
		>>done-castling
	@b-oo
		\ move rook
		61 P-NONE BLACK put-piece 
		63 P-ROOK BLACK put-piece
		>>done-castling
	@b-ooo
		\ move rook
		59 P-NONE WHITE put-piece 
		56 P-ROOK BLACK put-piece
		>>done-castling
		
	@done-castling
	\ restore other state from stack
	UNDO-STACK -1 get unmake drop
	CASTLING_B_OOO! CASTLING_B_OO! CASTLING_W_OOO! CASTLING_W_OO! HALFMOVE! EPSQUARE!
	UNDO-STACK 1 tail-drop UNDO-STACK!
	;
	
\ generate fully legal moves for side	
: gen-full-moves ( side -- moves )
	@locals [ pmoves attacks kingsq ]
	[ ] moves!
	@skip
	side gen-pseudo-moves
	\ loop over all pmoves, removing those that leave the king in check
	{ ( move )
		\ "CHECK PMOVE:" . move print-move-long move . CR
		
		move make-move
		\ get attacks of opposite side now
		side other gen-attacks
		\ see if king square is attacked (king might have moved so can't
		\ cache king square here)
		side BLACK == if >>check-black-king
		KING-SQUARE-W find-equal void? if >>keep-move
		>>done \ discard move 
		@check-black-king
		KING-SQUARE-B find-equal void? if >>keep-move
		>>done \ discard move 
		@keep-move
		\ king is not attacked, so keep this move
		moves move append!
		@done
		move unmake-move
	} for-each
	
	\ get all attacks in current position to determine if castling is legal
	\ but check if castling is possible first to skip expensive attack generation
	side WHITE ==
		CASTLING_W_OO CASTLING_W_OOO or and if >>gen-w-castling
	side BLACK ==
		CASTLING_B_OO CASTLING_B_OOO or and if >>gen-b-castling
	>>done-castling
	
	@gen-w-castling
		side other gen-attacks attacks!
		CASTLING_W_OO not if >>check-w-ooo \ O-O not available
		\ O-O legality check:
		\	* f1 & g1 empty
		5 piece-at P-NONE != if >>check-w-ooo 
		6 piece-at P-NONE != if >>check-w-ooo 
		\	* f1 & g1 not attacked
		attacks 5 find-equal void? not if >>check-w-ooo
		attacks 6 find-equal void? not if >>check-w-ooo
		\	* king not attacked
		attacks 4 find-equal void? not if >>check-w-ooo 
		\ O-O is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 4 6 new-move append!
		
	@check-w-ooo
		\ similar to above, except reuse attacks
		CASTLING_W_OOO not if >>done-castling \ O-O-O not available
		\ O-O-O legality check:
		\	* b1, c1, & d1 empty
		1 piece-at P-NONE != if >>done-castling
		2 piece-at P-NONE != if >>done-castling
		3 piece-at P-NONE != if >>done-castling
		\	* c1 & d1 not attacked
		attacks 2 find-equal void? not if >>done-castling
		attacks 3 find-equal void? not if >>done-castling
		\	* king not attacked
		attacks 4 find-equal void? not if >>done-castling 
		\ O-O-O is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 4 2 new-move append!
		>>done-castling
		
	@gen-b-castling
		side other gen-attacks attacks!
		CASTLING_B_OO not if >>check-b-ooo \ o-o not available
		\ o-o legality check:
		\	* f8 & g8 empty
		61 piece-at P-NONE != if >>check-b-ooo 
		62 piece-at P-NONE != if >>check-b-ooo 
		\	* f8 & g8 not attacked
		attacks 61 find-equal void? not if >>check-b-ooo
		attacks 62 find-equal void? not if >>check-b-ooo
		\	* king not attacked
		attacks 60 find-equal void? not if >>check-b-ooo 
		\ o-o is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 60 62 new-move append!
	
	@check-b-ooo
		\ similar to above, except reuse attacks
		CASTLING_B_OOO not if >>done-castling \ o-o-o not available
		\ o-o-o legality check:
		\	* b8, c8, & d8 empty
		57 piece-at P-NONE != if >>done-castling
		58 piece-at P-NONE != if >>done-castling
		59 piece-at P-NONE != if >>done-castling
		\	* c8 & d8 not attacked
		attacks 58 find-equal void? not if >>done-castling
		attacks 59 find-equal void? not if >>done-castling
		\	* king not attacked
		attacks 60 find-equal void? not if >>done-castling 
		\ o-o-o is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 60 58 new-move append!
		>>done-castling \ just to be explicit		
		
	@done-castling
	
	moves \ return legal moves
	;

\ moves are generated pseudo-moves
\ expected is a list of strings from move-str-long
\ returns true|false if they match
: check-p-movelist ( moves expected -- result )
	@locals [ i ]
	moves length expected length != if >>nomatch
	0 i!
	@loop \ loop manually so i can bail out immediately on nonmatch
		moves i get void? if >>goodmatch \ end of list
		\ make sure i find each expected move in movelist
		expected moves i get move-to-str-long find-equal void? if >>nomatch
		i 1 + i! <<loop
	@goodmatch true return
	@nomatch false return
	;
	
: test-pawn-pmoves
	\ white
	"4k3/2P5/4n1n1/5P2/4n3/3n4/PP1PP2P/4K3 w - - 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR

	[ 	"K-e1f1" "K-e1d1" "K-e1f2" "P-a2a3" "P-a2a4" "P-b2b3" "P-b2b4" 
		"P-e2xd3" "P-e2e3" "P-h2h3" "P-h2h4" "P-f5xe6" "P-f5xg6" 
		"P-f5f6" "P-c7c8" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ black
	"1k6/pppp3p/3N4/2N5/4p3/3N1N2/5p2/2K5 b - - 0 1" set-from-fen
	print-board
	BLACK gen-pseudo-moves dup { print-move-long } for-each CR
	
	[ "p-f2f1" "p-e4xd3" "p-e4xf3" "p-e4e3" "p-a7a6" "p-a7a5" "p-b7b6" 
		"p-b7b5" "p-c7xd6" "p-c7c6" "p-h7h6" "p-h7h5" "k-b8c8" "k-b8a8" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ en-passant test cases
	
	\ white, left
	"3k4/8/8/2pPp3/8/8/8/3K4 w - c6 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR
	[ "K-d1d2" "K-d1e1" "K-d1c1" "K-d1e2" "K-d1c2" "P-d5d6" "P-d5xc6-ep-c5" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ white, right
	"3k4/8/8/2pPp3/8/8/8/3K4 w - e6 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR
	[ "K-d1d2" "K-d1e1" "K-d1c1" "K-d1e2" "K-d1c2" "P-d5d6"
		"P-d5xe6-ep-e5" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ black, left
	"7k/8/8/8/2PpP3/8/8/K7 b - c3 0 1" set-from-fen
	print-board
	BLACK gen-pseudo-moves dup { print-move-long } for-each CR
	[ "p-d4d3" "p-d4xc3-ep-c4" "k-h8h7" "k-h8g8" "k-h8g7" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ black, right
	"7k/8/8/8/2PpP3/8/8/K7 b - e3 0 1" set-from-fen
	print-board
	BLACK gen-pseudo-moves dup { print-move-long } for-each CR
	[ "p-d4d3" "p-d4xe3-ep-e4" "k-h8h7" "k-h8g8" "k-h8g7" ]
	"MATCH?:" . check-p-movelist . CR	
	;
	
: test-rook-pmoves
	\ white
	"8/7k/4ppp1/2n2R1p/8/8/1rR2b2/2K5 w - - 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR
	
	[ "K-c1d1" "K-c1b1" "K-c1d2" "K-c1xb2" "R-c2c3" "R-c2c4" "R-c2d2"
		"R-c2e2" "R-c2xc5" "R-c2xf2" "R-c2xb2" "R-f5f4" "R-f5f3" 
		"R-f5g5" "R-f5e5" "R-f5d5" "R-f5xf6" "R-f5xf2" "R-f5xh5" "R-f5xc5" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ black
	"3k4/1Rpr2N1/8/3B2r1/8/6P1/5K2/8 b - - 0 1" set-from-fen
	print-board
	BLACK gen-pseudo-moves dup { print-move-long } for-each CR
	[ "r-g5g6" "r-g5g4" "r-g5h5" "r-g5f5" "r-g5e5" "r-g5xg7" "r-g5xg3"
		"r-g5xd5" "p-c7c6" "p-c7c5" "r-d7d6" "r-d7e7" "r-d7f7" 
		"r-d7xd5" "r-d7xg7" "k-d8e8" "k-d8c8" "k-d8e7" ]
	"MATCH?:" . check-p-movelist . CR
	;

: test-bishop-pmoves
	\ white
	"1k6/1p3p2/7r/3Br3/2n2B2/3p1n2/3P3P/3K4 w - - 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR
	[ "K-d1e1" "K-d1c1" "K-d1e2" "K-d1c2" "P-h2h3" "P-h2h4" "B-f4g5" 
		"B-f4g3" "B-f4e3" "B-f4xh6" "B-f4xe5" "B-d5e6" "B-d5e4" 
		"B-d5c6" "B-d5xf7" "B-d5xf3" "B-d5xb7" "B-d5xc4" ]
	"MATCH?:" . check-p-movelist . CR
		
	\ black
	"5k2/2p2p2/3b1Pp1/3p4/1P2bP2/5P2/4P3/4K3 b - - 0 1" set-from-fen
	print-board
	BLACK gen-pseudo-moves dup { print-move-long } for-each CR
	[ "b-e4f5" "b-e4d3" "b-e4c2" "b-e4b1" "b-e4xf3" "p-d5d4" "b-d6e7" 
		"b-d6e5" "b-d6c5" "b-d6xf4" "b-d6xb4" "p-g6g5" "p-c7c6" 
		"p-c7c5" "k-f8g8" "k-f8e8" "k-f8g7" "k-f8e7" ]
	"MATCH?:" . check-p-movelist . CR		
	;
	
: test-knight-pmoves
	\ white
	"1k6/3p1p2/8/4N3/p5p1/8/1N6/4K3 w - - 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR
	[ "K-e1e2" "K-e1f1" "K-e1d1" "K-e1f2" "K-e1d2" "N-b2c4" "N-b2xa4" 
		"N-b2d3" "N-b2d1" "N-e5xf7" "N-e5xd7" "N-e5f3" "N-e5d3" 
		"N-e5g6" "N-e5c6" "N-e5xg4" "N-e5c4" ]
	"MATCH?:" . check-p-movelist . CR		
	
	\ black
	"5k2/1n1P4/8/2P1n1P1/8/5p2/8/2K5 b - - 0 1" set-from-fen
	print-board
	BLACK gen-pseudo-moves dup { print-move-long } for-each CR
	[ "p-f3f2" "n-e5f7" "n-e5xd7" "n-e5d3" "n-e5g6" "n-e5c6" "n-e5g4" 
		"n-e5c4" "n-b7xc5" "n-b7a5" "n-b7d8" "n-b7d6" "k-f8f7" 
		"k-f8g8" "k-f8e8" "k-f8g7" "k-f8e7" ]
	"MATCH?:" . check-p-movelist . CR			
	;

\ *TODO* test castling once implemented
: test-king-pmoves
	\ white
	"4k3/8/8/8/2n1n3/2nK4/3n4/8 w - - 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR
	[ "K-d3d4" "K-d3xd2" "K-d3e3" "K-d3xc3" "K-d3xe4" "K-d3xc4" "K-d3e2" "K-d3c2" ]
	"MATCH?:" . check-p-movelist . CR			
	
	"8/4p3/3Nk3/3N1N2/8/8/8/2K5 b - - 0 1" set-from-fen
	print-board
	BLACK gen-pseudo-moves dup { print-move-long } for-each CR
	[ 	"k-e6e5" "k-e6f6" "k-e6xd6" "k-e6f7" "k-e6d7" "k-e6xf5"
		"k-e6xd5" "p-e7xd6" ]
	"MATCH?:" . check-p-movelist . CR	
	;

: test-queen-pmoves
	\ white
	"k7/pp6/3p1p2/8/3Q1P2/2p1P3/6PP/7K w - - 0 1" set-from-fen
	print-board
	WHITE gen-pseudo-moves dup { print-move-long } for-each CR
	[ "K-h1g1" "P-g2g3" "P-g2g4" "P-h2h3" "P-h2h4" "P-e3e4" "Q-d4e5" "Q-d4c5" "Q-d4b6"
		"Q-d4xf6" "Q-d4xa7" "Q-d4xc3" "Q-d4d5" "Q-d4d3" "Q-d4d2" "Q-d4d1" 
		"Q-d4e4" "Q-d4c4" "Q-d4b4" "Q-d4a4" "Q-d4xd6" "P-f4f5"
	]
	"MATCH?:" . check-p-movelist . CR			
	;
	
test-rook-pmoves
test-bishop-pmoves
test-knight-pmoves
test-king-pmoves 
test-pawn-pmoves
test-queen-pmoves

\ 37 WHITE gen-pawn-attacks . CR

\ 9 WHITE gen-pawn-moves dup . { print-move-long } for-each CR

: test-make-move
	@locals [ move ]
	"3k4/8/8/3n4/4P3/8/8/4K3 w - - 0 1" set-from-fen
	print-board
	P-PAWN WHITE "e4" algebraic-to-square "d5" algebraic-to-square new-move 
	P-KNIGHT move-pieceCaptured!
	"d5" algebraic-to-square move-squareCaptured! move!
	
	move move-to-str-long . CR
	move make-move
	print-board
	move unmake-move
	print-board
	;
	
test-make-move

: test-gen-full-moves
	\ P can't capture due to exposed check
	"1k2r3/8/8/3n4/4P3/8/8/4K3 w - - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "K-e1e2" "K-e1f1" "K-e1d1" "K-e1f2" "K-e1d2" "P-e4e5" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ only 1 move to save king (bishop capture)
	"k7/8/8/2N2B1Q/8/8/PPn5/KN5R w - - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "B-f5xc2" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ like above but with rook
	"k7/8/8/2R2N1N/8/8/PPn5/KN5R w - - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-c5xc2" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ like above but with knight
	"k7/8/8/2N2N1N/8/4N3/PPn5/KN5R w - - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "N-e3xc2" ]
	"MATCH?:" . check-p-movelist . CR
	
	\ white castling
	"4k3/8/8/8/8/8/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-a1b1" "R-a1c1" "R-a1d1" "K-e1e2" "K-e1f1" "K-e1d1" "K-e1f2" 
		"K-e1d2" "R-h1g1" "R-h1f1" "P-a2a3" "P-a2a4" "P-h2h3" "P-h2h4" "K-e1g1" "K-e1c1"
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ now several cases with attacks on empty squares & king
	
	\ attack f1
	"4k3/8/b7/8/8/8/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-a1b1" "R-a1c1" "R-a1d1" "K-e1d1" "K-e1f2" 
		"K-e1d2" "R-h1g1" "R-h1f1" "P-a2a3" "P-a2a4" "P-h2h3" "P-h2h4" "K-e1c1"
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack g1
	"4k3/8/1b6/8/8/8/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-a1b1" "R-a1c1" "R-a1d1" "K-e1e2" "K-e1f1" "K-e1d1"  
		"K-e1d2" "R-h1g1" "R-h1f1" "P-a2a3" "P-a2a4" "P-h2h3" "P-h2h4" "K-e1c1"
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack king
	"4k3/8/8/b7/8/8/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "K-e1e2" "K-e1f1" "K-e1d1" "K-e1f2" 
		
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack d1
	"4k3/8/8/8/6b1/8/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-a1b1" "R-a1c1" "R-a1d1" "K-e1f1" "K-e1f2" 
		"K-e1d2" "R-h1g1" "R-h1f1" "P-a2a3" "P-a2a4" "P-h2h3" "P-h2h4" "K-e1g1"
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack c1
	"4k3/8/8/8/5b2/8/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-a1b1" "R-a1c1" "R-a1d1" "K-e1e2" "K-e1f1" "K-e1d1" "K-e1f2" 
		"R-h1g1" "R-h1f1" "P-a2a3" "P-a2a4" "P-h2h3" "P-h2h4" "K-e1g1"
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack b1
	"4k3/8/8/8/4b3/8/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-a1b1" "R-a1c1" "R-a1d1" "K-e1e2" "K-e1f1" "K-e1d1" "K-e1f2" 
		"K-e1d2" "R-h1g1" "R-h1f1" "P-a2a3" "P-a2a4" "P-h2h3" "P-h2h4" "K-e1g1"
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack c1 & g1
	"4k3/8/8/8/8/4b3/P6P/R3K2R w KQ - 0 1" set-from-fen
	print-board
	WHITE gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "R-a1b1" "R-a1c1" "R-a1d1" "K-e1e2" "K-e1f1" "K-e1d1" 
		"R-h1g1" "R-h1f1" "P-a2a3" "P-a2a4" "P-h2h3" "P-h2h4"
	]
	"MATCH?:" . check-p-movelist . CR	
	
	\ black castling
	"r3k2r/p6p/8/8/8/8/8/4K3 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "p-a7a6" "p-a7a5" "p-h7h6" "p-h7h5" "r-a8b8" "r-a8c8" "r-a8d8" "k-e8e7" "k-e8f8"
		"k-e8d8" "k-e8f7" "k-e8d7" "r-h8g8" "r-h8f8" "k-e8g8" "k-e8c8" ]
	
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack f8
	"r3k2r/p6p/8/8/8/8/8/4KR2 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "p-a7a6" "p-a7a5" "p-h7h6" "p-h7h5" "r-a8b8" "r-a8c8" "r-a8d8" "k-e8e7" 
		"k-e8d8" "k-e8d7" "r-h8g8" "r-h8f8" "k-e8c8" ]
	
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack g8
	"r3k2r/p6p/8/8/8/8/8/4K1R1 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "p-a7a6" "p-a7a5" "p-h7h6" "p-h7h5" "r-a8b8" "r-a8c8" "r-a8d8" "k-e8e7" "k-e8f8"
		"k-e8d8" "k-e8f7" "k-e8d7" "r-h8g8" "r-h8f8" "k-e8c8" ]
	
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack king
	"r3k2r/p6p/8/8/8/8/4R3/4K3 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[  "k-e8f8"
		"k-e8d8" "k-e8f7" "k-e8d7" ]
	
	"MATCH?:" . check-p-movelist . CR
	
	\ attack d8
	"r3k2r/p6p/8/8/8/8/8/3RK3 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "p-a7a6" "p-a7a5" "p-h7h6" "p-h7h5" "r-a8b8" "r-a8c8" "r-a8d8" "k-e8e7" "k-e8f8"
		"k-e8f7" "r-h8g8" "r-h8f8" "k-e8g8" ]
	
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack c8
	"r3k2r/p6p/8/8/8/8/8/2R1K3 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "p-a7a6" "p-a7a5" "p-h7h6" "p-h7h5" "r-a8b8" "r-a8c8" "r-a8d8" "k-e8e7" "k-e8f8"
		"k-e8d8" "k-e8f7" "k-e8d7" "r-h8g8" "r-h8f8" "k-e8g8" ]
	
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack b8
	"r3k2r/p6p/8/8/8/8/8/1R2K3 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "p-a7a6" "p-a7a5" "p-h7h6" "p-h7h5" "r-a8b8" "r-a8c8" "r-a8d8" "k-e8e7" "k-e8f8"
		"k-e8d8" "k-e8f7" "k-e8d7" "r-h8g8" "r-h8f8" "k-e8g8" ]
	
	"MATCH?:" . check-p-movelist . CR	
	
	\ attack g8 & c8
	"r3k2r/p6p/4B3/8/8/8/8/4K3 b kq - 0 1" set-from-fen
	print-board
	BLACK gen-full-moves dup { print-move-long } for-each CR
	print-board
	[ "p-a7a6" "p-a7a5" "p-h7h6" "p-h7h5" "r-a8b8" "r-a8c8" "r-a8d8" "k-e8e7" "k-e8f8"
		"k-e8d8" "r-h8g8" "r-h8f8" ]
	
	"MATCH?:" . check-p-movelist . CR	
	
	;
	
: perft-worker ( side depth -- nrmoves )
	depth 0 > if >>skip
	1 return \ leaf node, return 1
	@skip
	0 nrmoves!
	side gen-full-moves
	\ run perft-worker for each move, at depth-1
	{ ( move )
		move make-move 
		side other depth 1 - perft-worker nrmoves + nrmoves!
		move unmake-move
	} for-each
	nrmoves
	;
	
\ run at root
: perft ( side depth -- )
	@locals [ nrmoves nr ]
	0 nrmoves!
	side gen-full-moves 
	{ ( move )
		move print-move-long ":" .
		move make-move
		side other depth 1 - perft-worker nr!
		nr . CR
		nr nrmoves + nrmoves!
		move unmake-move
	} for-each
	
	nrmoves . "nodes searched" . CR
	;
			
\ test-gen-full-moves

\ the expected node counts are generated with stockfish like:
\	position fen FENSTRING
\		* where FENSTRING is the UNQUOTED FEN string
\	go perft DEPTH
\		* where DEPTH matches the depth passed to perft here

\ "2k5/8/7b/8/2p5/4N3/1P6/1K6 w - - 0 1" set-from-fen
\ WHITE 1 perft

\ "2k5/8/7b/8/2p5/4N3/1P6/1K6 w - - 0 1" set-from-fen
\ WHITE 2 perft
(
"2k5/8/7b/8/2p5/4N3/1P6/1K6 w - - 0 1" set-from-fen
WHITE 3 perft

"2k5/8/7b/8/2p5/4N3/1P6/2K5 b - - 0 1" set-from-fen
BLACK 2 perft

"2k5/8/8/8/2p5/4b3/1P6/2K5 w - - 0 1" set-from-fen
WHITE 1 perft
)

\ "2k5/8/7b/8/2p5/4N3/1P6/1K6 w - - 0 1" set-from-fen
\ WHITE 4 perft

\ "4k3/8/8/8/8/8/P6P/R3K2R w KQ - 0 1" set-from-fen
\ WHITE 4 perft

\ 366834 - working
\ "r3k2r/2b2b2/8/8/8/8/P6P/R3K2R b KQ - 0 1" set-from-fen
\ BLACK 4 perft

\ "r3k2r/2b5/6b1/8/8/8/P6P/R3K2R w KQ - 0 1" set-from-fen
\ WHITE 1 perft

\ on the first move, white can disrupt black castling in every
\ way with rook, bishop and knight
\ "r3k2r/8/8/N6N/N6N/8/R7/2B2K1B w kq - 0 1" set-from-fen
\ WHITE 1 perft \ 44
\ WHITE 2 perft \ 704
\ WHITE 3 perft \ 28571

\ "2b1kb2/7r/8/n6n/n6n/8/8/R3K2R b KQ - 0 1" set-from-fen
\ BLACK 1 perft \ 43
\ BLACK 2 perft \ 690
\ BLACK 3 perft \ 29027

\ with black moving first, this tests the en-passant captures for white on move 2
\ "4k3/pppppppp/8/P1P1P1P1/8/8/8/4K3 b - - 0 1" set-from-fen
\ BLACK 1 perft \ 14
\ BLACK 2 perft \ 136
\ BLACK 3 perft \ 1937
\ BLACK 4 perft \ 20777

\ like above, with reversed setup and white first
\ "4k3/8/8/8/1p1p1p1p/8/PPPPPPPP/4K3 w - - 0 1" set-from-fen
\ WHITE 1 perft \ 14
\ WHITE 2 perft \ 136
\ WHITE 3 perft \ 1927
\ WHITE 4 perft \ 20654

\ "7k/P7/8/8/8/8/8/7K w - - 0 1" set-from-fen
\ print-board
\ WHITE gen-full-moves dup { print-move-long } for-each CR

\ stress-test white promotions
\ "8/PPPPPPPP/8/7k/8/8/8/7K w - - 0 1" set-from-fen
\ WHITE 1 perft \ 35
\ WHITE 2 perft \ 162
\ WHITE 3 perft \ 6157
\ WHITE 4 perft \ 34710

\ "3k4/8/8/3K4/8/8/pppppppp/8 b - - 0 1" set-from-fen
\ BLACK 1 perft \ 37
\ BLACK 2 perft \ 273
\ BLACK 3 perft \ 10622
\ BLACK 4 perft \ 65557

\ kiwipete
\ "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1" set-from-fen
\ WHITE 1 perft \ 48
\ WHITE 2 perft \ 2039
\ WHITE 3 perft \ 97862

"r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/P1N2Q1p/1PPBBPPP/R3K2R b KQkq - 0 1" set-from-fen
BLACK 2 perft

"r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/P1N2Q2/1PPBBPpP/R3K2R w KQkq - 0 1" set-from-fen
WHITE 1 perft
