\ Simple chess engine - purely for fun, not practicality :-)
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE

\ should be in init

\ is c an uppercase letter?
: isupper? @( c ) 
	c ord 65 >= c ord 90 <= and ;
	
\ is c an uppercase letter?
: islower? @( c )
	c ord 97 >= c ord 122 <= and ;
	
\ convert char c to lowercase, if it is a letter
: tolower @( c -- lowercase )
	c isupper? if >>is-upper
	c return \ not uppercase, return c as is
	@is-upper
		c ord 65 - 97 + chr
	;

\ convert char c to uppercase, if it is a letter
: toupper @( c -- uppercase )
	c islower? if >>is-lower
	c return \ not uppercase, return call
	@is-lower
		c ord 97 - 65 + chr
	;
	
\ convert string to lowercase
: string-lower @( s -- lowercase )
	s { tolower } map
	;

\ convert string to uppercase	
: string-upper @( s -- lowercase )
	s { toupper } map
	;

: unittest-string-lower @( s )
	"STRING:" . s . CR
	"LOWER:" . s string-lower . CR
	;
	
: unittest-string-upper @( s )
	"STRING:" . s . CR
	"UPPER:" . s string-upper . CR
	;
	
\ find index of first item in sequence that satisfies test or void if none 
: find @( seq test -- index )
	0 index!
	@loop
		index seq length >= if >>not-found
		seq index get test call if >>found 
		index 1 + index! <<loop
	@found index return
	@not-found void
	;

: unittest-find
	"Expect 2:" . "giant flying balloonz" { "a" == } find . CR
	"Expect 0:" . "giant flying balloonz" { "g" == } find . CR
	"Expect 6:" . "giant flying balloonz" { "f" == } find . CR
	"Expect 20:" . "giant flying balloonz" { "z" == } find . CR
	"Expect void:" . "giant flying balloonz" { "G" == } find . CR
	;
	
\ split text into parts separated by one or more chars from delims (a string or list of chars).
\ any leading/trailing delims are trimmed. this function does NOT make empty parts.
: string-split @( text delims -- parts )
	@locals [ i c piece ]
	[ ] parts!
	0 i!
	"" piece!
	@loop
		text i get c!
		c void? if >>got-end \ end of string
		delims @{ c == } find void? not if >>got-delim \ found delimiter
		\ not a delim, add to piece
		piece c + piece! >>next
	@got-delim
		\ if i've been building a piece, add to parts and reset piece
		piece length 0 > if >>push-piece
		\ else this in the middle of other delimiters, so just keep going
		>>next
	@push-piece
		parts piece append parts!
		"" piece!
		>>next
	@next
		i 1 + i! <<loop
	@got-end
		\ if i have a piece, add it to parts
		piece length 0 == if >>done 
		parts piece append parts!
	@done
		parts
	;
	
: unittest-string-split
	"Expect [ abc def ghi ]:" . "abc;def:ghi/jkl" ":/;" string-split . CR
	"Expect [ opq rst uvw xyz ]:" . ";/:://:opq;;//;rst;:::uvw:;;/xyz//////:://;" ":/;" string-split . CR
	"Expect [ ]:" . ":://;;;;//;/;;/:" ":/;" string-split . CR
	"Expect [ w x y z ]:" . "//;;/;w:::;/x///:::;y::///::z///:::;" ":/;" string-split . CR
	;
	
 "AbcDE 12345 xyZ #@" unittest-string-lower
 "AbcDE 12345 xyZ #@" unittest-string-upper
 unittest-find

\ make a variable with a getter and setter:
\	name gets data stored in var
\	name! sets data stored in var
: make-var @( name initval )
	@locals [ addr ]
	1 alloc addr! \ alloc storage
	initval addr set! \ save initval
	
	\ make:
	\	name = get data @ addr
	\	name! = set data @ addr
	
	\ make word: : NAME addr ref ;
	addr 'ref 2 make-list name make-word
	\ make word: : NAME! addr set! ;
	addr 'set! 2 make-list name '! + make-word
	;

\ chess code starts here
	
\ pieces
: P_PAWN 0 ;
: P_KNIGHT 1 ;
: P_BISHOP 2 ;
: P_ROOK 3 ;
: P_QUEEN 4 ;
: P_KING 5 ;
: P_NONE 6 ;

'PIECE-CHARS [ "P" "N" "B" "R" "Q" "K" "." ] make-var

\ sides
: WHITE 0 ;
: BLACK 1 ;
: other ( side -- other ) 1 + 2 mod ;

\ ------ board state -------

\ coordinates: row=0,col=0 is a1; row=0,col=7 is h1; row=7,col=7 is h8

\ pieces list (P_*), 1 for each square
'PIECES null make-var
	
\ colors list (WHITE|BLACK), 1 for each square
'COLORS null make-var

\ must call this at least once to init board state
: clear-board ( -- ) 
	[ ] PIECES!
	{ PIECES P_NONE append drop } 0 1 64 for-range
	[ ] COLORS!
	{ COLORS WHITE append drop } 0 1 64 for-range
	;
	
\ get square (0..63) given row,col
: square-index ( row col -- square )
	swap 8 * + 
	;
	
\ get printable char for piece at square
: piece-char-at @( square -- char )
	COLORS square get WHITE == if >>white
	PIECE-CHARS PIECES square get get tolower return \ black = lowercase
	@white PIECE-CHARS PIECES square get get
	;

\ parse a piece char into its P_* and color	
: char-to-piece @( char -- piece color )
	@locals [ ip ]
	PIECE-CHARS @{ char toupper == } find ip! \ find index into PIECE_CHARS
	ip void? if >>bad-char
	char isupper? if >>white
	ip BLACK return 
	@white ip WHITE return
	@bad-char "Bad piece character:" char str + error
	;

: print-board ( -- )
	@locals [ row col ]
	0 row!
	@loop-row
		row 8 >= if >>done-board
		0 col!
		@loop-col
			col 8 >= if >>done-row
			7 row - col square-index piece-char-at .
			col 1 + col! <<loop-col
		@done-row
			CR
			row 1 + row! <<loop-row
	@done-board
	;
	
: put-piece @( square piece color -- )
	PIECES square piece put 
	COLORS square color put 
	;
	
\ set board state from a FEN string
: fen-parse-string @( fen -- )
	@locals [ parts row col c i ]
	clear-board
	\ split string into its fields
	fen " " string-split parts!
		"FEN PARTS:" . parts . CR
		
	\ parse pieces, e.g. "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"
	7 row!
	0 col!
	0 i!
	@pieces-loop
		parts 0 get i get c! \ next char of string
			"ROW=" . row . "COL=" . col . "CHAR:" . c . CR
		c void? if >>pieces-end-string 
		c digit? if >>pieces-blanks \ got # for blank squares
		c "/" == if >>pieces-slash
		\ else it must be a piece for (row,col)
		row col square-index c char-to-piece 
			"CHAR TO PIECE:" . dup . CR 
			put-piece
		col 1 + col! >>pieces-next
	@pieces-blanks
		c parse-int col + col! \ skip # blanks
		>>pieces-next
	@pieces-slash
		row 1 - row! 0 col! >>pieces-next
	@pieces-next
		i 1 + i! <<pieces-loop
	@pieces-end-string
		row 0 == col 8 == and if >>pieces-ok
		"Pieces string too short in FEN:" parts 0 get + error
		
	@pieces-ok
	;
	
clear-board
"PIECES:" . PIECES . CR
"COLORS:" . COLORS . CR

31 P_BISHOP WHITE put-piece 
19 P_ROOK BLACK put-piece

4 "K" char-to-piece put-piece

print-board

"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" fen-parse-string

print-board

"rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2" fen-parse-string
print-board

'FOO 123 make-var
"WORDS:" . CR
"FOO:" . 'FOO .dumpword . CR
"FOO!:" . 'FOO! .dumpword . CR

"FOO IS:" . FOO . CR
"SET FOO TO 'abcde'" . CR
"abcde" FOO!
"FOO IS:" . FOO . CR

	
			
			
			
