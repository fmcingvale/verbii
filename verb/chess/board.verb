\ Simple chess engine - purely for fun, not practicality :-) Very simple & slow design.
\ Also this is a semi-real app so makes a better excercise for programming in verbii
\ versus the shorter demos.
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
	
\ chess code starts here
	
\ pieces
: P-PAWN 0 ;
: P-KNIGHT 1 ;
: P-BISHOP 2 ;
: P-ROOK 3 ;
: P-QUEEN 4 ;
: P-KING 5 ;
: P-NONE 6 ;

'PIECE-CHARS [ "P" "N" "B" "R" "Q" "K" "." ] make-var

\ sides
: WHITE 0 ;
: BLACK 1 ;
( side -- other )
: other 1 + 2 mod ;

\ ------ board state -------

\ coordinates: row=0,col=0 is a1; row=0,col=7 is h1; row=7,col=7 is h8

\ pieces list (P-*), 1 for each square
'PIECES null make-var
	
\ colors list (WHITE|BLACK), 1 for each square
'COLORS null make-var

\ side to move next - WHITE or BLACK
'SIDE-TO-MOVE WHITE make-var

\ castling availability as bools
'CASTLING_W_OO false make-var
'CASTLING_W_OOO false make-var
'CASTLING_B_OO false make-var
'CASTLING_B_OOO false make-var

\ en-passant target square [0-63] or -1
\ this is the square directly BEHIND (relative to its kindside) 
\ the pawn that just jumped two squares
'EPSQUARE -1 make-var

\ halfmove number for 50-move rule
'HALFMOVE 0 make-var

\ fullmove number
'FULLMOVE 0 make-var

\ epsquare, halfmove and castling status are difficult or not possible
\ to reconstruct from just the previous move, so save them on an undo stack
'UNDO-STACK [ ] make-var

\ track king squares
'KING-SQUARE-W -1 make-var
'KING-SQUARE-B -1 make-var 

\ must call this at least once to init board state
: clear-board ( -- ) 
	[ ] PIECES!
	{ ( i ) PIECES P-NONE append! } 0 1 64 for-count
	[ ] COLORS!
	{ ( i ) COLORS WHITE append! } 0 1 64 for-count
	WHITE SIDE-TO-MOVE!
	true CASTLING_W_OO!
	true CASTLING_W_OOO!
	true CASTLING_B_OO!
	true CASTLING_B_OOO!
	-1 EPSQUARE!
	\ set these to invalid
	-1 KING-SQUARE-W!
	-1 KING-SQUARE-B!
	;
	
\ get square (0..63) given row,col
\ ( row col -- square )
: square-index
	swap 8 * + 
	;
	
\ get row,col from square index
\ ( square -- row col )
: square-to-rowcol 
	8 /mod swap
	;
	
\ get piece at square
: piece-at ( square )
	PIECES square get
	;
	
\ get color at square (only valid if piece != P-NONE)
: color-at ( square )
	COLORS square get
	;
	
\ get printable char for given piece & color
: piece-char ( piece color -- char )
	color WHITE == if >>white
	PIECE-CHARS piece get tolower return \ black = lowercase
	@white PIECE-CHARS piece get
	;
	
\ get printable char for piece at square
: piece-char-at ( square -- char )
	PIECES square get
	COLORS square get
		piece-char
	;

\ parse a piece char into its P-* and color	
: char-to-piece ( char -- piece color )
	@locals [ ip ]
	PIECE-CHARS { char toupper == } find ip! \ find index into PIECE_CHARS
	ip void? if >>bad-char
	char upper? if >>white
	ip BLACK return 
	@white ip WHITE return
	@bad-char "Bad piece character:" char str + error
	;

\ convert square (0..63) to algebraic notation
: square-to-algebraic ( square )
	square 8 /mod ( remainder quot )
	swap "a" ord + chr
	swap "1" ord + chr +
	;

\ convert algebraic notation (a1..h8) to square (0..63)
: algebraic-to-square ( alg )
	alg string? not if >>bad-alg
	alg length 2 != if >>bad-alg
	"abcdefgh" { alg 0 get == } find void? if >>bad-alg
	"12345678" { alg 1 get == } find void? if >>bad-alg
	alg 1 get ord "1" ord - 8 * 
	alg 0 get ord "a" ord - +
	return

	@bad-alg
		"Bad algebraic coordinate:" alg str + error
	;

: print-board ( -- )
	@locals [ row col ]
	0 row!
	@loop-row
		row 8 >= if >>done-board
		0 col!
		@loop-col
			col 8 >= if >>done-row
			7 row - col square-index piece-char-at .
			col 1 + col! <<loop-col
		@done-row
			CR
			row 1 + row! <<loop-row
	@done-board

	\ side to move
	"Side to move:" .
	SIDE-TO-MOVE WHITE == 
		{ "white" . CR } { "black" . CR } ifelse

	\ castling status
	"Castling:" .
	CASTLING_W_OO { "K" puts } ifthen
	CASTLING_W_OOO { "Q" puts } ifthen
	CASTLING_B_OO { "k" puts } ifthen
	CASTLING_B_OOO { "q" puts } ifthen
	\ if no castling available, print - 
	CASTLING_W_OO 
	CASTLING_W_OOO
	CASTLING_B_OO 
	CASTLING_B_OOO
		or or or not { "-" . } ifthen
	CR
	
	"Ep-Target:" . 
	EPSQUARE -1 ==
		{ "None" . }
		{ EPSQUARE square-to-algebraic . }
		ifelse CR	
	
	"Halfmove:" . HALFMOVE .. ", Fullmove:" . FULLMOVE . CR
	;
	
: put-piece ( square piece color -- )
	PIECES square piece put!
	COLORS square color put!
	piece P-KING != if >>done
	\ update king square
	WHITE color == if >>white
	\ black
	square KING-SQUARE-B! >>done
	@white square KING-SQUARE-W!
	@done
	;

: square-empty? ( square -- result )
	PIECES square get P-NONE ==
	;
	
\ put & drop result, since normally putting into an object that
\ code has saved a ref to
: put! put drop ;
\ same for append
: append! append drop ;
\ and for extend
: extend! extend drop ;

\ set board state from a FEN string
: set-from-fen ( fen -- )
	@locals [ parts row col c i ]
	clear-board
	\ split string into its fields
	fen " " string-split parts!
		\ "FEN PARTS:" . parts . CR
		
	\ parse pieces, e.g. "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"
	7 row!
	0 col!
	0 i!
	@pieces-loop
		parts 0 get i get c! \ next char of string
			\ "ROW=" . row . "COL=" . col . "CHAR:" . c . CR
		c void? if >>pieces-end-string 
		c digit? if >>pieces-blanks \ got # for blank squares
		c "/" == if >>pieces-slash
		\ else it must be a piece for (row,col)
		row col square-index c char-to-piece 
			\ "CHAR TO PIECE:" . dup . CR 
			put-piece
		col 1 + col! >>pieces-next
	@pieces-blanks
		c parse-int col + col! \ skip # blanks
		>>pieces-next
	@pieces-slash
		row 1 - row! 0 col! >>pieces-next
	@pieces-next
		i 1 + i! <<pieces-loop
	@pieces-end-string
		row 0 == col 8 == and if >>pieces-ok
		"Pieces string too short in FEN:" parts 0 get + error
		
	@pieces-ok

	\ parts[1] is "w" or "b" to move next
	parts 1 get
	[
		[ [ "w" ] { WHITE SIDE-TO-MOVE! } ]
		[ [ "b" ] { BLACK SIDE-TO-MOVE! } ]
		[ else { "Bad side to move in FEN string" error } ]
	]
	case

	\ parts[2] is castling availability - any of KQkq-
	\ set initially to none
	false CASTLING_W_OO!
	false CASTLING_W_OOO!
	false CASTLING_B_OO!
	false CASTLING_B_OOO!
		\ K?
		parts 2 get { "K" == } find void? if >>check-W-OOO
		true CASTLING_W_OO!
	@check-W-OOO
		\ Q?
		parts 2 get { "Q" == } find void? if >>check-B-OO
		true CASTLING_W_OOO!
	@check-B-OO
		\ k?
		parts 2 get { "k" == } find void? if >>check-B-OOO
		true CASTLING_B_OO!
	@check-B-OOO
		\ q?
		parts 2 get { "q" == } find void? if >>castling-done
		true CASTLING_B_OOO!
	@castling-done

	\ parts[3] is en-passant target square or '-' if none
	parts 3 get "-" == 
		{ -1 EPSQUARE! }
		{ parts 3 get algebraic-to-square EPSQUARE! }
		ifelse
	
	\ parts[4] is halfmove number
	parts 4 get parse-int HALFMOVE!
		
	\ parts[5] is fullmove
	parts 5 get parse-int FULLMOVE!
	;

clear-board

: valid-rowcol? ( row col )
	row 0 >=
	row 8 <
	col 0 >=
	col 8 <
	and and and
	;
	
\ for pieces that have fixed attack spaces relative to their position (kings, knights)
\
\ square = square that piece is assumed to be on
\ moves = list of [ dRow dCol ] (delta row/col) to move from square
\
\ this only returns squares that the piece COULD attack; caller must still check if there
\ is a piece on the square or not
: gen-fixed-attacks ( square moves -- attacks )
	@locals [ row col row+ col+ ]
	[ ] attacks!
	square square-to-rowcol col! row!
	moves
	{ ( move )
		\ calc row+dRow, col+dCol and see if that is a valid square
		row move 0 get + row+!
		col move 1 get + col+!
		row+ col+ valid-rowcol? not if >>done
		\ valid, so add square to attacks
		attacks row+ col+ square-index append attacks!
		@done
	} for-each
	
	attacks
	;

\ generate a table of all fixed attacks for a piece at each square
: gen-all-fixed-attacks ( moves -- attack-table ) 
	[ ] attack-table!
	{ ( square )
		attack-table
			square moves gen-fixed-attacks
			append attack-table!
	} 0 1 64 for-count
	attack-table
	;
	
\ generate attack squares for sliding pieces - pieces moves from square along (dRow,dCol) direction
\
\ squares are returned as a list of empty squares + the final blocked square, or void if all are empty
: gen-sliding-attacks ( square dRow dCol -- attacks blocked )
	@locals [ row col ]
	[ ] attacks!
	square square-to-rowcol col! row!
	@loop
		row dRow + row!
		col dCol + col!
		row col valid-rowcol? not if >>off-board 
		row col square-index square!
		square piece-at P-NONE != if >>blocked 
		\ valid & empty -- add to attacks
		attacks square append! <<loop
	@off-board
		\ all were empty and i went off side of board, so
		\ no square was blocked
		attacks void return
	@blocked
		\ square is blocked (be either side) so stop & return
		attacks square return
	;

\ generate sliding attacks for multiple direction vectors
\	movedirs is list of [ dRow dCol ]		
\
\ here, blockers is always a list (can be empty)
: gen-all-sliding-attacks ( square movedirs -- attacks blockers )
	[ ] attacks!
	[ ] blockers!
	movedirs
	{ ( dir )
		square dir unmake drop gen-sliding-attacks \ ( attacks blocked )
		\ if blocked is not void, add to blockers list
		dup void? not
			{ blockers swap append blockers! }
			{ drop } ifelse
			
		\ add attacks to list (use extend so i don't change object identity vs attacks
		\ defined in outer scope!)
		attacks swap extend attacks!
	} for-each
	
	attacks blockers
	;
	
\ generate attacks for king of given side at square (king does not have
\ to actually be there); these will be ALL squares the king can reach,
\ regardless of whether something is on the destination square
'KING-MOVEDIRS [ [ 1 0 ] [ -1 0 ] [ 0 1 ] [ 0 -1 ] [ 1 1 ] [ 1 -1 ] [ -1 1 ] [ -1 -1 ] ] make-var

\ pregenerated list of king attacks indexed by square
'KING-ATTACKS-BY-SQUARE [ ] make-var

\ pregenerate KING-ATTACKS-BY-SQUARE
: gen-all-king-attacks ( -- ) 
	KING-MOVEDIRS gen-all-fixed-attacks
		KING-ATTACKS-BY-SQUARE!
	;
	
\ generate attacks for knight of given side at square (knight does not have
\ to actually be there); these will be ALL squares the knight can reach,
\ regardless of whether something is on the destination square
'KNIGHT-MOVEDIRS [ [ 2 1 ] [ 2 -1 ] [ -2 1 ] [ -2 -1 ] [ 1 2 ] [ 1 -2 ] [ -1 2 ] [ -1 -2 ] ] make-var

\ pregenerated list of knight attacks indexed by square
'KNIGHT-ATTACKS-BY-SQUARE [ ] make-var

\ pregenerate KNIGHT-ATTACKS-BY-SQUARE
: gen-all-knight-attacks ( -- ) 
	KNIGHT-MOVEDIRS gen-all-fixed-attacks
		KNIGHT-ATTACKS-BY-SQUARE!
	;

\ make list of squares a pawn at square of given side CAN attack, assuming a 
\ piece were there (the move generator must check if there is actually a piece there
\ before making the attack in a move)
\
\ en-passant is NOT checked here -- it is not an attack that can attack
\ the king which is a primary use of the attacks lists
: _gen-pawn-attacks ( square side -- attacks )
	@locals [ row col ]
	[ ] attacks!
	
	square square-to-rowcol col! row!
	
	side BLACK == if >>black
	\ gen for white pawn
	row 7 >= if >>no-attacks \ pawn on last row?? anyways, cannot attack
	\ attack left?
	col 0 == if >>check-w-cap-right
		attacks square 7 + append attacks!
		
	@check-w-cap-right
	col 7 == if >>done
		attacks square 9 + append attacks!
		>>done
	
	@black
	\ gen for black pawn
	row 0 <= if >>no-attacks \ pawn on last row?? anyways, cannot attack
	\ attack left?
	col 0 == if >>check-b-cap-right
		attacks square 9 - append attacks!
		
	@check-b-cap-right
	col 7 == if >>done
		attacks square 7 - append attacks!
	
	@done
		attacks return
		
	@no-attacks [ ] return
	;

\ pawn moves nonsymmetrical so need a white & black table	
'PAWN-ATTACKS-BY-SQUARE-W [ ] make-var
'PAWN-ATTACKS-BY-SQUARE-B [ ] make-var

\ pregenerate pawn attack tables
: gen-all-pawn-attacks ( -- )
	@locals [ i ]
	{ ( square )
		PAWN-ATTACKS-BY-SQUARE-W
			square WHITE _gen-pawn-attacks append!
		PAWN-ATTACKS-BY-SQUARE-B
			square BLACK _gen-pawn-attacks append!
	} 0 1 64 for-count 
	;

: gen-pawn-attacks ( square side -- attacks )
	side WHITE == if >>white
	PAWN-ATTACKS-BY-SQUARE-B square get return
	@white
	PAWN-ATTACKS-BY-SQUARE-W square get
	;
	
\ move object
: new-move ( piece side squareFrom squareTo )
	\ fields: 
	\	tag 
	\	piece
	\	side
	\	squareFrom 
	\	squareTo
	\	pieceCaptured
	\	squareCaptured
	\	piecePromotion
	'move piece side squareFrom squareTo P-NONE null P-NONE
	8 make-list
	;
	
\ is obj a move object?
: move? ( obj )
	obj list? not if >>no 
	obj 0 get 'move == if >>yes
	@no false return
	@yes true return
	;

\ get printable move, long version
: move-to-str-long ( move -- s )
	""
		move move-piece move move-side piece-char "-" + +
		move move-squareFrom square-to-algebraic +
		move move-isCapture? not if >>skip
		"x" +
		@skip
		move move-squareTo square-to-algebraic +
		\ append -ep-target for en-passant
		move move-isEnPassant? not if >>promotion
		"-ep-" +
		move move-squareCaptured square-to-algebraic +
		@promotion
		move move-piecePromotion P-NONE == if >>done
		"=" + move move-piecePromotion move move-side piece-char +
		@done
	;
	
\ print a move verbosely
: print-move-long ( move )
	move move-to-str-long .
	;
	
\ setters/getters -- for efficiency these assume move is valid - caller should
\ check with move? if unsure before calling these
\
\ the setters leave the move on the stack so these can be chained together
: move-piece ( move -- piece ) move 1 get ;
: move-piece! ( move piece -- move ) move 1 piece put ;

: move-side ( move -- side ) move 2 get ;
: move-side! ( move side -- move ) move 2 piece put ;

: move-squareFrom ( move -- square ) move 3 get ;
: move-squareFrom! ( move square -- move' ) move 3 square put ;

: move-squareTo ( move -- square ) move 4 get ;
: move-squareTo! ( move square -- move' ) move 4 square put ;

: move-pieceCaptured ( move -- piece ) move 5 get ;
: move-pieceCaptured! ( move piece -- move' ) move 5 piece put ;

: move-squareCaptured ( move -- square ) move 6 get ;
: move-squareCaptured! ( move square -- move' ) move 6 square put ;

: move-piecePromotion ( move -- piece ) move 7 get ;
: move-piecePromotion! ( move piece -- move' ) move 7 piece put ;
	
: move-isCapture? ( move -- result ) move move-pieceCaptured P-NONE != ;

\ e.p. is the only time that squareTo != squareCaptured, when not null
: move-isEnPassant? ( move -- result )
	move move-squareCaptured null? not 
	move move-squareCaptured move move-squareTo !=
	and
	;
	
"Making king attack table ..." . CR	
gen-all-king-attacks

"Making knight attack table ..." . CR	
gen-all-knight-attacks

"Making pawn attack table ..." . CR			
gen-all-pawn-attacks

\ attacks is from gen-fixed-attacks
: gen-fixed-moves ( piece square attacks side -- moves )
	[ ] moves!
	attacks
	{ ( squareTo )
		\ see what is at squareTo
		squareTo piece-at P-NONE == if >>empty
		\ not empty - see if its opposing color
		squareTo color-at side other == if >>capture
		\ my own piece is on squareTo, so no move generated
		return
		@empty
			\ move to empty square
			moves
				piece side square squareTo new-move append moves!
			return
		@capture
			\ gen capture
			moves
				piece side square squareTo new-move
				squareTo piece-at move-pieceCaptured!
				squareTo move-squareCaptured!
				append moves!
			return
	} for-each
	moves
	;
	
\ (attacks,blockers) is from gen-all-sliding-attacks
: gen-sliding-moves ( piece square attacks blockers side -- moves )
	[ ] moves!
	\ all the squares in attacked are empty, so make those first
	attacks
	{ ( squareTo )
		\ always non-capturing move
		moves
			piece side square squareTo new-move append moves!
	} for-each
	
	\ now i have to check if blockers are opposite side (voids were already
	\ filtered out in gen-all-sliding-squares)
	blockers
	{ ( squareTo )
		squareTo color-at side == if >>done \ blocked by my piece, so i'm done
		\ else its a capture
		moves
			piece side square squareTo new-move
			squareTo piece-at move-pieceCaptured!
			squareTo move-squareCaptured!
			append moves!
		@done
	} for-each
	moves
	;
	
\ NOTE - all the gen-PIECE-moves functions are pseudo-legal - they are the literal moves
\ the piece can make, regardless of whether they put/leave their king in check

: gen-king-moves ( square side -- moves )
	P-KING square KING-ATTACKS-BY-SQUARE square get side gen-fixed-moves
	;
	
: gen-knight-moves ( square side -- moves )
	P-KNIGHT square KNIGHT-ATTACKS-BY-SQUARE square get side gen-fixed-moves
	;
	
'ROOK-MOVEDIRS [ [ 1 0 ] [ -1 0 ] [ 0 1 ] [ 0 -1 ] ] make-var

\ piece is a parameter since this is used for both queen and rook generation
: gen-rook-moves ( square side piece -- moves )
	@locals [ attacks blockers ]
	\ gen attacks & blocked squares
	square ROOK-MOVEDIRS gen-all-sliding-attacks blockers! attacks!
	piece square attacks blockers side gen-sliding-moves
	\ return moves
	;

'BISHOP-MOVEDIRS [ [ 1 1 ] [ -1 1 ] [ 1 -1 ] [ -1 -1 ] ] make-var

\ piece is a parameter since this is used for both queen and bishop generation
: gen-bishop-moves ( square side piece -- moves )
	@locals [ attacks blockers ]
	\ gen attacks & blocked squares
	square BISHOP-MOVEDIRS gen-all-sliding-attacks blockers! attacks!
	piece square attacks blockers side gen-sliding-moves
	\ return moves
	;
	
: gen-queen-moves ( square side -- moves )
	square side P-QUEEN gen-bishop-moves
	square side P-QUEEN gen-rook-moves
	extend
	;
	
: gen-pawn-moves ( square side -- moves )
	@locals [ attacks move row col ]
	[ ] moves!
	\ find squares i can attack
	square side gen-pawn-attacks
	\ make these into moves IF there is a piece there
	{ ( squareTo )
		squareTo piece-at P-NONE == if >>done
		squareTo color-at side == if >>done \ my own piece is on squareTo
		P-PAWN side square squareTo new-move
			squareTo piece-at move-pieceCaptured!
			squareTo move-squareCaptured!
			move!
			
		moves move append moves!
			
		\ promotion after capture?
		squareTo 56 <
		squareTo 7 > and if >>done
		
		\ add all possible promotions
		\ overwrite move already in list for first one
		move P-KNIGHT move-piecePromotion! move!
		\ now deepcopy & adjust promotion for others	
		moves
			move deepcopy P-BISHOP move-piecePromotion! append
			move deepcopy P-ROOK move-piecePromotion! append
			move deepcopy P-QUEEN move-piecePromotion! append!
		@done
	} for-each
	
	\ now generate the forward 1/2 and en-passant captures
	
	square square-to-rowcol col! row!
	
	side BLACK == if >>b-forw-1
	\ white forward 1
	row 7 >= if >>w-forw-2
	square 8 + piece-at P-NONE != if >>w-forw-2 \ occupied?
		P-PAWN side square square 8 + new-move move!
		moves move append moves!
	\ promotions?
	square 8 + 56 < if >>w-forw-2
	\ add all possible promotions
	\ overwrite move already in list for first one
	move P-KNIGHT move-piecePromotion! move!
	\ now deepcopy & adjust promotion for others	
	moves
	 	move deepcopy P-BISHOP move-piecePromotion! append
		move deepcopy P-ROOK move-piecePromotion! append
		move deepcopy P-QUEEN move-piecePromotion! append!
		
	@w-forw-2 
	row 1 != if >>w-ep
	square 8 + piece-at P-NONE != if >>w-ep
	square 16 + piece-at P-NONE != if >>w-ep
		moves
		P-PAWN side square square 16 + new-move 
		append moves! >>w-ep
		
	@b-forw-1
	row 1 < if >>b-forw-2
	square 8 - piece-at P-NONE != if >>b-forw-2 \ occupied?
		P-PAWN side square square 8 - new-move move!
		moves move append moves!
	\ promotions?
	square 8 - 7 > if >>b-forw-2
	\ add all possible promotions
	\ overwrite move already in list for first one
	move P-KNIGHT move-piecePromotion! move!
	\ now deepcopy & adjust promotion for others	
	moves
	 	move deepcopy P-BISHOP move-piecePromotion! append
		move deepcopy P-ROOK move-piecePromotion! append
		move deepcopy P-QUEEN move-piecePromotion! append!
	
	@b-forw-2 
	row 6 != if >>b-ep
	square 8 - piece-at P-NONE != if >>b-ep \ occupied?
	square 16 - piece-at P-NONE != if >>b-ep \ occupied?
		moves
		P-PAWN side square square 16 - new-move 
		append moves! >>b-ep
		
	\ en-passant, white
	@w-ep 
	\ check left
	col 0 >
	square 7 + EPSQUARE ==
		and not if >>w-ep-right 
		moves
		P-PAWN side square square 7 + new-move
		square 1 - move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
	
	@w-ep-right
	\ check right
	col 7 <
	square 9 + EPSQUARE ==
		and not if >>done
		moves
		P-PAWN side square square 9 + new-move
		square 1 + move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
		>>done 
	
	\ en-passant, black
	@b-ep 
	\ check left
	col 0 >
	square 9 - EPSQUARE ==
		and not if >>b-ep-right 
		moves
		P-PAWN side square square 9 - new-move
		square 1 - move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
	
	@b-ep-right
	\ check right
	col 7 <
	square 7 - EPSQUARE ==
		and not if >>done
		moves
		P-PAWN side square square 7 - new-move
		square 1 + move-squareCaptured!
		P-PAWN move-pieceCaptured!
		append!		
		>>done 
		
	@done
		moves return
	;
	
\ generate pseudolegal moves for side (moves are not checked to see if they
\ put the king into/leave the king in check)
: gen-pseudo-moves ( side -- moves )
	@locals [ piece ]
	[ ] moves!
	\ for each square ...
	{ ( i )
		i piece-at piece!
		piece P-NONE == if >>done \ empty square, skip
		i color-at side != if >>done \ wrong color piece

		\ generate moves for piece
		piece P-PAWN == if >>pawn
		piece P-ROOK == if >>rook 
		piece P-BISHOP == if >>bishop 
		piece P-KNIGHT == if >>knight 
		piece P-QUEEN == if >>queen
		piece P-KING == if >>king 
		"Unknown piece:" piece str + error
		
		@pawn moves i side gen-pawn-moves extend moves! >>done
		@rook  moves i side P-ROOK gen-rook-moves extend moves! >>done
		@bishop moves i side P-BISHOP gen-bishop-moves extend moves! >>done
		@knight moves i side gen-knight-moves extend moves! >>done
		@queen moves i side gen-queen-moves extend moves! >>done
		@king moves i side gen-king-moves extend moves! >>done
		@done
	} 0 1 64 for-count
	moves
	;

\ get a list of all squares attacked by side
\ does NOT include:
\	* en-passant moves - those cannot attack king and that is the
\     primary use for this function
\	* castling moves, since those are not attacks
: gen-attacks ( side -- attacks )
	@locals [ piece blockers sub-attacks ]
	[ ] attacks!
	\ for each square ...
	{ ( i )
		i piece-at piece!
		piece P-NONE == if >>done \ empty square, skip
		i color-at side != if >>done \ wrong color piece

		\ generate moves for piece
		piece P-PAWN == if >>pawn
		piece P-ROOK == if >>rook 
		piece P-BISHOP == if >>bishop 
		piece P-KNIGHT == if >>knight 
		piece P-QUEEN == if >>queen
		piece P-KING == if >>king 
		"Unknown piece:" piece str + error
		
		@pawn attacks i side gen-pawn-attacks extend attacks! >>done 
		@rook 
			\ gen attacks & blocked squares
			i ROOK-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks! >>done
		@bishop
			\ gen attacks & blocked squares
			i BISHOP-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks! >>done
		@queen 
			\ gen attacks & blocked squares
			i ROOK-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks!
			\ gen attacks & blocked squares
			i BISHOP-MOVEDIRS gen-all-sliding-attacks blockers! sub-attacks!
			attacks sub-attacks extend blockers extend attacks! >>done
		@knight
			attacks KNIGHT-ATTACKS-BY-SQUARE i get extend attacks! >>done
		@king
			attacks KING-ATTACKS-BY-SQUARE i get extend attacks! >>done
		@done
	} 0 1 64 for-count
	attacks
	;		

\ make move -- assumes move is valid
: make-move ( move -- )
	\ sanity check that move matches SIDE-TO-MOVE
	SIDE-TO-MOVE move move-side != if >>bad-side
	\ save extra state to undo stack first
	\ **TODO** this is a reason that globals should be treated more like args/locals,
	\ the globals here would be saved as symbols not as values if i used literal list
	\ notations, but with args/locals it would have the expected behavior
	\ ... so just make the list manually
	UNDO-STACK
		EPSQUARE HALFMOVE CASTLING_W_OO CASTLING_W_OOO CASTLING_B_OO CASTLING_B_OOO
		6 make-list append!
		
	\ remove from squareFrom
	move move-squareFrom P-NONE WHITE put-piece 
	\ if capture, remove
	move move-isCapture? not if >>skip-cap
	move move-squareCaptured P-NONE WHITE put-piece 
	@skip-cap
	\ place on squareTo
	move move-squareTo move move-piece move move-side put-piece
	\ promotion?
	move move-piecePromotion P-NONE == if >>epsquare
	\ put promoted piece at squareTo instead
	move move-squareTo move move-piecePromotion move move-side put-piece
	
	@epsquare
	\ see if it was a double pawn jump and set epsquare to square behind pawn
	-1 EPSQUARE!
	move move-piece P-PAWN != if >>skip-ep
	move move-squareTo move move-squareFrom - 16 == if >>set-w-ep
	move move-squareTo move move-squareFrom - -16 == if >>set-b-ep
	>>skip-ep
	@set-w-ep move move-squareTo 8 - EPSQUARE! >>skip-ep
	@set-b-ep move move-squareTo 8 + EPSQUARE!
	@skip-ep
	
	\ see if it's castling (did king move 2 squares left/right)
	move move-piece P-KING != if >>done-castling
	move move-squareFrom 4 == 
		move move-squareTo 6 == and if >>w-oo 
	move move-squareFrom 4 == 
		move move-squareTo 2 == and if >>w-ooo 
	move move-squareFrom 60 == 
		move move-squareTo 62 == and if >>b-oo 
	move move-squareFrom 60 == 
		move move-squareTo 58 == and if >>b-ooo
	>>done-castling
	@w-oo
		\ move rook
		7 P-NONE WHITE put-piece 
		5 P-ROOK WHITE put-piece
		\ no castling available now
		false CASTLING_W_OO!
		false CASTLING_W_OOO!
		>>done-castling
	@w-ooo
		\ move rook
		0 P-NONE WHITE put-piece 
		3 P-ROOK WHITE put-piece
		\ no castling available now
		false CASTLING_W_OO!
		false CASTLING_W_OOO!
		>>done-castling
	@b-oo
		\ move rook
		63 P-NONE BLACK put-piece 
		61 P-ROOK BLACK put-piece
		\ no castling available now
		false CASTLING_B_OO!
		false CASTLING_B_OOO!
		>>done-castling
	@b-ooo
		\ move rook
		56 P-NONE WHITE put-piece 
		59 P-ROOK BLACK put-piece
		\ no castling available now
		false CASTLING_B_OO!
		false CASTLING_B_OOO!
		>>done-castling
	
	@done-castling
	\ update castling availability based on pieces leaving squares
	\ i don't have to check colors since even if the piece leaves its starting
	\ square for 1 move, that is enough to turn off the flag permanently
	CASTLING_W_OO
		4 piece-at P-KING ==
		7 piece-at P-ROOK == and and
			CASTLING_W_OO!
	CASTLING_W_OOO
		4 piece-at P-KING ==
		0 piece-at P-ROOK == and and
			CASTLING_W_OOO!
	CASTLING_B_OO
		60 piece-at P-KING ==
		63 piece-at P-ROOK == and and
			CASTLING_B_OO!
	CASTLING_B_OOO
		60 piece-at P-KING ==
		56 piece-at P-ROOK == and and
			CASTLING_B_OOO!	

	\ flip side to move & return
	SIDE-TO-MOVE other SIDE-TO-MOVE!
	return
	
	@bad-side 
		"SIDE-TO-MOVE out of sync in make-move" error
	;

\ unmake move -- assumes move is valid AND that move was just made	
: unmake-move ( move -- )
	\ remove from squareTo
	move move-squareTo P-NONE WHITE put-piece
	\ place on squareFrom
	move move-squareFrom move move-piece move move-side put-piece
	\ if capture, replace captured piece
	move move-isCapture? not if >>skip
	move move-squareCaptured move move-pieceCaptured move move-side other put-piece
	@skip
	
	\ see if it's castling (did king move 2 squares left/right)
	move move-piece P-KING != if >>done-castling
	move move-squareFrom 4 == 
		move move-squareTo 6 == and if >>w-oo 
	move move-squareFrom 4 == 
		move move-squareTo 2 == and if >>w-ooo 
	move move-squareFrom 60 == 
		move move-squareTo 62 == and if >>b-oo 
	move move-squareFrom 60 == 
		move move-squareTo 58 == and if >>b-ooo
	>>done-castling
	@w-oo
		\ move rook
		5 P-NONE WHITE put-piece 
		7 P-ROOK WHITE put-piece
		>>done-castling
	@w-ooo
		\ move rook
		3 P-NONE WHITE put-piece 
		0 P-ROOK WHITE put-piece
		>>done-castling
	@b-oo
		\ move rook
		61 P-NONE BLACK put-piece 
		63 P-ROOK BLACK put-piece
		>>done-castling
	@b-ooo
		\ move rook
		59 P-NONE WHITE put-piece 
		56 P-ROOK BLACK put-piece
		>>done-castling
		
	@done-castling
	\ restore other state from stack
	UNDO-STACK -1 get unmake drop
	CASTLING_B_OOO! CASTLING_B_OO! CASTLING_W_OOO! CASTLING_W_OO! HALFMOVE! EPSQUARE!
	UNDO-STACK 1 tail-drop UNDO-STACK!
	
	\ flip side to move
	SIDE-TO-MOVE other SIDE-TO-MOVE!
	;
	
\ generate fully legal moves for side	
: gen-full-moves ( side -- moves )
	@locals [ pmoves attacks kingsq ]
	[ ] moves!
	@skip
	side gen-pseudo-moves
	\ loop over all pmoves, removing those that leave the king in check
	{ ( move )
		\ "CHECK PMOVE:" . move print-move-long move . CR
		
		move make-move
		\ get attacks of opposite side now
		side other gen-attacks
		\ see if king square is attacked (king might have moved so can't
		\ cache king square here)
		side BLACK == if >>check-black-king
		KING-SQUARE-W find-equal void? if >>keep-move
		>>done \ discard move 
		@check-black-king
		KING-SQUARE-B find-equal void? if >>keep-move
		>>done \ discard move 
		@keep-move
		\ king is not attacked, so keep this move
		moves move append!
		@done
		move unmake-move
	} for-each
	
	\ get all attacks in current position to determine if castling is legal
	\ but check if castling is possible first to skip expensive attack generation
	side WHITE ==
		CASTLING_W_OO CASTLING_W_OOO or and if >>gen-w-castling
	side BLACK ==
		CASTLING_B_OO CASTLING_B_OOO or and if >>gen-b-castling
	>>done-castling
	
	@gen-w-castling
		side other gen-attacks attacks!
		CASTLING_W_OO not if >>check-w-ooo \ O-O not available
		\ O-O legality check:
		\	* f1 & g1 empty
		5 piece-at P-NONE != if >>check-w-ooo 
		6 piece-at P-NONE != if >>check-w-ooo 
		\	* f1 & g1 not attacked
		attacks 5 find-equal void? not if >>check-w-ooo
		attacks 6 find-equal void? not if >>check-w-ooo
		\	* king not attacked
		attacks 4 find-equal void? not if >>check-w-ooo 
		\ O-O is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 4 6 new-move append!
		
	@check-w-ooo
		\ similar to above, except reuse attacks
		CASTLING_W_OOO not if >>done-castling \ O-O-O not available
		\ O-O-O legality check:
		\	* b1, c1, & d1 empty
		1 piece-at P-NONE != if >>done-castling
		2 piece-at P-NONE != if >>done-castling
		3 piece-at P-NONE != if >>done-castling
		\	* c1 & d1 not attacked
		attacks 2 find-equal void? not if >>done-castling
		attacks 3 find-equal void? not if >>done-castling
		\	* king not attacked
		attacks 4 find-equal void? not if >>done-castling 
		\ O-O-O is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 4 2 new-move append!
		>>done-castling
		
	@gen-b-castling
		side other gen-attacks attacks!
		CASTLING_B_OO not if >>check-b-ooo \ o-o not available
		\ o-o legality check:
		\	* f8 & g8 empty
		61 piece-at P-NONE != if >>check-b-ooo 
		62 piece-at P-NONE != if >>check-b-ooo 
		\	* f8 & g8 not attacked
		attacks 61 find-equal void? not if >>check-b-ooo
		attacks 62 find-equal void? not if >>check-b-ooo
		\	* king not attacked
		attacks 60 find-equal void? not if >>check-b-ooo 
		\ o-o is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 60 62 new-move append!
	
	@check-b-ooo
		\ similar to above, except reuse attacks
		CASTLING_B_OOO not if >>done-castling \ o-o-o not available
		\ o-o-o legality check:
		\	* b8, c8, & d8 empty
		57 piece-at P-NONE != if >>done-castling
		58 piece-at P-NONE != if >>done-castling
		59 piece-at P-NONE != if >>done-castling
		\	* c8 & d8 not attacked
		attacks 58 find-equal void? not if >>done-castling
		attacks 59 find-equal void? not if >>done-castling
		\	* king not attacked
		attacks 60 find-equal void? not if >>done-castling 
		\ o-o-o is legal
		\ move is generated as a king move of 2 squares
		moves
			P-KING side 60 58 new-move append!
		>>done-castling \ just to be explicit		
		
	@done-castling
	
	moves \ return legal moves
	;
