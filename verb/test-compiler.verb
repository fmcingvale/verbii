\ Test compiler functions
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE

: test-digit?
	"0" digit? expectTrue
	"5" digit? expectTrue
	"0" ord 1 - chr digit? expectFalse
	"9" ord 1 + chr digit? expectFalse
	;
	
: test-any-digits?
	"abc3de" any-digits? expectTrue
	"3abc" any-digits? expectTrue
	"abc6" any-digits? expectTrue
	"7" any-digits? expectTrue
	
	"abcde" any-digits? expectFalse
	"abc" any-digits? expectFalse
	"a" any-digits? expectFalse
	"" any-digits? expectFalse
	;
	
: test-ltrim-char
	"abc" "*abc" "*" ltrim-char expect==
	"abc" "abc" "*" ltrim-char expect==
	
	"" "*" "*" ltrim-char expect==
	"" "" "*" ltrim-char expect==
	;
	
: test-ltrim-sign
	"123" "+123" ltrim-sign expect==
	"+123" "++123" ltrim-sign expect==
	"123" "-123" ltrim-sign expect==
	"-123" "--123" ltrim-sign expect==
	"123" "123" ltrim-sign expect==
	"" "" ltrim-sign expect==
	"" "+" ltrim-sign expect==
	"" "-" ltrim-sign expect==
	;

: test-ltrim-digits
	"abc" "123abc" ltrim-digits expect==
	"" "123" ltrim-digits expect==
	"abc" "abc" ltrim-digits expect==
	"" "" ltrim-digits expect==
	;
	
: test-int-string?
	"123" int-string? expectTrue
	"+123" int-string? expectTrue
	"-123" int-string? expectTrue
	"3" int-string? expectTrue
	"+3" int-string? expectTrue
	"-3" int-string? expectTrue
	
	"123a" int-string? expectFalse
	"-123a" int-string? expectFalse
	"+123a" int-string? expectFalse
	"+123.4" int-string? expectFalse
	"-123.4" int-string? expectFalse
	"123.4" int-string? expectFalse
	;
	
: test-float-string?
	"123" float-string? expectTrue
	"123." float-string? expectTrue
	"123.5" float-string? expectTrue
	"123.567" float-string? expectTrue
	"123.567" float-string? expectTrue
	"123e6" float-string? expectTrue
	"123e-5" float-string? expectTrue
	"123.456e-5" float-string? expectTrue
	
	"+123" float-string? expectTrue
	"+123." float-string? expectTrue
	"+123.5" float-string? expectTrue
	"+123.567" float-string? expectTrue
	"+123.567" float-string? expectTrue
	"+123e6" float-string? expectTrue
	"+123e-5" float-string? expectTrue
	"+123.456e-5" float-string? expectTrue
	
	"-123" float-string? expectTrue
	"-123." float-string? expectTrue
	"-123.5" float-string? expectTrue
	"-123.567" float-string? expectTrue
	"-123.567" float-string? expectTrue
	"-123e6" float-string? expectTrue
	"-123e-5" float-string? expectTrue
	"-123.456e-5" float-string? expectTrue
	
	"+123z" float-string? expectFalse
	"+123.z" float-string? expectFalse
	"+123.5z" float-string? expectFalse
	"+123.56z7" float-string? expectFalse
	"+12z3.567" float-string? expectFalse
	"+123ez6" float-string? expectFalse
	"+123ze-5" float-string? expectFalse
	"+123.45z6e-5" float-string? expectFalse
	;
	
: test-opcodes
	\ use make-opcode since #op causes immediate execution
	'FRAME-GET 10 20 30 make-opcode
	'FRAME-GET 10 20 30 make-opcode expect==
	
	'FRAME-GET 10 20 30 make-opcode
	'FRAME-GET 10 20 31 make-opcode expect!=
	
	'FRAME-GET 10 20 30 make-opcode
	'FRAME-SET 10 20 30 make-opcode expect!=
	
	\ make sure packed format is correct
	240520399873 'FRAME-SET 12 34 56 make-opcode opcode-packed expect==
	;
	
: test-string-compile
	\ since the test suite may be running pre-compiled, the compiler itself isn't getting
	\ checked if the .b files exist. so test compiling from strings to ensure the compiler
	\ is working.
	@locals [ f ]
	"""
	\ closures are the most complex part of the compiler, so this should be a good sanity check
	: foo-758 ( a b )
		{ ( c d )
			{ ( e f )
				a b c d e f * + - * -
			}
		}
		;
	"""
	compile-and-load-string
	12 34 foo-758 f!
	56 78 f call f!
	91 23 f call
	
	\ rewriting to check value ...
	\ (a - (b * (c - (d + (e * f)))))
	\ python test code:
	\ $ 12 - (34 * (56 - (78 + (91 * 23))))) = 71922
	71922 expect==
	;
	
	