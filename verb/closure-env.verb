\ Closure environments
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE

\ this defines a closure environment -- this is similar conceptually to a scheme environment.
\ it is used to take some of the work of rewriting variables into frame references out of the
\ rewriting routine so that it can be tested in isolation.
\
\ this is a compile-time environment only; at runtime only frames & indexes are used

\ closure environment:
\	[ TAG dict up ]
\
\	TAG = ,,closure-env (for type checking)
\	dict = maps names into local frame indexes (NAME, not NAME! -- NAME! handled internally)
\	up = next upward frame, or void if toplevel env
: new-closure-env ( -- env )
	',,closure-env	 	\ TAG
	[ ] make-dict		\ dict
	void				\ up
	3 make-list
	;

: closure-env? @( env -- result ) env 0 get ',,closure-env == ;	
: closure-env-dict @( env -- dict ) env 1 get ;
\ set the parent of env (i.e. its outer scope) so that name lookups	
\ can traverse up the parent tree
: closure-env-set-up @( env up -- ) env 2 up put drop ;
: closure-env-get-up @( env -- ) env 2 get ;

\ add a new name (symbol) to env, assigning it the next available index
: closure-env-add-name @( env name -- )
	\ type checking
	env closure-env? not if >>bad-env
	\ check if already defined
	env closure-env-dict name str get void? not if >>dup-name 
	\ add to dict
	env closure-env-dict name str env closure-env-dict length put drop return
	
	@dup-name "Duplicate name in args/locals: " name str + error
	@bad-env "Not a closure environment: " env str + error
	;

\ add a list of names at once
: closure-env-add-namelist @( env names -- )
	names
	@{ @( name )
		env name closure-env-add-name
	} for-each
	;
	
\ lookup name in closure or in any outer scope
\
\ if found, returns ( level index ) where level is the scope level (local==0, first parent==1, etc.)
\ and index is the index into that frame
\
\ if NOT found, returns ( void void )
: closure-env-lookup-name @( env name )
	env name 0 closure-env-lookup-name-inner
	;
	
\ the inner loop, called recursively
: closure-env-lookup-name-inner @( env name level )
	@locals [ index up ]
	\ if name has ! at the end then remove it
	name -1 get '! != if >>lookup
	name 0 name length 1 - slice name! \ remove !
	
	@lookup
	env closure-env-dict name str get index! 
	index void? if >>try-up \ try next scope up
	\ found it, return ( level index )
	level index return
	
	@try-up
		env closure-env-get-up up!
		up void? if >>not-found \ no outer scope, so name not found
		\ recursively search upwards
		up name level 1 + closure-env-lookup-name-inner
		return
		
	@not-found
		void void
	;
	
: closure-env-make-ref-or-set @( name level index )
	name -1 get '! == if >>set 
	\ make a get 
	'FRAME-GET level index 0 make-opcode return
	@set
	'FRAME-SET level index 0 make-opcode return
	;
	
: v2-compile-rewrite-args-locals @( objlist outer-env -- new-objlist nr-rewritten )
	@locals [ argnames localnames env i ]
			
		"* V2-rewrite-args-locals" . CR
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
		
		"ARGS:" . argnames . CR
		"LOCALS:" . localnames . CR
		"NEW-OBJLIST:" . new-objlist . CR
		
		\ track number of var references i rewrite
		0 nr-rewritten!
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ note: i don't have to reserve space for locals -- interpreter creates frame
		\ with sufficient space, so i only have to pop args into frame ...
		
		\ make code to push args to locals (add to new-objlist)
		\ (pop in reverse order of argnames, so range starts at (#argnames-1)
		@{ @( i )
			new-objlist
				'FRAME-SET 0 i 0 make-opcode
				append drop
		} argnames length 1 - 				\ start index = #argnames-1
			-1 								\ count by -1
				argnames length for-range	\ for argnames args
		
		"NEW-OBJLIST:" . new-objlist . CR
		
		\ create an environment to resolve names -- add args first since those are at lowest indexes
		new-closure-env env!
		\ add args first so they'll get assigned indexes starting at 0
		env argnames closure-env-add-namelist
		\ now @locals
		env localnames closure-env-add-namelist
		
		\ .. and chain to my outer scope
		env outer-env closure-env-set-up
		
		"ENV NOW:" . env . CR
		
	\ rewrite symbols using environment just created
	0 i!
	@rewrite-loop
		i objlist length >= if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>list
		\ everything else, copy as-is
	@copy-element
		new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		@locals [ level index sym ]
		objlist i get sym!
		\ see if symbol is in my env or any outer scope
		env sym closure-env-lookup-name index! level!
		index void? if <<copy-element \ not in environment, so copy as is 
		\ turn symbol into get/set opcode
		new-objlist
			sym level index closure-env-make-ref-or-set
			append new-objlist!
		\ increment counter
		nr-rewritten 1 + nr-rewritten!
		>>next 
		
	@list
		\ look for [ ,,v2-closure ... ] (parsed from ::{ .. })
		objlist i get length 2 < if <<copy-element \ list too short, can't be closure
		objlist i get 0 get ',,v2-closure == if >>rewrite-inner-closure \ got [ ,,v2-closure .. ]
		<<copy-element \ not a special list, so just copy element
		
	@rewrite-inner-closure
		@locals [ sub-objlist sub-nr-rewritten ]
		"REWRITE SUBLIST:" . CR
		\ call rewrite recursively with my env as the outer scope
		objlist i get 1 -1 slice \ remove ,,v2-closure
		env v2-compile-rewrite-args-locals sub-nr-rewritten! sub-objlist!
		"GOT NEW SUBLIST:" . sub-objlist . CR
		"NEW OBJLIST:" . new-objlist . CR
		\ turn new sub-objlist back into lambda now that its rewritten and add to new-objlist
		new-objlist
			sub-objlist make-lambda append new-objlist!
		\ did i rewrite ANY names in inner closure (or any inner closures of that, etc.)
		sub-nr-rewritten 0 == if >>done-rewrite-sub 
		\ i rewrote terms, therefore this lambda needs to be bound to my (runtime) frame,
		\ so add that ...
		new-objlist 'bind-lambda append new-objlist!
		
	@done-rewrite-sub
		\ add # rewritten to my count so i return total of mine + all recursive inner lambdas
		nr-rewritten sub-nr-rewritten + nr-rewritten!
		>>next
		
	@next
		i 1 + i! <<rewrite-loop
		
	@done
		new-objlist nr-rewritten return	
		;
		
\ make an environment chain ENV0 (top level) <- ENV1 <- ENV2 (innermost level)
'ENV0 new-closure-env make-var
'ENV1 new-closure-env make-var
'ENV2 new-closure-env make-var

ENV0 'x closure-env-add-name
ENV0 'y closure-env-add-name
ENV0 'z closure-env-add-name

ENV1 'a closure-env-add-name 
ENV1 'b closure-env-add-name 
ENV1 'c closure-env-add-name 

ENV2 't closure-env-add-name 
ENV2 'u closure-env-add-name 
ENV2 'v closure-env-add-name 

\ set ENV0 as parent (outer scope) of ENV1
ENV1 ENV0 closure-env-set-up
\ set ENV1 as outer scope of ENV2 
ENV2 ENV1 closure-env-set-up

ENV2 . CR

[ x y z a b c t u v x! y! z! a! b! c! t! u! v! ]
@{ @( name )
	"Lookup " name str + ":" + . ENV2 name closure-env-lookup-name 2 make-list . CR
} for-each

[ x y z a b c t u v x! y! z! a! b! c! t! u! v! ]
@{ @( name )
	@locals [ level index ]
	ENV2 name closure-env-lookup-name index! level!
	index void? if >>not-found 
	"NAME:" . name str . "CODE:" . 
	name level index closure-env-make-ref-or-set . CR return
	@not-found
	"Name not found:" name str + error
} for-each 

:W zzz ( a b )
	::{ ( d e ) 
		@locals [ x ] 
		\ a d + e * x! 
		dup drop <
	}  
	;

"DUMPING:" . CR	
'zzz .dumpword . CR
"Rewriting:" . CR
'zzz .dumpword 1 -1 slice void v2-compile-rewrite-args-locals 
"RESULT:" . CR
drop . CR

"END STACK:" . .S CR
	