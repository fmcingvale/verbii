

\ make an environment chain ENV0 (top level) <- ENV1 <- ENV2 (innermost level)
'ENV0 new-closure-env make-var
'ENV1 new-closure-env make-var
'ENV2 new-closure-env make-var

ENV0 'x closure-env-add-name
ENV0 'y closure-env-add-name
ENV0 'z closure-env-add-name

ENV1 'a closure-env-add-name 
ENV1 'b closure-env-add-name 
ENV1 'c closure-env-add-name 

ENV2 't closure-env-add-name 
ENV2 'u closure-env-add-name 
ENV2 'v closure-env-add-name 

\ set ENV0 as parent (outer scope) of ENV1
ENV1 ENV0 closure-env-set-up
\ set ENV1 as outer scope of ENV2 
ENV2 ENV1 closure-env-set-up

ENV2 . CR

[ x y z a b c t u v x! y! z! a! b! c! t! u! v! ]
@{ @( name )
	"Lookup " name str + ":" + . ENV2 name closure-env-lookup-name 2 make-list . CR
} for-each

[ x y z a b c t u v x! y! z! a! b! c! t! u! v! ]
@{ @( name )
	@locals [ level index ]
	ENV2 name closure-env-lookup-name index! level!
	index void? if >>not-found 
	"NAME:" . name str . "CODE:" . 
	name level index closure-env-make-ref-or-set . CR return
	@not-found
	"Name not found:" name str + error
} for-each 

\ temporarily -- v2 word defs are prefixed with :W instead of :
:W zzz ( a b )
	::{ ( d e ) 
		@locals [ x ] 
		a b + d e * x!
	}  
	;

"DUMPING:" . CR	
'zzz .dumpword . CR

:W add4 ( a b )
	::{ ( c d )
		a b c d + + +
	}
	;
	
\ "Rewriting:" . CR
\ 'zzz .dumpword 1 -1 slice void v2-compile-rewrite-args-locals 
\ "RESULT:" . CR
\ drop . CR

'a4 void make-var
"Add4:" . CR
10 22 add4 a4!
"A4:" . a4 . CR
"Expect 116:" . 
36 48 a4 call . CR

:W add6 ( a b )
	::{ ( c d )
		::{ ( e f )
			a b c d e f + + + + +
		}
	}
	;
	
'a6 void make-var
\ call add6, get 1st level bound lambda
13 25 add6 a6!
\ call 1st level bound lambda, get 2nd level bound lambda
37 41 a6 call a6!
\ call 2nd level lambda, get sum
"Expect 236:" . 53 67 a6 call . CR

\ this is the problem that v2 closures were designed to handle
\ -- in v1 closures, outer scope was captured by VALUE so changes
\    made in inner closure would not be seen in outer scope, or other
\    inner scopes.
\ -- with v2, the values propogate as you would expect in other languages
:W changer ( a )
	"Outer a:" . a . CR
	::{
		"Inner1 a:" . a . CR
		a 10 + a!
		"Inner1 a+10:" . a . CR
	}
	call
	"Outer a:" . a . CR
	::{
		"Inner2 a:" . a . CR
		a 30 + a!
		"Inner2 a+30:" . a . CR
	}
	call
	"Outer a:" . a . CR
	;
	
33 changer

\ something more complicated
:W stringadds ( s )
	@locals [ add+ add* ]
	"Outer s:" . s . CR
	\ make 2 closures that modify s in different ways, saving to add+ and add*
	::{
		s "+" + s!
		"Inner-1, add '+' = " . s . CR
	} add+!
	::{
		s "*" + s!
		"Inner-2, add '*' = " . s . CR
	} add*!
	
	"Outer - adding ++*+*:" . CR
	add+ call add+ call add* call add+ call add* call
	"Outer s now:" . s . CR
	;
	
"Hello" stringadds 

\ this is not working as intended yet
:W listtest ( a b c )
	[ a b c ]
	;

"List test:" . 	
11 22 33 listtest . CR

"END STACK:" . .S CR
	