\
\ WIP of new rewrite/closure code
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE

\ copy first nr locals into list [ LP LP+1 LP+2 ... ]
: locals-to-list ( nr -- list )
	\ cannot use @( .. ) params since that would mess up the locals
	[ ]
	0
	@loop ( nr list i )
		dup SP 3 + ref ( nr list i i nr ) >= if >>done
		dup LP + ref ( nr list i Li )
		SP 2 + ref swap ( nr list i list Li ) append drop ( nr list i )
		1 + ( nr list i+1 ) <<loop
	@done ( nr list i )
		drop nip
	;	


\ add each name to dict with value set to size of dict at time name was added
\ (i.e. adding [ "a" "b" "c" ] to an empty dict gives a=0, b=1, c=2)
\ note: symbols are accepted and converted to strings
: dict-add-indexed-names @( dict names -- dict-out )
	@locals [ i ]
	0 i!
	@loop
		i names length >= if >>done 
		dict names i get str dict length put drop \ dict[name[i]] = len(dict)
		i 1 + i! <<loop
	@done
		dict
	;
	

\ variant of for-each that calls func with ( key val )
: for-each-dict @( dict func -- )
	@locals [ i keylist ]
	dict keys keylist!
	0 i!
	@loop
		i keylist length >= if >>done 
		keylist i get dup dict swap get func call
		i 1 + i! <<loop
	@done 
		;
		

\ rewrites an objlist to translate arg/local names including capturing outer vars (closures)
\
\ selfmap should be set to an empty dict at the toplevel
\
\ ASSUMPTIONS:
\	1. objlist must come from a lambda, not a plain list (rewriting ensures a return is at the end 
\	   	of new objlist, so has to be assumed to be code)
\	2. closures must be marked with @{ ... } ; will NOT transform unmarked lambdas since they might
\		be used in other binding constructs
\	3. does NOT (yet) rewrite lists so dynamic code cannot use @args/@lists nor create closures
\		(user code can manually do closures with :: of course)
\
\ does these things:
\	1. scans objlist (non-recursively) for @args, @locals, and/or [ ,,declargs ... ]
\	2. if NO names found in above search, then objlist is returned as-is and changed=false
\		(no names at THIS level, means no captures can happen here or anywhere underneath)
\	3. rewrite objlist to do:
\		a. alloc locals (LP nr - LP!)
\		b. pop args (L> L> ...)
\		c. rewrite symbols to their code sequences:
\			(i) if name in args/locals, rewrite to (LP i + ref) or (LP i + set!)
\			(ii) if name in selfmap, rewrite to (self i get) or (self i rot put)
\		d. if an inner lambda is found ( @{ ... } -- @ is required for backward compat with { .. } obj :: code )
\			(i) recursively rewrite lambda, passing selfmap + my args+locals as its selfmap
\			(ii) add binding of selfmap + my locals as self for inner lambda
: NEW-rewrite-args-locals @( objlist selfmap -- new-objlist )
	@locals [ argnames localnames local-refmap local-setmap new-objlist i self-setmap ]
		\ "REWRITE-ARGS-LOCALS OBJLIST:" . objlist . CR
		\ "SELFMAP:" . selfmap . CR
		
	\ ensure objlist ends with a 'return', or add one
	objlist -1 get 'return == if >>scan-args-locals
	objlist 'return append objlist!
	
	@scan-args-locals
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
			\ "AFTER COLLECT: ARGS=" . argnames . "LOCALS=" . localnames . "OBJLIST=" . new-objlist . CR

		\ note: even if i have no @args/@locals, i can still have names that resolve to selfmap
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ make preamble code to:
		\	1. alloc spaces for @locals
		\	2. pop args to locals
		\ note this will put args starting at LP and locals starting at LP + #args
		
		\ 1. alloc locals (LP #localnames - LP!)
		localnames length 0 == if >>popargs \ omit code if no locals
		'LP localnames length '- 'LP! 4 make-list new-objlist!
	@popargs
		\ 2. push args to locals (adding code to new-objlist)
		argnames { ( accum elem ) drop '>L append } new-objlist fold new-objlist! 
		
		\ make a map of arg|local name -> index into locals
		[ ] make-dict argnames localnames + dict-add-indexed-names local-refmap!
		"MADE NAMEMAP:" . local-refmap . CR
		\ map a map of name! as well to replace setters
		[ ] make-dict 
			argnames { str "!" + } map 
			localnames { str "!" + } map 
			+ dict-add-indexed-names local-setmap!
		"MADE SETTER MAP:" . local-setmap . CR
		
		\ for each name in selfmap, make name! in self-setmap with same index
		[ ] make-dict self-setmap!
		selfmap
		{
			( key val ; self self-setmap )
			self -rot swap "!" + swap put drop
		} self-setmap :: for-each-dict
		"SET-SETMAP:" . self-setmap . CR
		
	\ rewrite objlist replacing arg|local symbols with appropriate code sequences and creating
	\ closures as needed
	0 i!
	@rewrite-loop
			\ "REWRITE LOOP, NEW NOW:" . new-objlist . CR
			\ "REWRITE LOOP STACK:" . .S CR
		i objlist length >= if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>list
		\ everything else, copy as-is
	@copy-element
		new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		objlist i get 'return == if >>rewrite-return
		\ is symbol (as string) in local-refmap?
		local-refmap objlist i get str get void? not if >>rewrite-local-ref
		\ is symbol (as string) in selfmap?
		selfmap objlist i get str get void? not if >>rewrite-self-ref
		\ check for local setter
		local-setmap objlist i get str get void? not if >>rewrite-local-set
		\ check for self setter
		self-setmap objlist i get str get void? not if >>rewrite-self-set
		
		\ else not in either list, keep as-is
		<<copy-element
		
	@rewrite-local-ref
		\ add (LP i + ref) to new-objlist
		new-objlist
		'LP local-refmap objlist i get str get '+ 'ref 4 make-list
		+ new-objlist! >>next
		
	@rewrite-local-set
		\ add (LP i + set!) to new-objlist
		new-objlist
		'LP local-setmap objlist i get str get '+ 'set! 4 make-list
		+ new-objlist! >>next
	
	@rewrite-self-ref
		\ add (self i get) to new-objlist
		new-objlist
		'self selfmap objlist i get str get 'get 3 make-list
		+ new-objlist! >>next
	
	@rewrite-self-set
		\ add (self i rot put) to new-objlist
		new-objlist
		'self self-setmap objlist i get str get 'rot 'put 4 make-list
		+ new-objlist! >>next
		
	@rewrite-return
			\ "******* REWRITE RETURN ************" . CR
		\ replace return with code to remove local frame
		new-objlist
		'LP argnames length localnames length + '+ 'LP! 'return 5 make-list
		+ new-objlist! >>next
		
	@list
		\ look for [ ,,closure ... ] (parsed from @{ .. })
		objlist i get length 2 < if <<copy-element \ list too short, can't be closure
		objlist i get 0 get ',,closure != if <<copy-element \ not [ ,,closure .. ] so just copy element
		\ recursively parse list, passing a selfmap that is my selfmap + my locals
		selfmap deepcopy \ don't alter my selfmap
		( inner-selfmap )
		argnames dict-add-indexed-names \ add arg names first -- they are first on locals stack
		localnames dict-add-indexed-names \ .. then locals
		( inner-selfmap )
		objlist i get 1 -1 slice \ remove ,,closure
		swap ( objlist inner-selfmap )
			\ "** PARSE INNER LAMBDA:" . CR
		NEW-rewrite-args-locals ( new-objlist )
			\ "** INNER REWROTE:" . over . CR
		make-lambda \ turn new-objlist back into lambda
		new-objlist swap append new-objlist! \ add lambda to new-objlist
		\ now create code to make runtime binding for new lambda
		\ want self = [ self0 .. selfN arg0 .. argN local0 .. localN ]
		\ so code will be:
		\	[ ] self + ( shallow-copy self )
		\	#args #locals + locals-to-list + ( self + locals ) ::
		
		\ NOTE! have to check for empty selfmap since referencing a non-existent self is an error
		selfmap length 0 == if >>no-selfmap
		
		\ case 1: my self is bound so concatenate my locals to self
		0 'make-list 'self '+ argnames length localnames length + 'locals-to-list '+ '::
		8 make-list new-objlist swap + new-objlist! \ add self-making code to new-objlist
		>>next
		
	@no-selfmap
		\ case 2: no selfmap so just pass on my locals
		argnames length localnames length + 'locals-to-list '::
		3 make-list new-objlist swap + new-objlist! \ add self-making code to new-objlist
		>>next
		
	@next
		i 1 + i! <<rewrite-loop
	
	@done
		new-objlist return
	;
	
\ [ @args [ a b c ] @locals [ d e f ] a b c + * d! [ ,,closure b c / e! return ] x z * y! return ]
\ [ @args [ a b c ] @locals [ d e f ] 10 20 + return ]
\ [ @args [ a b c ] @locals [ d ] a b c * + d! return ]
\ [ @args [ a b ] @locals [ c ] [ ,,closure @args [ d e ] a b c d e ] ]
\ [ @locals [ d e f ] ]
\ [ @args [ a b c ] ]
\ [ [ "x" 0 ] [ "y" 1 ] [ "z" 2 ] ] make-dict \ selfmap
[ @args [ a b ] [ ,,closure @args [ c d ] [ ,,closure @args [ e f ] a b c d e f ] ] ]
\ [ @args [ a b ] [ ,,closure @args [ c d ] a b c d ] ]
[ ] make-dict \ selfmap
NEW-rewrite-args-locals
"NEW-OBJLIST:" . . CR
"END STACK:" . .S CR
