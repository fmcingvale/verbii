
\ Demonstrate closures ('version 2')
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE

\ first, here is a plain lambda - it does not capture anything so can
\ only work with stack value, no named variables.
{ "Hello lambda!" . CR }
\ run it with 'call'
call

\ make a plain lambda taking 3 stack args A,B,C and returns A+B*C 
"Expect 5+6*7 = 47:" .
5 6 7 { * + } call . CR

\ plain (non-capturing) lambdas work fine for simple functions, but
\ as you add more arguments and more complexity in the function, the
\ stack shuffling becomes unwieldy. so named variables help a lot
\ with readabiliy.
\
\ here is the same function as above, written as a closure:
"Expect 5+6*7 = 47:" . 
5 6 7 \ push args to stack
\ the ::{ indicates this should be compiled as a closure; eventually this will not be necessary
::{  ( a b c ) \ args are automatically popped from the stack and can be referred to with names
	\ return a+b*c
	b c * a +
} call . CR

\ of course, such a trivial function doesn't really need named variable, but that
\ demonstrates the basic usage

\ closures get interesting when you use them to store state information.
\ for example, let's make an accumulator factory
\	ref: http://rosettacode.org/wiki/Accumulator_factory
\
\ an accumulator factory works like this:
\	f = make-accumulator(11) -> create accumulator function with initial sum=11
\	f(10) -> returns 21 (i.e. 11+10)
\	f(20) -> returns 41 (i.e. 11+10+20)
\	f(50) -> returns 91 (i.e. 11+10+20+50)

"* Accumulator factory" . CR

:V2 make-accumulator ( initval )
	\ return a lambda that, when called with a numeric argument, adds the argument
	\ to its sum and returns the new sum
	::{ ( n )
		initval n + initval! \ update my sum
		initval \ return new sum
	}
	;
	
\ lets make several accumulators and store them in variables to show that they
\ are independent from each other
'acc1 11 make-accumulator make-var \ acc1 start with initval=11
'acc2 33 make-accumulator make-var \ acc2 start with initval=33
'acc3 100 make-accumulator make-var \ acc3 start with initval=100
 
\ lets show the intial values first by adding zeros
"acc1 init [11] = " . 0 acc1 call . CR
"acc2 init [33] = " . 0 acc2 call . CR
"acc3 init [100] = " . 0 acc3 call . CR

"STACK:" . .S CR

"Adding 20 to each ..." . CR
"acc1 [31] = " . 20 acc1 call . CR
"acc2 [53] = " . 20 acc2 call . CR
"acc3 [120] = " . 20 acc3 call . CR

"Adding 100 to each ..." . CR
"acc1 [131] = " . 100 acc1 call . CR
"acc2 [153] = " . 100 acc2 call . CR
"acc3 [220] = " . 100 acc3 call . CR

\ the accumulator factory works because the inner closure captures a reference
\ to 'initval' that was passed to the function that created the accumulator.
\ therefore, closures capture state as you would expect in other languages.

\ in earlier versions of verbii, closures captured VALUES so they would correctly
\ store the state from the outer context, but the outer context could not see any changes
\ that the inner closure made. this was unlike other languages like scheme, so was changed
\ to references call frames as is normally done.

\ so here is an example to show that it works like you'd expect ...

:V2 test-outer-inner ( x )
	@locals [ f1 f2 ]
	"Hello outer! x =" . x . CR
	\ lets make two closures that capture x and store
	\ them to locals f1 and f2
	::{
		"Closure-1 begin, x=" . x . CR
		"Adding 11" . CR
		x 11 + x!
		"Closure-1 end, x=" . x . CR		
	} f1! \ store this closure to f1
	
	::{
		"Closure-2 begin, x=" . x . CR
		"Adding 100" . CR
		x 100 + x!
		"Closure-2 end, x=" . x . CR		
	} f2! \ store this closure to f2
	
	"--- Run closure-1:" . CR f1 call
	"--- Run closure-2:" . CR f2 call
	
	"outer end, x=" . x . CR
	;
	
"* Show that closure-1 and closure-2 changes DO affect outer x value ..." . CR

44 test-outer-inner

\ so you can see from the above that the outer context and the two inner lambdas share 
\ the same state. this same state is shared AFTER the outer function returns (as you would
\ expect in e.g. scheme)

:V2 make-math-ops ( x )
	\ make lambdas that perform +, -, * and / operations on x to
	\ show they share the same x 
	
	\ x += n
	::{ ( n )
		x . "+" . n . "=" .
		x n + x! x . CR
	}
	
	\ x -= n
	::{ ( n )
		x . "-" . n . "=" .
		x n - x! x . CR
	}
	
	
	\ x *= n
	::{ ( n )
		x . "*" . n . "=" .
		x n * x! x . CR
	}
	
	
	\ x /= n
	::{ ( n )
		x . "/" . n . "=" .
		x n / x! x . CR
	}
	;

\ instead of making a bunch of globals, make a test function ...
:V2	test-math-ops ( x )
	@locals [ fADD fSUB fMUL fDIV ]
	"* Testing math ops maker ..." . CR
	x make-math-ops fDIV! fMUL! fSUB! fADD!
	"Starting X = " . x . CR
	20 fADD call
	50 fSUB call
	12 fMUL call
	7 fDIV call
	;
	
15 test-math-ops

\ this shows that the same name can be defined in an outer
\ and inner scope and the inner name will be seen in the inner scope

:V2 scope-test-1 ( i )
	"scope test outer i =" . i . CR
	::{ ( i )
		"inner scope i =" . i . CR
	}
	;
	
"* Outer scope sees i=10, inner sees i=20 ..." . CR
10 scope-test-1 \ outer sees i=10
20 swap call    \ inner sees i=20

\ === the following is a test/demo of all closure forms ...

:V2 cl-test1 ( a b )
	\ returns closure that captures a,b from
	\ outer context
	::{
		"a:" . a . "b:" . b . CR
	}
	;

"* Test all closure forms ..." . CR

\ show closure holds correct values after test1 returns
'F1 null make-var
'F2 null make-var

\ make 2 closures to show they are independent
11 22 cl-test1 F1!
33 44 cl-test1 F2!

"Expect a,b=11,12:" . F1 call
"Expect a,b=33,44:" . F2 call

:V2 cl-test2 ( a b )
	::{ ( c d )
		\ 2nd level closure that captures a,b,c,d
		::{
			"a:" . a . "b:" . b . 
			"c:" . c . "d:" . d . CR
		}
	}
	;

33 44 cl-test2 F1!
100 200 cl-test2 F2!
\ now send the c,d args to each
55 66 F1 call F1!
300 400 F2 call F2!
\ now call inners
"Expect a,b,c,d=33,44,55,66:" . CR 
F1 call

"Expect a,b,c,d=100,200,300,400:" . CR 
F2 call

\ .. and nesting one more ...
:V2 cl-test4 ( a b )
	::{ ( c d )
		\ 2nd inner 
		::{ ( e f ) 
			"a:" . a . "b:" . b .
			"c:" . c . "d:" . d .
			"e:" . e . "f:" . f . CR
		}
	}
	;

"aa" "bb" cl-test4 F1!
"AA" "BB" cl-test4 F2!

"cc" "dd" F1 call F1!
"CC" "DD" F2 call F2!

"Expect a,b,c,d,e,f=aa,bb,cc,dd,ee,ff:" . CR
"ee" "ff" F1 call
"Expect a,b,c,d,e,f=AA,BB,CC,DD,EE,FF:" . CR
"EE" "FF" F2 call

:V2 cl-test5 ( a b c )
	\ inside [ .. ], captured names are replaced with values
	[ a b c ]
	;

"Expect [ 12 34 56 ]:" .
12 34 56 cl-test5 . CR

:V2 cl-test6 ( a b )
	[
		\ captures should be seen in @{ .. } as well
		::{
			a b +
		}
	]
	;

'cl-test6 .dumpword . CR

"Expect 59:" . 12 47 cl-test6 0 get call . CR

:V2 cl-test7 ( a b c )
	[
		\ inside [ .. ] closures should work as expected
		::{ "a:" . a . "b:" . b . "c:" . c . CR }
		::{ "a*b:" . a b * . "b*c:" . b c * . CR }
	]
	;

"Expect a,b,c,d=111,222,333:" . 
111 222 333 cl-test7 
dup 0 get call
"Expect a*b=24642, b*c=73926:" .
dup 1 get call
