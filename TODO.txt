Global TODO

---[    Ports    ]------------------------------------------------------

* node.js

* scala

* swift

---[    Demos    ]------------------------------------------------------

* Chess engine

* (mini) scheme -> verbii translator

* more rosettacode tasks:
	* https://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm
	* https://rosettacode.org/wiki/Heronian_triangles
	* https://rosettacode.org/wiki/Additive_primes
	* https://rosettacode.org/wiki/Anti-primes
	* https://rosettacode.org/wiki/S-expressions
	* https://rosettacode.org/wiki/Bulls_and_cows
	* https://rosettacode.org/wiki/Prime_decomposition

---[  Libraries  ]------------------------------------------------------

* JSON import/export

* math: gcd, sqrt

---[   Features   ]------------------------------------------------------

* add caching of byte-compilation, i.e. file.verb is cached to file.verb.b after
  a successful byte-compile. to support this:
	* need new words: file-exists?, file-mtime
	* compiler needs to support writing to a file instead of (or in addition to) stdout
	* deserialize needs to be callable from verbii

* slightly change 'if' semantics:
	1. pop bool from stack
	2. if true, run next word (i.e. do nothing)
	3. if false, skip over next word and continue

	* in other words, word after 'if' no longer has to be a jump, but if it is
	  a jump, code will continue to work as it always has

* commpiler:syntax-next should return void instead of null on EOF conditions.
	* once that is done, then null can be added as a literal like true & false were 
	* make sure void is not serializable

* add bit level operations -- limit to 32 bits
	* add random number generator

* the L0,L1, etc should become:
	: L3 LP 3 + ref ;
	: L3! LP 3 + set! ;

* add open-input-file, open-output-file, open-string, read-line, read-char, 
write-string, write-char ... basically I/O with ports concept like scheme

* pick should be 0-based for consistency with other 0-indexed functions
	* I think I should just add names S0, S0! S1 S1! etc to initlib instead

* add load or import word (in verbii if possible)

* more repl pieces in verbii

* need to extend ,,del (or maybe just get rid of 'del NAME' and always make del stack-based??)
  to delete entries from more objects:
	dict STRING ,,del ( delete a key from dictionary )
	SYMBOL ,,del ( delete a word )
	list INDEX ,,del ( delete entry from list )

* make sure { .. } :: obj works -- right now just [ .. ] :: obj is accepted

* chicken needs backtraces

---[    Tests     ]------------------------------------------------------

* math demo needs to be a unittest -- rework it to print TESTNAME: OK, or something like that, instead
of printing all the numeric values which will not match between platforms
 
---[   Clean-up   ]------------------------------------------------------

* compiler should insert a 'return' at the end of words to rid of special cases in interpreter

* I think parse-bool can be removed now .. also remove null & ,,null once that is possible

* chicken: main interpreter loop -- use while instead of having to place recursive calls everywhere

* More error checking of input types in library/tests/demos

* sort out usage of null/NULL/'void' in ports for consistency. add some unittests
that include null to make sure it is handled correctly. also make sure voids are 
never visible from verbii code
	*** POSSIBLY void can be a word (but NOT a literal, so it can never be serialized directly)
	    this would allow functions that can return null to return a "nothing" as void

* make sure ports all implement the same builtins (c++ has more that are not in other ports right now)

* why does chicken port report more userwords when running same code as other ports?

* in native.* the pop* functions should take a 'where' argument like chicken

* chicken: cleanout old comments

* python: get rid of more type() and isinstance() and replace with the correct is*() function

---[ Optimization ]------------------------------------------------------

* I think the native make-word should be renamed to something like set-word and 
  make-word should be implemented in verbii and perform optimizations at creation time
  examples:
	* convert jumps into offsets so no searching is required at runtime

	* convert words into indexes so they can be called without lookup at runtime
		* WORDS in interpreter would then be a list

	* add syntax like:
		: name args [ a b c ] vars [ d e f ]
		where:
			* a, b, c are pulled from the stack into locals
			* d, e, f are added to locals, undefined
			* names are created: a == 'LP i + ref', a! == 'LP i + set!'
			* compiler converts names into LP/ref/set! at compile time so no
			  overhead other than setting args up into locals
			* compiler emits cleanup code (LP + n LP!) before 'return'
				* need to add a return at end of all word lists for simplicity
	
	* try inlining small functions
	
* 'get' should be a builtin, both for efficiency and for symmetry now that 'put' exists

* improve exp by reducing x like dividing by 100,1000,1e6,etc. and adjusting
  at end since values for powers of 10 can be in a table (exp algorithm seems
  to have trouble with larger values)

---[   Unsorted   ]------------------------------------------------------


