Global TODO

---[    Ports    ]------------------------------------------------------

* node.js

* scala

* swift

---[    Demos    ]------------------------------------------------------

* Chess engine

* (mini) scheme -> verbii translator

* more rosettacode tasks:
	* https://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm
	* https://rosettacode.org/wiki/Heronian_triangles
	* https://rosettacode.org/wiki/Additive_primes
	* https://rosettacode.org/wiki/Anti-primes
	* https://rosettacode.org/wiki/S-expressions
	* https://rosettacode.org/wiki/Bulls_and_cows
	* https://rosettacode.org/wiki/Prime_decomposition

---[  Libraries  ]------------------------------------------------------

* JSON import/export

* math: gcd, sqrt

---[   Features   ]------------------------------------------------------

* add caching of byte-compilation, i.e. file.verb is cached to file.verb.b after
  a successful byte-compile. to support this:
	* need new words: file-exists?, file-mtime
	* compiler needs to support writing to a file instead of (or in addition to) stdout
	* deserialize needs to be callable from verbii

* slightly change 'if' semantics:
	1. pop bool from stack
	2. if true, run next word (i.e. do nothing)
	3. if false, skip over next word and continue

	* in other words, word after 'if' no longer has to be a jump, but if it is
	  a jump, code will continue to work as it always has

* add bit level operations -- limit to 32 bits
	* add random number generator

* the L0,L1, etc should become:
	: L3 LP 3 + ref ;
	: L3! LP 3 + set! ;

* add open-input-file, open-output-file, open-string, read-line, read-char, 
write-string, write-char ... basically I/O with ports concept like scheme

* pick should be 0-based for consistency with other 0-indexed functions
	* I think I should just add names S0, S0! S1 S1! etc to initlib instead

* add load or import word (in verbii if possible)

* more repl pieces in verbii

* need to extend ,,del (or maybe just get rid of 'del NAME' and always make del stack-based??)
  to delete entries from more objects:
	dict STRING ,,del ( delete a key from dictionary )
	SYMBOL ,,del ( delete a word )
	list INDEX ,,del ( delete entry from list )

* make sure { .. } :: obj works -- right now just [ .. ] :: obj is accepted

* chicken needs backtraces

---[    Tests     ]------------------------------------------------------

* reorganize tests by category?
 
---[   Clean-up   ]------------------------------------------------------

* compiler should insert a 'return' at the end of words to rid of special cases in interpreter

* I think parse-bool can be removed now .. also remove null & ,,null once that is possible

* chicken: main interpreter loop -- use while instead of having to place recursive calls everywhere

* More error checking of input types in library/tests/demos

* make sure ports all implement the same builtins (c++ has more that are not in other ports right now)

* why does chicken port report more userwords when running same code as other ports?

* in native.* the pop* functions should take a 'where' argument like chicken

* chicken: cleanout old comments

* python: get rid of more type() and isinstance() and replace with the correct is*() function

---[ Optimization ]------------------------------------------------------

* repls are still doing to much work, even more with caching additions. need to push more
  of this to verbii code. maybe interpreter:run should have a safe_run wrapper to handle
  a lot of this that could be called from verbii (??)
  
* compiler.verb -- in byte-compile, all words for __main__ get pushed to stack and then
  a huge list made at the end. this leads to stack overflows for large files (like the unittests
  where everything is in __main__). would be better to add items in chunks (maybe do an append
  every N words, for example)  so compilation won't overflow the stack. for now i just bumped up the
  stack size in all ports.

* I think the native make-word should be renamed to something like set-word and 
  make-word should be implemented in verbii and perform optimizations at creation time
  examples:
	* convert jumps into offsets so no searching is required at runtime

	* convert words into indexes so they can be called without lookup at runtime
		* WORDS in interpreter would then be a list

	* add syntax like:
		: name @args [ a b c ] @vars [ d e f ]
		where:
			* a, b, c are pulled from the stack into locals
			* d, e, f are added to locals, undefined
			* names are created: a == 'LP i + ref', a! == 'LP i + set!'
			* compiler converts names into LP/ref/set! at compile time so no
			  overhead other than setting args up into locals
			* compiler emits cleanup code (LP + n LP!) before 'return'
				* need to add a return at end of all word lists for simplicity
	
	* try inlining small functions

* improve exp by reducing x like dividing by 100,1000,1e6,etc. and adjusting
  at end since values for powers of 10 can be in a table (exp algorithm seems
  to have trouble with larger values)

* the chicken argument dispatch to builtins is really slow ... rework

---[   Unsorted   ]------------------------------------------------------


