Global TODO

---[   Periodic  ]------------------------------------------------------

* run all unittests, demos, etc. with -stats across ports to make sure
  everything matches (# userwords, # tail calls, builtin words, max stack/locals depth)
  and no Notices are given (i.e. stack/locals not clean)

---[    Ports    ]------------------------------------------------------

* node.js

* scala

* swift

---[    Demos    ]------------------------------------------------------

* simple demo games (i.e. 'guess the number', etc. beginner programming type things)

* Chess engine

* (mini) scheme -> verbii translator

* more rosettacode tasks:
	* https://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm
	* https://rosettacode.org/wiki/Heronian_triangles
	* https://rosettacode.org/wiki/Additive_primes
	* https://rosettacode.org/wiki/Anti-primes
	* https://rosettacode.org/wiki/S-expressions
	* https://rosettacode.org/wiki/Bulls_and_cows
	* https://rosettacode.org/wiki/Prime_decomposition

---[  Libraries  ]------------------------------------------------------

* JSON export

---[   Features   ]------------------------------------------------------

* SCRIPT-ARGS (repl/boot?) should be a read only var instead of returning an address

* add an 'append' for strings, like lists, to allow dynamically growing strings without breaking
  backwards compat ... so ie. the rules are:
		object + object => new object (e.g. [ a b ] + [ c d ] == new list [ a b c d ])
		object part append => modifies existing object, leaving obj on stack
		
		since no code uses 'string string append' right now there is no code to break
		
	lists have an 'append' and 'extend' since there is a semantic difference between e.g. adding
	a list an an ELEMENT and flattening a list into an existing list. with strings, append is the
	same regardless of 1 char vs 100
	
* i think i need to move to a character instead of word parser .. things like: "\a comment" crash the
  parser with no explanation of what happened .. so at least char-by-char for these cases:
	* \a comment
	* [1 2 3 4]
	* @[1 2 3 4]
	* {1 2 3 4}
	* @{1 2 3 4}
	
	-- * -- cons of this approach would be, for example, word breaking allows making variations
	of matched tokens easily ... for example when I was making v1/v2 closures i added syntax
	like @{ that wouldn't have been possible if '{' was ALWAYS treated specially, for example.
	
	-- * -- BUT ... character-based is more what is expected in modern languages i think so
	may be worth it overall.
	
* add mergesort

* i think COUNT in "var NAME COUNT" is not really gaining anything -- just make it 'var NAME' then
  NAME can be defined to get value and NAME! to set value. if arrays are needed then
  just store a list to NAME

* slightly change 'if' semantics:
	1. pop bool from stack
	2. if true, run next word (i.e. do nothing)
	3. if false, skip over next word and continue

	* in other words, word after 'if' no longer has to be a jump, but if it is
	  a jump, code will continue to work as it always has

* need to extend ,,del (or maybe just get rid of 'del NAME' and always make del stack-based??)
  to delete entries from more objects:
	dict STRING ,,del ( delete a key from dictionary )
	SYMBOL ,,del ( delete a word )
	list INDEX ,,del ( delete entry from list )

* chicken needs backtraces

---[    Tests     ]------------------------------------------------------

---[   Clean-up   ]------------------------------------------------------

* maybe? rename bitops for readability:
	bit-shr -> bit>>
	bit-shl -> bit<<
	
* I think lambda & bound-lambda should be merged, so it's just a lambda with or
  without an outer frame set

	* then, words should be lambdas instead of objlists so they can be bound as well

* this is broken (del in v2 funcs) ...
	>> : foo 'ZZZ 1 make-var del ZZZ ;
	=>
	>> 'foo .dumpword
	=> [ ''ZZZ 1 'make-var [ ',,inline ''ZZZ ',,del ] ]
	>> foo
	=> [ ''ZZZ 1 'make-var [ ',,inline ''ZZZ ',,del ] ] [ ',,inline ''ZZZ ',,del ]
	
	** lots of other examples fail like:
		[ [ { del YYY } ] ]
		
		[ [ "a" { del FF } ] [ "b" { del GG } ] ]
		
* + on lists is kind of unsafe -- extend is better since it maintains object identity (important across
  closure boundaries). a list+ could be defined as:
	: list+ @( list1 list2 ) [ ] list1 extend list2 extend ;

* change all verbii code to use make-var instead of var then get rid of old ,,var/var -- can replace with make-var based function

* chicken - minimize imports across all files

* check all places (in all ports) where files are opened to make sure any errors are returned
  as verbii errors and don't crash the host language

* need a better way to find lib/ than hardcoding/assuming path in repls
	* also need to find modules in same path as source file without having to run in that directory
	
* More error checking of input types in library/tests/demos

* make sure ports all implement the same builtins (c++ has more that are not in other ports right now)

* c++ reports (sometimes vastly) different # of tail calls with -stats than other ports

* in native.* the pop* functions should take a 'where' argument like chicken

---[ Optimization ]------------------------------------------------------

* compiler.verb -- in byte-compile, all words for __main__ get pushed to stack and then
  a huge list made at the end. this leads to stack overflows for large files (like the unittests
  where everything is in __main__). would be better to add items in chunks (maybe do an append
  every N words, for example)  so compilation won't overflow the stack. for now i just bumped up the
  stack size in all ports.

* I think the native make-word should be renamed to something like set-word and 
  make-word should be implemented in verbii and perform optimizations at creation time
  examples:
	* convert jumps into offsets so no searching is required at runtime

	* try inlining small functions
		* the question would be should this be done recursively and to what depth?
			i.e. 
				: 3dup dup dup dup ;
				: 9dup 3dup 3dup 3dup ;

			should 9dup be expanded to the 3dups, then the 3dups expanded to dups,
			then the dups expanded to their lowest level form?

* i think i should add more math functions (sin,cos,log,exp,etc.) -- these
  are all basically 1-liners so isn't saving significant code space now to
  omit them.

* math: gcd, sqrt
	
* the chicken argument dispatch to builtins is really slow ... rework

---[   Unsorted   ]------------------------------------------------------


