Global TODO

---[   Periodic  ]------------------------------------------------------

* run all unittests, demos, etc. with -stats across ports to make sure
  everything matches (# userwords, # tail calls, builtin words, max stack/locals depth)
  and no Notices are given (i.e. stack/locals not clean)

---[    Ports    ]------------------------------------------------------

* node.js

* scala

* swift

---[    Demos    ]------------------------------------------------------

* simple demo games (i.e. 'guess the number', etc. beginner programming type things)

* Chess engine

* (mini) scheme -> verbii translator

* more rosettacode tasks:
	* https://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm
	* https://rosettacode.org/wiki/Heronian_triangles
	* https://rosettacode.org/wiki/Additive_primes
	* https://rosettacode.org/wiki/Anti-primes
	* https://rosettacode.org/wiki/S-expressions
	* https://rosettacode.org/wiki/Bulls_and_cows
	* https://rosettacode.org/wiki/Prime_decomposition

---[  Libraries  ]------------------------------------------------------

* JSON export

---[   Features   ]------------------------------------------------------

* i think COUNT in "var NAME COUNT" is not really gaining anything -- just make it 'var NAME' then
  NAME can be defined to get value and NAME! to set value. if arrays are needed then
  just store a list to NAME

* add caching of byte-compilation, i.e. file.verb is cached to file.verb.b after
  a successful byte-compile. to support this:
	* need new words: file-exists?, file-mtime
	* compiler needs to support writing to a file instead of (or in addition to) stdout
	* deserialize needs to be callable from verbii

* slightly change 'if' semantics:
	1. pop bool from stack
	2. if true, run next word (i.e. do nothing)
	3. if false, skip over next word and continue

	* in other words, word after 'if' no longer has to be a jump, but if it is
	  a jump, code will continue to work as it always has

* add bit level operations -- limit to 32 bits
	* add random number generator

* the L0,L1, etc should become:
	: L3 LP 3 + ref ;
	: L3! LP 3 + set! ;

* add open-input-file, open-output-file, open-string, read-line, read-char, 
write-string, write-char ... basically I/O with ports concept like scheme

* pick should be 0-based for consistency with other 0-indexed functions
	* I think I should just add names S0, S0! S1 S1! etc to initlib instead

* add load or import word (in verbii if possible)

* more repl pieces in verbii

* need to extend ,,del (or maybe just get rid of 'del NAME' and always make del stack-based??)
  to delete entries from more objects:
	dict STRING ,,del ( delete a key from dictionary )
	SYMBOL ,,del ( delete a word )
	list INDEX ,,del ( delete entry from list )

* make sure { .. } :: obj works -- right now just [ .. ] :: obj is accepted

* chicken needs backtraces

---[    Tests     ]------------------------------------------------------

* reorganize tests by category?
 
---[   Clean-up   ]------------------------------------------------------

* check all places (in all ports) where files are opened to make sure any errors are returned
  as verbii errors and don't crash the host language
  
* makeboot needs to compile files to a temp location and not replace existing files until ALL are recompiled.
	* avoid the crashes caused when e.g. init changes in way that is incompatible with existing compiler.verb.b 

* read-file should be file-read for consistency with file-exists?, etc.

* need a better way to find lib/ than hardcoding/assuming path in repls

* compiler should insert a 'return' at the end of words to rid of special cases in interpreter

* chicken: main interpreter loop -- use while instead of having to place recursive calls everywhere

* More error checking of input types in library/tests/demos

* make sure ports all implement the same builtins (c++ has more that are not in other ports right now)

* c++ reports (sometimes vastly) different # of tail calls with -stats than other ports

* in native.* the pop* functions should take a 'where' argument like chicken

* chicken: cleanout old comments

---[ Optimization ]------------------------------------------------------

* why do interpreters check for symbols last in main loop? symbols account for about 70-80% of
  code (going by boot/init/compiler .b files) so shouldn't they be checked first?

* repls are still doing too much work, even more with caching additions. need to push more
  of this to verbii code. maybe interpreter:run should have a safe_run wrapper to handle
  a lot of this that could be called from verbii (??)
	* in progress - only c# remains to be done
	* once stable, switch repls to the minimized frontends

* compiler.verb -- in byte-compile, all words for __main__ get pushed to stack and then
  a huge list made at the end. this leads to stack overflows for large files (like the unittests
  where everything is in __main__). would be better to add items in chunks (maybe do an append
  every N words, for example)  so compilation won't overflow the stack. for now i just bumped up the
  stack size in all ports.

* I think the native make-word should be renamed to something like set-word and 
  make-word should be implemented in verbii and perform optimizations at creation time
  examples:
	* convert jumps into offsets so no searching is required at runtime

	* convert words into indexes so they can be called without lookup at runtime
		* WORDS in interpreter would then be a list

	* add syntax like:
		: name @args [ a b c ] @vars [ d e f ]
		where:
			* a, b, c are pulled from the stack into locals
			* d, e, f are added to locals, undefined
			* names are created: a == 'LP i + ref', a! == 'LP i + set!'
			* compiler converts names into LP/ref/set! at compile time so no
			  overhead other than setting args up into locals
			* compiler emits cleanup code (LP + n LP!) before 'return'
				* need to add a return at end of all word lists for simplicity
	
	* try inlining small functions
		* the question would be should this be done recursively and to what depth?
			i.e. 
				: 3dup dup dup dup ;
				: 9dup 3dup 3dup 3dup ;

			should 9dup be expanded to the 3dups, then the 3dups expanded to dups,
			then the dups expanded to their lowest level form?

* improve exp by reducing x like dividing by 100,1000,1e6,etc. and adjusting
  at end since values for powers of 10 can be in a table (exp algorithm seems
  to have trouble with larger values)

	* i think i should add more math functions (sin,cos,log,exp,etc.) -- these
  are all basically 1-liners so isn't saving significant code space now to
  omit them.

	* math: gcd, sqrt
	
* the chicken argument dispatch to builtins is really slow ... rework

---[   Unsorted   ]------------------------------------------------------


