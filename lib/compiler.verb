(
	Verbii compiler, written in verbii
	
	Copyright (c) 2022 Frank McIngvale, see LICENSE

	*** Read bootstrap/READ-ME-BEFORE-RUNNING.txt before editing this code! ***
	***       Changing this file can easily break the entire system!        ***
)

\ **TODO** change this to use the stream interface

\ ** GENERAL NOTE ** I've converted these to v2 format, but did not rewrite them
\ to use named vars so they are mostly all stack oriented. will redo at a later step.

( --- reader interface, used by compiler, but may be generally useful
	usage:
		" ... " reader-open-string
		or
		filename reader-open-file

		then reader-next until it returns null
)

'READER-TEXT void make-var
'READER-TEXT-LEN void make-var
'READER-POS void make-var

( note - the reader-open-* functions discard any current input )

: reader-open-string ( string )
	string READER-TEXT!
	READER-TEXT length READER-TEXT-LEN!
	0 READER-POS!
	;

: reader-open-file ( filename )
	filename file-read reader-open-string
	;

\
\ general note for below: for consistency, when there is no return value due to EOF,
\ void is returned. although technically only a few places need to distinguish null from void,
\ using void throughout I think will be less confusing in the long run
\

\ get next char [string] from reader without advancing stream
: reader-peek-char ( -- char )
	IF READER-POS READER-TEXT-LEN >= THEN
		void \ return void on eof
	ELSE
		READER-TEXT READER-POS get \ return char on stack
	END
	;

\ get next char [string] from reader stream or void on eof
: reader-next-char ( -- char )
	IF READER-POS READER-TEXT-LEN >= THEN
		void \ return void on eof
	ELSE
		READER-TEXT READER-POS get \ return char on stack
		READER-POS 1 + READER-POS!
	END
	;
	
\ get next string of either all whitespace -OR- non-whitespace
: reader-next-chunk ( -- chunk )
		\ "reader-next-chunk" . CR
	@locals [ c ]
	"" chunk!
	\ see what next chunk starts with ...
	reader-peek-char c!
	IF c void? THEN
		void return
	ELIF c whitespace? THEN
		\ read whitespace chunk
		WHILE true DO
			reader-peek-char c!
			\ if next is non-whitespace or void, then end whitespace chunk and return
			IF c void? c whitespace? not or THEN
				chunk return
			\ else append char to chunk and continue
			ELSE
				chunk reader-next-char + chunk!
			END
		END
	\ else, read non-whitespace chunk
	ELSE
		WHILE true DO
			reader-peek-char c!
			\ if next is whitespace or void, then end whitespace chunk and return
			IF c void? c whitespace? or THEN
				chunk return
			\ else append char to chunk and continue
			ELSE
				chunk reader-next-char + chunk!
			END
		END
	END
	;
	
\ skip any whitespace from current position in reader input
: reader-skip-whitespace ( -- )
	@locals [ c ]
	WHILE true DO
		reader-peek-char c!
		IF c void? THEN return
		ELIF c ord 32 > THEN return \ non-whitespace is next char
		ELSE reader-next-char drop
		END
	END
	;
	
\ get next non-whitespace chunk from reader stream (as a symbol), or void on eof
: reader-next ( -- symbol )
	@locals [ c ]
	\ skip leading whitespace
	reader-skip-whitespace
	\ get next non-whitespace chunk
	"" symbol!
	WHILE true DO
		\ i want to preserve any whitespace after word [e.g. for string parsing], so peek first
		reader-peek-char c!
		IF c void? THEN >>return-chunk
		ELIF c ord 32 <= THEN >>return-chunk
		\ not whitespace/EOF, append char to chunk and continue
		ELSE symbol reader-next-char + symbol!
		END
	END
	
	@return-chunk
		\ "RETURN-NEXT RETURNS:" . symbol . CR
		IF symbol length 0 == THEN void return \ got no input, so treat as EOF
		ELSE symbol string->symbol return
		END
	;

\ same as reader-next but doesn't change input stream position
: reader-peek-next ( -- symbol ) 
	@locals [ pos sym ]
	READER-POS pos!
	reader-next sym!
	pos READER-POS!
	sym
	;
	
\ is single char (string|symbol) a digit?
: digit? ( char -- result )
	IF char string? THEN char "0" >= char "9" <= and return
	ELIF char symbol? THEN char '0 >= char '9 <= and return
	ELSE "digit? requires string or symbol but got:" char str + error
	END
	;

\ does string|symbol contain ANY digits?
: any-digits? ( string-or-symbol -- result )
	string-or-symbol { digit? } any?
	;

\ if char is at start of string, remove it
: ltrim-char ( string char -- string )
	IF string 0 get char == THEN
		string 1 -1 slice
	ELSE
		string
	END
	;

\ remove "+" or "-" from start of string (max 1 removal)
: ltrim-sign ( string -- string )
	IF string 0 get "+" == string 0 get "-" == or THEN
		string 1 -1 slice
	ELSE
		string
	END
	;

\ remove all leftmost digits from string
: ltrim-digits ( string -- string )
	WHILE string length 0 > DO
		IF string 0 get digit? not THEN string return \ no more digits on left side
		ELSE string 1 -1 slice string! \ remove first char (which is a digit) and continue
		END
	END
	string return \ empty string
	;

\ true|false if string can be parsed as integer (i.e. a call to parse-int would succeed)
: int-string? ( string -- result )
	IF string any-digits? not THEN false return \ no digits in string, so cannot be an int
	ELSE
		string ltrim-sign
			ltrim-digits \ chain operations
			length 0 == return \ if removing +/- then digits yields an empty string, then it is an integer
	END
	;

\ like above but for symbols
: int-symbol? ( sym )
	sym str int-string?
	;

\ true|false if string can be parsed as float (i.e. a call to parse-float would succeed)
: float-string? ( string -- result )
	\ NOTE - this will ALSO match integers, so use int-string? first to rule those out
	IF string any-digits? not THEN false return \ must have digits, not just +/-/./e
	ELSE
		\ remove expected portions then see if i end up with an empty string
		string ltrim-sign
			ltrim-digits
			"." ltrim-char
			ltrim-digits
			"e" ltrim-char
			"E" ltrim-char
			ltrim-sign
			ltrim-digits
			length 0 == return
	END
	;
	
\ as above but for symbols ... caller could also just unconditionally call 'str' on
\ the argument before passing it
: float-symbol? 
	str float-string?
	;
	
\ =========================================================================
\ Parsing & printing of hex values (these were originally in numeric.verb
\ but are needed in the compiler now.
\ =========================================================================

\ convert char h from hex to int
: hex-char-to-int ( h -- i )
	h "0" >= 
	h "9" <=
	and if >>digit 

	h "a" >=
	h "h" <=
	and if >>hexlower 

	h "A" >= 
	h "H" <=
	and if >>hexupper

	"Bad hex digit: " h + error

	@digit h ord "0" ord - return
	@hexlower h ord "a" ord - 10 + return
	@hexupper h ord "A" ord - 10 + return
	;

\ parse hex string to integer -- hex must NOT have leading "0x"; ONLY hex digits
: parse-hex ( hex -- i )
	\ fold
	hex
	{ ( accum h ) 
		h hex-char-to-int 
		accum 16 * + 
	} 0 fold
	;

\ 4-bit value to hex digit
\ ( n -- h )
: int4-to-hex 
	dup 9 <= if >>digit 
	dup 16 < if >>hex 
	"Bad value in int4-to-hex:" swap str + error

	@digit "0" ord + chr return
	@hex 10 - "a" ord + chr
	;

\ 8-bit value to 2 hex digits )
\ ( n -- h )
: int8-to-hex 
	16 /mod int4-to-hex swap int4-to-hex +
	;

\ 16-bit value to 4 hex digits
\ ( n -- h )
: int16-to-hex
	256 /mod int8-to-hex swap int8-to-hex +
	;

\ 32-bit value to 8 hex digits )
\ ( n -- h )
: int32-to-hex
	65536 /mod int16-to-hex swap int16-to-hex +
	;

\ shortcut - int to hex string
\ - always unsigned
\ - does NOT prepend "0x", only returns the hex digits
\
\ ( val -- hexstring )
: str.hex int32-to-hex ;

\ parse binary string to integer -- must NOT have any prefix, only "0" and "1" digits
: parse-binary ( binstr -- i )
	\ fold
	binstr
	{ ( accum b ) 
		IF b "0" == THEN
			accum 1 bit-shl
		ELIF b "1" == THEN
			accum 1 bit-shl 1 bit-or
		\ allow dots to break digits into groups
		ELIF b "." == THEN
			accum \ skip
		ELSE "Bad binary digit: " b + error 
		END
	} 0 fold
	;
	
( make literal """ which cannot be written directly as source )

'TRIPLEQUOTE 34 34 34 3 make-symbol make-var

\ parse next word from input into runnable object
: syntax-next ( -- obj )
	@locals [ word ]
	reader-next word!
		\ "syntax-next word:" . word . CR
	IF word void? THEN void return
	ELIF word '( == THEN \ ) <- to fix syntax highlighting here
		syntax-comment syntax-next return \ skip comment and return NEXT object
	ELIF word '\ == THEN
		syntax-line-comment syntax-next return \ skip comment and return NEXT object
	ELIF word '{ == THEN
		syntax-v2-closure return
	ELIF word '[ == THEN
		syntax-list return
	ELIF word '#op( == THEN \ )
		syntax-opcode return
	ELIF word ': == THEN
		v2-syntax-define-word return
	ELIF word 'del == THEN
		syntax-del return
	ELIF word 'true == THEN 
		true return
	ELIF word 'false == THEN
		false return
	ELIF word 'null == THEN
		null return
	ELIF word 'WHILE == THEN
		syntax-while return
	ELIF word 'IF == THEN
		syntax-if return
	( look for triple-quoted string first )
	ELIF word 0 3 slice TRIPLEQUOTE == THEN
		\ "GOT TRIPLEQUOTE START:" . word . CR
		\ call syntax-triple-string with first piece on stack
		word syntax-triple-string return
	( now single quoted string )
	ELIF word 0 get '" == THEN \ "... <- fix syntax highlighting here
		( call syntax-string with first piece on stack )
		word syntax-string return
	\ test for correct format before passing to parse-int or parse-float since those functions
	\ may (depending on platform) happily parse something like "123abc" as 123 
	ELIF word int-symbol? THEN
		word parse-int return
	ELIF word float-symbol? THEN
		word parse-float return
	\ literals:
	\	#NN.NNN -> float
	\	#xNNNNN -> hex
	\	#bNNNNN -> binary (TODO)
	ELIF word 0 get '# == THEN
		IF word 1 -1 slice float-symbol? THEN
			word 1 -1 slice parse-float return
		ELIF word 1 get 'x == THEN
			word 2 -1 slice str parse-hex return
		ELIF word 1 get 'b == THEN
			word 2 -1 slice str parse-binary return
		ELSE
			"Unknown literal: " word str + error
		END
	ELSE
		\ "RET PLAIN WORD:" . word . CR
		\ no match, return unprocessed word
		word return
	END
	; 

\ TODO -- this could be used when parsing other things like lists, lambdas, etc.
\
\ parse reader stream into a list until any of the given symbols are found (upon return, symbol will have been read)
\
\ returns parsed list
: syntax-collect-until-any-symbol ( symbols -- list stop-symbol )
	@locals [ obj ]
	[ ] list!
	WHILE true DO
		syntax-next obj!
		IF obj void? THEN
			"End of input looking for: " symbols str + error
		ELIF symbols obj contains? THEN
			\ return ( list stop-symbol )
			list obj return
		ELSE
			\ else append to list and continue
			IF obj is-inline-list? THEN
				\ got [ ,,inline elem ... ] -- add elements inline instead of appending as a list 
				\ remove ,,inline 
				list obj 1 -1 slice extend!
			ELSE
				list obj append!
			END
		END
	END	
	;

\ simplification of above when looking for only one symbol (so don't need stop-symbol)
: syntax-collect-until-symbol ( symbol -- list )
	symbol 1 make-list syntax-collect-until-any-symbol drop
	;

'NEXT-UNIQUE-SYMBOL-NUMBER 0 make-var

: make-unique-symbol ( -- nr )
	NEXT-UNIQUE-SYMBOL-NUMBER 1 + NEXT-UNIQUE-SYMBOL-NUMBER!
	'auto-symbol- NEXT-UNIQUE-SYMBOL-NUMBER str string->symbol +
	;
	
\ parses:
\	WHILE cond-words ... DO do-words ... END
\
\ .. and converts into primitive instructions.
\
\ Assumes WHILE was just read.
: syntax-while ( -- code )
	@locals [ obj cond-list do-list label-start label-done ]
	\ read: cond-list ... DO 
	'DO syntax-collect-until-symbol cond-list!
	\ read: do-words ... END
	'END syntax-collect-until-symbol do-list!
	
	\ now rewrite pieces into a normal if loop and put in an inline list
	',,inline 1 make-list code!
	\ make unique labels
	make-unique-symbol label-start!
	make-unique-symbol label-done!
	\ make code:
	\ 	@start-label
	\ 		cond ... not if >>done-label
	\		do-list ... <<start-label
	\	@done-label
	code '@ label-start + append!
	code cond-list extend!
	code 'not 'if '>> label-done + 3 make-list extend!
	code do-list extend!
	code '<< label-start + '@ label-done + 2 make-list extend!
	\ return code
	code return
	;
	
\ parses: IF test1 ... THEN do1 ...
\		  ELIF test2 ... THEN do2 ...
\		  ELSE do3 ... 
\		  END
: syntax-if ( -- code )
	@locals [ test-list do-list pairs stop ]
	[ ] pairs!
	\ read all pairs of test:do 
	@loop
		\ read: test ... THEN
		'THEN syntax-collect-until-symbol test-list!
	@read-do
		\ read: do ... [ELIF | ELSE | END]
		[ ELIF ELSE END ] syntax-collect-until-any-symbol stop! do-list!
		\ add [ test-list do-list ] to pairs
		pairs test-list do-list 2 make-list append!
		\ see which stop symbol i received and decide what to do
		'ELIF stop == if >>got-elif 
		'ELSE stop == if >>got-else 
		'END stop == if >>got-end
		"Expecting [ELIF | ELSE | END], got: " stop str + error 
	@got-elif 
		\ make sure i didn't get another ELIF after an ELSE
		test-list null? if >>bad-elif 
		\ ready to read next test ... THEN ... do ...
		<<loop
	@got-else
		\ make sure i didn't get another ELSE after the last one 
		test-list null? if >>bad-else 
		\ NO test, just need to read the do ... clause
		null test-list! 
		<<read-do 
	@bad-elif "Syntax error: Got ELIF after ELSE" error 
	@bad-else "Syntax error: Got ELSE after ELSE" error 
	@got-end
		@locals [ label-end label-next ]
		\ "PARSED 'IF' SYNTAX:" . pairs . CR
		\ create code as inline-list
		',,inline 1 make-list code!
		\ make a label to jump to after successful matching and running of a do .. clause
		make-unique-symbol label-end!
		\ loop over all [ test do ] pairs
		pairs
		{ ( test-list do-list )
			test-list null? if >>make-else \ if test is null, then its the ELSE clause 
			\ normal case -- make a label to jump to when test is false to run next case
			make-unique-symbol label-next!
			\ write test + if into code
			code test-list extend [ not if ] extend '>> label-next + append
			\ write do ... into code then jump to END
			do-list extend '>> label-end + append
			\ write label-next that the above jumps to for running next case
			'@ label-next + append!
			\ ... and continue with next pair 
			return
			
			@make-else
			\ pair is the ELSE clause; no test, just write the do .. 
			code do-list extend!
			\ no need to write a jump -- just fall through to label-end
		} apply-for-each
			
		\ finally add the end label that all of the above clauses jump to when done 
		code '@ label-end + append!
		
		\ "CREATED CODE:" . code . CR
		code
	;
	
\ assumes @( was just read, parses until ) as an object list, prepended with ,,declargs
: syntax-parse-decl-arglist ( -- outlist )
	@locals [ obj ]
	',,declargs 1 make-list outlist!
	WHILE true DO
		syntax-next obj!
		IF obj void? THEN "End of input inside @(" error
		ELIF obj ') == THEN outlist return
		ELSE
			\ else append object and continue
			outlist obj append!
		END
	END
	;
	
\ is obj a list like: [ ,,inline ... ]
: is-inline-list? ( obj -- result )
	IF obj list? THEN
		IF obj length 0 > THEN
			obj 0 get ',,inline == return
		END
	END
	false
	;
	
\ assumes ':' was just read
\
\ TODO --- there should be a common routine to parse functions & lambdas since they
\ are so similar ... 
\	: name ( args ) STUFF ... ;
\ vs
\	{ ( args ) STUFF ... }
: v2-syntax-define-word
	@locals [ SP-start name outlist ]
		\ "define word" . CR
	syntax-next ( name must be next )
	dup symbol? not if >>badname
	name!
	
	\ now this is syntax-v2-closure
	[ ] outlist!
	
	\ see if there is a ( .. ) next -- if so treat it as declargs
	reader-peek-next '( == if >>read-arglist \ )
	>>loop \ no arglist, peeked symbol will be read again below
	
	@read-arglist
	\ read ( ... ) as arglist
	reader-next drop \ read the ( now \ )
	syntax-parse-decl-arglist 
	outlist swap append outlist! \ fall through to loop
		\ "AFTER ARGLIST:" . outlist . CR
	
	@loop
		syntax-next
		dup void? if >>eof
		\ just ; instead of } like in syntax-v2-closure
		dup '; == if >>done
		dup is-inline-list? if >>inline-list
		\ else append object and continue
		outlist swap append outlist! <<loop
	@eof
		drop "End of input inside : ... ;" error
	@badname
		"Expecting symbol after ':' but got: " swap repr + error
	@inline-list ( inline-list )
		\ got [ ,,inline elem .. ] where elements should be inlined instead of appended as a list
		\ remove ,,inline and extend list
		1 -1 slice outlist swap extend drop <<loop
	@done
		drop \ drop '}
		
	@finish
		( save names & compiled words )
		outlist name save-defined-word
		syntax-next ( save-defined-word has no return value, so return NEXT object )
	;
	
\ del NAME -- 'del' was already read
: syntax-del
	syntax-next ( name must be next )
	dup symbol? not if >>badname
	'' swap + ( make quoted name )
	\ as with var, i need to return multiple words, so return 
	\ [ ,,inline name ,,del ]
	',,inline swap ( ,,inline name )
	',,del ( ,,inline name ,,del )
	3 make-list 
	return

	@badname str "Bad name in del: " swap + error
	;

\ assumes "#op(" was just read and dropped \ )
: syntax-opcode 
	@locals [ list s ]
	[ ] list!
	@loop ( list )
		\ everything inside the parens must be a literal so call 
		\ reader-next instead of syntax-next
		reader-next s!
		s void? if >>eof
		s ') == if >>closelist
		list s append list! ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside #op( .. )" error
	@closelist
		\ i parsed: #(op NAME A B C)
		\ check for errors
		list length 0 == if >>no-name 
		list length 4 > if >>too-long 
		\ A,B,C are allowed to be omitted - fill in zeroes
	@padlist 
		list length 4 == if >>make-opcode 
		list "0" append list! <<padlist
	@make-opcode
		\ put name on stack
		list 0 get 
		\ parse A,B,C as ints
		list 1 -1 slice { parse-int } map unmake drop 
		make-opcode \ make-opcode will check for errors as well
		return
	@no-name
		"Missing opcode name" error
	@too-long
		"#op( .. ) too long: " list str + error
		;
		
\ first string part already on stack *as symbol*
: syntax-string
	\ convert first since reader-next-char returns strings
	symbol->string
		
	( see if first string part ends with " )
	dup -1 get ord 34 == ( use ascii value for " )
		over length 1 >
		and
		if >>endstring ( first part begins and ends with " so string is complete )

	( now switch to character mode to preserve all inner whitespace )
	@loop ( string )
		reader-next-char ( string char )
		dup void? if >>eof ( EOF in string, error )
		dup ord 34 == if >>quote ( test against ASCII value for " to avoid any parsing weirdness )
		( else, append regular char to string )
		+ <<loop
		
	@quote ( string " )
		+ ( append " to string )

		( if whitespace is next, then string is complete )
		reader-peek-char
		dup void? if >>endquote ( EOF ok AFTER end quote )
		dup whitespace? if >>endquote
		( else, keep reading more )
		drop <<loop

	@endquote drop >>endstring

	@eof ( string char ) 
		drop "Unexpected end of input inside string: " swap + error

	@endstring ( string -- string without quotes )
		dup length 2 - 1 swap slice ( remove quotes )
	;
	

\ ( first-piece-symbol -- string )
: syntax-triple-string ( piece -- out )
	@locals [ chunk ]
		\ "SYNTAX-TRIPLE-STRING - INIT:" . piece . CR
	\ convert to string first ...
	piece symbol->string piece!
	\ special case of only one piece ... """..."""
	IF 	piece length 6 >=
		piece -3 -1 slice TRIPLEQUOTE symbol->string == and THEN
		\ "\ GOT SINGLE CHUNK" . CR
		>>return
	END
	\ else, add chunks until i find one that ends in """
	WHILE true DO
		reader-next-chunk chunk!
			\ "GOT NEXT CHUNK:" . chunk . CR
		IF chunk void? THEN
			"String ended inside triple-quoted string: " piece str + error
		ELSE
			piece chunk + piece!
		END
		\ does piece end with """ now?
		IF piece -3 -1 slice TRIPLEQUOTE symbol->string == THEN
			>>return
		END
	END
	
	@return ( remove triple quotes from both sides )
		piece piece length 3 swap 6 - slice
	;
	
\ assumes [ was just read & dropped
: syntax-list ( -- list )
	@locals [ obj ]
	0 make-list list!
	WHILE true DO
		\ note - any inner lists/lambdas will be handled automatically by syntax-next,
		\ so don't have to check for { or [ here
		syntax-next obj!
		IF obj void? THEN "Unexpected end of input inside [ .. ]" error
		ELIF obj '] == THEN list return 
		ELIF obj is-inline-list? THEN
			\ got [ ,,inline elem ... ] -- add elements inline instead of appending as a list 
			\ remove ,,inline 
			list obj 1 -1 slice extend!
		ELSE
			\ anything else, append to list and continue
			list obj append!
		END
	END
	;
		
\ parse ( ... ) comment, with nesting. assumes "(" was just read.
: syntax-comment
	@locals [ nesting comment-text ]
	"" comment-text!
	1 nesting!
	@loop
		reader-next ( puts symbol on stack )
		dup void? if >>eof
		( add to comment text )
		dup symbol->string comment-text " " + swap + comment-text! 

		dup ') == if >>closeparen
		dup '( == if >>openparen \ ) <- to stop notepad++ highlighter from messing up
		drop <<loop ( discard and continue )
	@closeparen
		nesting 1 - nesting!
		nesting 0 == if >>end
		drop <<loop
	@openparen
		nesting 1 + nesting!
		drop <<loop
	@end
		drop return
	@eof
		comment-text 0 40 slice
		"Unexpected end of input inside comment: " swap + error
	;
	
\ assumes "\" was just read
: syntax-line-comment 
	\ read *characters* until EOL found
	@loop
		reader-next-char
		( if end of stream, "\n" or "\r", then i'm done )
		dup void? if >>eol
		dup ord 13 == if >>eol
		dup ord 10 == if >>eol
		drop <<loop ( discard char and continue )
	@eol
		drop ( discard char and return )
	;

\ parses { .. } into a lambda (will potentially be converted to a closure (bound-lambda)
\ during finalization)
\
\ assumes { was just read, parses until } as an object list
: syntax-v2-closure
	@locals [ outlist ]
	[ ] outlist!
	
	\ see if there is a ( .. ) next -- if so treat it as declargs
	reader-peek-next '( == if >>read-arglist \ )
	>>loop \ no arglist, peeked symbol will be read again below
	
	@read-arglist
	\ read ( ... ) as arglist
	reader-next drop \ read the ( now \ )
	syntax-parse-decl-arglist 
	outlist swap append outlist! \ fall through to loop
	
	@loop
		syntax-next
		dup void? if >>eof
		dup '} == if >>done
		dup is-inline-list? if >>inline-list
		\ else append object and continue
		outlist swap append outlist! <<loop
	@eof
		drop "End of input inside { .. }" error
	@inline-list
		\ got [ ,,inline elem .. ] -- elements should be added inline instead of appending as list
		\ remove ,,inline
		1 -1 slice outlist swap extend drop <<loop
	@done
		drop \ drop '}
		outlist make-lambda
	;
	
\ string -- string with whitespace escaped
: serialize-escape-string
	{ 
		\ ( char )
		dup ord 32 == if >>space
		dup ord 37 == if >>percent
		dup ord 9 == if >>tab
		dup ord 10 == if >>lf 
		dup ord 13 == if >>cr 
		\ not a special char - return as-is
		return

		\ note -- "%" cannot appear in the strings here nor the serialize/deserialize
		\ loop - would mess up the replacement strings. so use % == chr(37) instead of "%" )
		@space ( char )
			drop 37 chr "32" + ( "%32" )
			return

		@tab ( char )
			drop 37 chr "09" + ( "%09" )
			return

		@percent ( char )
			drop 37 chr "37" + ( "%37" )
			return
			
		@lf ( char )
			drop 37 chr "10" + ( "%10" )
			return
		@cr 
			drop 37 chr "13" + ( "%13" )
	} map
	;

\ general note: the following is NOT intended to be a general-purpose serialization format.
\ 				its only purpose is to be able to serialize byte-compiled verbii source.
\				primarily it is for compiler.verb/init.verb/boot.verb, but is general enough to
\				serialize any verbii source file.
\
\				as a consequence, there is no need to serialize anything that cannot exist
\				in source form. this includes:
\					* void - no source format (void is a word)
\					* bound-lambda - no source format - requires binding at runtime
\					* dict - no source format - requires make-dict or ,,new-dict at runtime
\
\				technically floats are not needed in compiler.verb nor init.verb, however,
\				to allow this to be used for ANY verbii source (i.e. to cache compilations)
\				they are allowed here.

\ ( obj -- ; serialize obj to stdout )
: serialize-object 
	dup int? if >>int
	dup float? if >>float
	dup string? if >>string
	dup symbol? if >>symbol
	dup list? if >>list
	dup lambda? if >>lambda
	dup bool? if >>bool
	dup null? if >>null
	dup opcode? if >>opcode
	repr "Unknown obj in serialize-object:" swap + error
	@int ( i NNN )
		"i" . str puts CR return
	@float ( f NN.NNN )
		"f" . str puts CR return
	@bool ( b true|false )
		"b" . str puts CR return
	@null ( n )
		drop "n" . CR return
	@string ( s SSS )
		"s" . serialize-escape-string puts CR return
	@symbol ( y SSS - symbols cannot contains spaces, \n, etc. so no escaping needed )
		"y" . str puts CR return
	@list ( "L length" then serialized items )
		"L" . dup length str puts CR
		{ serialize-object } for-each ( items )
		return
	@lambda ( "F" then list serialized )
		"F" puts CR
		unmake serialize-object ( serialize list )
		return
	@opcode ( "o" then packed value )
		"o" . opcode-packed str puts CR return
		;

\ ( list name )
: save-defined-word
	swap 2 make-list ( [ name list ] )
	COMPILED-NAMELISTS swap append drop
	;

\ take a list: [ ,,declargs arg ... -- local ... ]
\ and return lists of [ arg ... ] and [ local ... ]
\
\ ( list -- args locals )
: compile-split-declargs
	@args [ list ]
	@locals [ i args locals parsing-locals ]
	[ ] args!
	[ ] locals!
	false parsing-locals! \ have i seen the '--' ?
	1 i! \ skip ,,declargs
	@loop
		i list length >= if >>done
		list i get '-- == if >>got-dashes 
		\ else add to either args or locals list
		parsing-locals if >>add-to-locals
		args list i get append args! >>next \ add to args
	@add-to-locals ( obj )
		locals list i get append locals! >>next \ add to locals 
	@got-dashes
		true parsing-locals! \ switch to parsing locals, fall through to next
	@next
		i 1 + i! <<loop
	@done 
		args locals
		;
		
\ takes a compiled objlist and collects:
\	[ ,,declargs arg .. -- local .. ] => args & locals
\		(the compiler generates this from @( arg ... -- local ... )
\	@args [ ... ] => args
\	@locals [ ... ] => locals
\
\ returns rewritten objlist with the @args & @locals removed.
\
\ it is valid to have BOTH @( ... ) and @args/@locals -- the names will be
\ merged into a single args/locals lists
\
\ ( objlist -- new-objlist args locals )
: compile-collect-args-locals
	@args [ objlist ]
	@locals [ new-objlist args locals i ]
		\ "COMPILE COLLECT ARGS LOCALS:" . .S CR
		\ "	objlist:" . objlist str . CR
	[ ] new-objlist!
	[ ] args!
	[ ] locals!
	0 i!
	@loop
		objlist i get ( objlist[i] )
		dup void? if >>done \ i >= length
		dup list? if >>check-list
		dup '@args == if >>args-list 
		dup '@locals == if >>locals-list
		\ else regular obj, copy to new list
		>>keep-obj
	@check-list ( obj )
		\ see if this is [ ,,declargs ... ]
		dup length 0 == if >>keep-obj
		dup 0 get ',,declargs != if >>keep-obj
		\ it is ,,declargs, so split into args,locals
		compile-split-declargs ( args locals )
		locals swap + locals!  \ append locals & args to my lists 
		args swap + args! >>next
	@keep-obj ( list )
		new-objlist swap append new-objlist! >>next
	@args-list ( obj )
		drop
		\ just saw @args so a list must be next
		i 1 + i!
		objlist i get
		dup void? if >>missing-args \ end of input
		dup list? not if >>missing-args 
		\ add list to anything collected so far from @( .. )
		args swap + args! >>next
	@missing-args
		"Expecting list after @args in:" objlist str + error
	@locals-list ( obj )
		drop
		\ list must be next
		i 1 + i!
		objlist i get
		dup void? if >>missing-locals
		dup list? not if >>missing-locals
		\ add to any existing locals from @( .. )
		locals swap + locals! >>next 
	@missing-locals
		"Expecting list after @locals in:" objlist str + error
	@next
		i 1 + i! <<loop
	@done ( void )
		drop new-objlist args locals
		;
			
\ ===============================================
\ Closure environments
\ ===============================================
\ this defines a closure environment -- this is similar conceptually to a scheme environment.
\ it is used to take some of the work of rewriting variables into frame references out of the
\ rewriting routine so that it can be tested in isolation.
\
\ this is a compile-time environment only; at runtime only frames & indexes are used

\ closure environment:
\	[ TAG dict up ]
\
\	TAG = ,,closure-env (for type checking)
\	dict = maps names into local frame indexes (NAME, not NAME! -- NAME! handled internally)
\	up = next upward frame, or void if toplevel env
: new-closure-env ( -- env )
	',,closure-env	 	\ TAG
	[ ] make-dict		\ dict
	void				\ up
	3 make-list
	;

: closure-env? ( env -- result ) env 0 get ',,closure-env == ;	
: closure-env-dict ( env -- dict ) env 1 get ;
\ set the parent of env (i.e. its outer scope) so that name lookups	
\ can traverse up the parent tree
: closure-env-set-up ( env up -- ) env 2 up put drop ;
: closure-env-get-up ( env -- ) env 2 get ;

\ add a new name (symbol) to env, assigning it the next available index
: closure-env-add-name ( env name -- )
	\ type checking
	env closure-env? not if >>bad-env
	\ check if already defined
	env closure-env-dict name str get void? not if >>dup-name 
	\ add to dict
	env closure-env-dict name str env closure-env-dict length put drop return
	
	@dup-name "Duplicate name in args/locals: " name str + error
	@bad-env "Not a closure environment: " env str + error
	;

\ add a list of names at once
: closure-env-add-namelist ( env names -- )
	names
	{ ( name )
		env name closure-env-add-name
	} for-each
	;
	
\ lookup name in closure or in any outer scope
\
\ if found, returns ( level index ) where level is the scope level (local==0, first parent==1, etc.)
\ and index is the index into that frame
\
\ if NOT found, returns ( void void )
: closure-env-lookup-name ( env name -- level index )
	env name 0 closure-env-lookup-name-inner
	;
	
\ the inner loop, called recursively
: closure-env-lookup-name-inner ( env name level -- level index )
	@locals [ index up ]
	\ if name has ! at the end then remove it
	name -1 get '! != if >>lookup
	name 0 name length 1 - slice name! \ remove !
	
	@lookup
	env closure-env-dict name str get index! 
	index void? if >>try-up \ try next scope up
	\ found it, return ( level index )
	level index return
	
	@try-up
		env closure-env-get-up up!
		up void? if >>not-found \ no outer scope, so name not found
		\ recursively search upwards
		up name level 1 + closure-env-lookup-name-inner
		return
		
	@not-found
		void void
	;
	
\ make opcode to either set or get a var (based on whether name ends in "!")
: closure-env-make-ref-or-set ( name level index -- opcode )
	name -1 get '! == if >>set 
	\ make a get 
	'FRAME-GET level index 0 make-opcode return
	@set
	'FRAME-SET level index 0 make-opcode return
	;
	 
\ ===============================================

\ objlist can be from a lambda or list. pass plain-list=true if objlist is from a list; false if from a lambda.
\ (the difference being that plain lists are never bound to a frame since they are never called as code)
\
\ max-frame-level is the maximum frame level (from i.e. OP-FRAME-GET) that is required to resolve rewritten
\ references. so i.e. if max-level == 0, then the rewritten objlist only accesses its only locals and doesn't
\ need to be bound to an outer frame at runtime.
\
\ *NOTE* a value of -1 for max-frame-level means NOTHING was rewritten.
: v2-compile-rewrite-args-locals ( objlist outer-env plain-list -- new-objlist max-frame-level )
	@locals [ argnames localnames env i ]
			
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
		
		\ track max frame level required (set to -1 so i can tell later if i rewrote anything)
		-1 max-frame-level!
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ note: i don't have to reserve space for locals -- interpreter creates frame
		\ with sufficient space, so i only have to pop args into frame ...
		
		\ make code to push args to locals (add to new-objlist)
		\ (pop in reverse order of argnames, so range starts at (#argnames-1)
		{ ( i )
			new-objlist
				'FRAME-SET 0 i 0 make-opcode
				append drop
		} argnames length 1 - 				\ start index = #argnames-1
			-1 								\ count by -1
				argnames length for-count	\ for argnames args
		
		\ create an environment to resolve names 
		plain-list if >>make-env-plain-list
		
		\ make environment for new closure, chained to outer-env
		\ -- add args first since those are at lowest indexes
		new-closure-env env!
		\ add args first so they'll get assigned indexes starting at 0
		\ -- arg names are NOT allowed to repeat
		argnames
		{ ( name )
			env name closure-env-add-name
		} for-each

		\ env argnames closure-env-add-namelist
		
		\ now @locals -- these ARE allowed to duplicate names in arglist, in which
		\ case they are ignored
		\ WHY? it seems fairly common to have arglists like:
		\		( a b -- a )
		\ where the output a is a modified version of a, for example. there is no need
		\ for a second var in these kinds of cases, and allowing the duplicated names
		\ makes function signatures cleaner for a lot of common cases
		
		\ env localnames closure-env-add-namelist
		localnames
		{ ( name )
			env closure-env-dict name str get void? not if >>dup-name 
			env name closure-env-add-name
			@dup-name \ not an error, just ignored
		} for-each

		\ .. and chain to my outer scope
		env outer-env closure-env-set-up
		>>begin-rewrite
		
	@make-env-plain-list
		\ i'm rewriting a LIST, not code -- list will be flattened (see below) so will
		\ run IN the outer-env, not a new environment
		outer-env env!
		\ IMPORTANT! nothing below here is allowed to modify env since that would modify
		\ outer-env incorrectly
		
	@begin-rewrite
	\ rewrite symbols using environment just created
	0 i!
	@rewrite-loop
		\ i objlist length >= if >>done 
		
		objlist i get void? if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>rewrite-inner-plain-list
		objlist i get lambda? if >>rewrite-inner-lambda
		\ fall through for everyting else, copy as-is
	@copy-element
		\ subtlety here: if i'm working on a plain-list, then, if it contains ANY captures (or any in
		\ ANY nested list/lambda) then it will be flattened and then remade at runtime. this means that every element
		\ in the list will be evaluated -- what i WANT to happen is for everything to be pushed to the stack,
		\ and the only things that should really be evaluated are opcodes that pull values from my frame.
		\ however, i need to quote any symbols so they will be pushed as symbols instead of run. when they are
		\ seen, the outer quoting will be removed, so when make-list runs, they will end up back in the list as
		\ intended. even though I don't know HERE whether a list will be flattened or not,
		\ i can replace them unconditionally since if the list contains no captures, this list will never
		\ be used (see below as well e.g. @plain-list-no-rewrites)
		plain-list not if >>normal-copy-element
		objlist i get symbol? not if >>normal-copy-element
			\ it is a symbol in a plain list, so add a level of quoting
			new-objlist '' objlist i get + append new-objlist! >>next
		@normal-copy-element
			\ not a symbol or not in a plain-list, so just copy as is
			new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		@locals [ level index sym ]
		objlist i get sym!
		\ see if symbol is in my env or any outer scope
		env sym closure-env-lookup-name index! level!
		index void? if <<copy-element \ not in environment, so copy as is 
		\ turn symbol into get/set opcode (tied into the comments below, this never
		\ changes the size of the list -- the symbol & the opcode that replaces it
		\ are both single objects)
		new-objlist
			sym level index closure-env-make-ref-or-set
			append new-objlist!
		\ remember max level so i can tell at the end if I need to be bound to an outer frame
		max-frame-level level max max-frame-level!
		>>next 
		
	@rewrite-inner-lambda
		@locals [ sub-objlist sub-max-frame-level ]
		\ call rewrite recursively with my env as the outer scope
		objlist i get unmake \ get lambda as list to pass
		env false v2-compile-rewrite-args-locals sub-max-frame-level! sub-objlist!
		\ turn new sub-objlist back into lambda now that its rewritten and add to new-objlist
		new-objlist
			sub-objlist make-lambda append new-objlist!
		\ does rewritten code require any vars from my (or higher) frames? 
		sub-max-frame-level 0 <= if >>done-rewrite-sub \ max level == 0 means it only needs its locals (-1 means it needs NO vars)
		\ this lambda requires values from my (or higher) frames, so needs to be bound to my
		\ runtime frame ...
		new-objlist 'bind-lambda append new-objlist!
		
	@done-rewrite-sub
		\ several subtleties here -- i might never use any values from a higher frame, but have a sub-lambda that does so,
		\ so i need to take sub-max-frame into account. NOTE -- since i am 1 level up, i subtract 1 from sub-max-level 
		\ (i.e. a sub-lambda requiring a value 2 frames up is only 1 frame up for me, so should be counted that way ... 
		\ so if sub-max is 1 for example, *I* do not need to be bound to an outer frame since those are my locals.
		\
		\ HOWEVER, once the level is >= 0, NEVER decrease it below 0 since that would then be mistaken for meaning nothing was
		\ rewritten -- in the case of lists, that would mean the original lists are deepcopied instead of the replacement
		\ list being used, so lambdas inside a list would never be transformed correctly.
		\
		\ note that this does not harm the optimization at all, since level=0 means only locals are used, so this does not
		\ cause any lambdas to be bound unnecessarily.
		IF sub-max-frame-level 0 > THEN
			max-frame-level sub-max-frame-level 1 - max max-frame-level!
		ELSE
			max-frame-level sub-max-frame-level max max-frame-level!
		END
		>>next
		
	@rewrite-inner-plain-list
		@locals [ list-length ]
		\ rewrite vars inside a list without binding frame to it at runtime (since the list will
		\ be expanded, it will be filled from MY frame) -- also see code at beginning that
		\ knows not to create a new env for plain lists
		
		\ remember ORIGINAL length of list i'm about to rewrite. after rewriting i could have something like:
		\	BEFORE: [ a b [ c d [ e f ] ] ]
		\	AFTER: a b c d e f 2 make-list 3 make-list 3 make-list
		\ in other words, the inner lists have been flattened so the literal length is longer, but the
		\ RUNTIME length (i.e. for make-list) is the same -- rewriting is a 1-to-1 replacement of varnames
		\ with a single opcode, so the final RUNTIME length will be the same.
		objlist i get length list-length!
		\ rewrite list
		objlist i get env true v2-compile-rewrite-args-locals sub-max-frame-level! sub-objlist!
		\ did I rewrite anything?
		sub-max-frame-level 0 < if >>plain-list-no-rewrites
		\ else, the rewrites occurred in MY ENV so flatten list so runtime references are correct
		new-objlist
			sub-objlist extend \ flatten sub-objlist into new-objlist
			\ add code to remake list at runtime -- see notes above on the length passed to make-list
			list-length append 'make-list append new-objlist!
		\ like above, i need to account for sub-max-frame-level in my max-frame-level.
		\ *UNLIKE* above, the rewrites occurred in MY frame, so I do NOT subtract 1 as i did above
		max-frame-level sub-max-frame-level max max-frame-level!
		>>next 
		
	@plain-list-no-rewrites
		\ nothing rewritten, so leave list as-is and it can be instantiated by deepcopy at runtime
		new-objlist objlist i get append new-objlist!
		
		>>next \ just to be clear ...
		
	@next
		i 1 + i! <<rewrite-loop
		
	@done
		new-objlist max-frame-level return	
		;
		
\ starting at objlist[index], look for @label, with index += increment at each step.
\ returns offsets if found, null if not. note that label must be a symbol.
: compiler-find-label ( objlist label index increment -- offset )
	\ "FIND LABEL:" . label repr . CR
	@locals [ i ]
	index i!
	@loop
		objlist i get void? if >>notfound \ went past start/end of objlist 
		\ objlist[i] == @label?
		objlist i get '@ label + == if >>found 
		i increment + i! <<loop
	@found
		\ return offset
		i index - return
	@notfound
		null return
	;
	
\ recursively rewrite objlist to change "<<" and ">>" jumps into opcodes
: compiler-optimize-jumps ( objlist -- objlist )
	@locals [ i newlist obj offset ]
	0 i!
	[ ] newlist!
	@loop
		objlist i get obj! \ get next obj
		obj void? if >>done
		obj symbol? if >>symbol
		obj list? if >>list
		obj lambda? if >>lambda
		\ fall through - copy anything else to newlist
	@copy-element
		newlist obj append drop 
	@next
		i 1 + i! <<loop
	@symbol
		\ see if symbol starts with << or >>
		obj 0 2 slice '<< == if >>backward-jump 
		obj 0 2 slice '>> == if >>forward-jump 
		\ not a jump, so just copy
		<<copy-element
	@backward-jump
		\ find offset to label for jump
		objlist obj 2 -1 slice i -1 compiler-find-label offset!
		offset null? if >>missing-label 
		\ add jump opcode
		\
		\ at runtime, the codepos will point to AFTER the jump, so the real offset
		\ to the label is (offset-1), however, i don't want to jump to the label, since
		\ that would waste time to interpret the label, so jump 1 after it, so that will
		\ be (offset-1+1), so using just the offset is correct. note i pass -offset since it is JUMP-BACK
		newlist 'JUMP-BACK 0 0 offset neg make-opcode append drop <<next
	@forward-jump
		\ like above, but find forward jump
		objlist obj 2 -1 slice i 1 compiler-find-label offset!
		offset null? if >>missing-label 
		\ add jump opcode
		\
		\ similar to above, codepos will point to AFTER the jump, so instead of
		\ offset, i really want (offset-1). but i don't want to jump to the label, i want
		\ to jump to the instruction after the label, so (offset-1+1) which again is just offset
		newlist 'JUMP-FORW 0 0 offset make-opcode append drop <<next
	@list
		\ recursively process list and append result
		newlist obj compiler-optimize-jumps append drop <<next
	@lambda
		\ like above but do via lambda->list->lambda
		newlist obj unmake compiler-optimize-jumps make-lambda append drop <<next
	@missing-label
		"Cannot find label for jump: " obj str + error
	@done
		newlist \ return rewritten list
	;
	
\ take a parsed objlist, presumably from byte-compile, and perform finalization:
\	* transform @args [ .. ] and @locals [ .. ] into code and handles closure creation
\
\ returns a new list, does NOT modify objlist
: compile-finalize-word ( objlist -- newlist )
	\ always a toplevel function - no outer environment
	objlist void false v2-compile-rewrite-args-locals
	drop \ don't need max-frame-level here; top level functions cannot have outer frames by definition
	\ now that all the rewriting above is done, can replace << and >> with jump opcodes
	compiler-optimize-jumps
	return \ return new objlist
	;
	
'COMPILED-NAMELISTS void make-var

\ *TODO* this REALLY needs to be rewritten with named args for clarity ...

\ take the parsed COMPILED-NAMELISTS and perform finalization on the words.
\ see compiled-finalize-wprd for details. saves finalized lists back to COMPILED-NAMELISTS
\
\ ( -- )
: compiler-finalize-all-words
		\ "FINALIZE ALL WORDS" . CR
	0
	@loop ( i )
		dup COMPILED-NAMELISTS length >= ( i >= #lists ) if >>done 
		COMPILED-NAMELISTS over get ( i lists[i] )
		1 get ( i objlist )
		compile-finalize-word ( i new-objlist )
		over COMPILED-NAMELISTS swap get ( i newlist LISTS[i] )
		1 rot put drop ( i )
		1 + <<loop ( ++i )
	@done
		drop
	;
	
\ byte-compile source from current reader stream
: byte-compile ( -- names wordlists )
	\ do NOT store compiled words into interpreter since that would prevent compiling
	\  any code that contained a name that was already defined -- for example when
	\  compiling this file
	\
	\ instead, store as a list of [name,wordlist] to COMPILED-NAMELISTS
	0 make-list COMPILED-NAMELISTS!
	
	\ objects that do NOT go into a word definition are put into MAINLIST and become __main__
	@locals [ MAINLIST ]
	[ ] MAINLIST!

	@loop
	\ parse all of input stream -- this will either put new words into COMPILED-NAMELISTS
	\ OR will leave objects on stack
	syntax-next
	dup void? if >>done 
	dup is-inline-list? if >>inline-list
	\ any other objects go into MAINLIST
	MAINLIST swap append MAINLIST!
	<<loop
	@inline-list ( inline-list )
		\ got [ ,,inline elem .. ] -- elements should be inlined instead of appended as a list
		\ remove ,,inline and splice in elements
		1 -1 slice MAINLIST swap extend drop 
		<<loop
	@done ( void )
	drop
	( save MAINLIST as __main__ )
	MAINLIST '__main__ save-defined-word
	( perform finalization of all words )
	compiler-finalize-all-words
	( leave list of [ name list ] on stack )
	COMPILED-NAMELISTS
	;

\ leaves list of [ name list ] on stack
: byte-compile-file ( filename -- output-list )
	filename reader-open-file byte-compile
	;

\ leaves list of [ name list ] on stack
: byte-compile-string ( text -- output-list )
	text reader-open-string byte-compile
	;

\ takes list of [ name list ]
: serialize-compiled-output
	\ take output of byte-compile-* and serialize to stdout

	( each obj is [ name wordlist ] )
	{ "W" . dup 0 get str puts CR 1 get serialize-object } for-each 
	;

\ compiles filename and writes serialized form to stdout. does NOT alter interpreter words
: compile-and-serialize ( filename -- )
	filename byte-compile-file ( this will be all code other than word definitions )

	( that left list of [ name list ] on stack )

	\ write metadata -- packed on 1 line for ease of parsing later
	\ version 1: M v1: FNVHASH, where FNVHASH is integer fnv-1a-32 hash of input file
	\ (careful to pack this so there is NO extra space before/after the number, since that
	\ breaks int parsing on some host languages)
	"M v1:" puts filename file-read fnv-1a-32 str puts CR \ fnv hash of input file as integer
		
	( this will all be written to a list )
	"L" . dup length str puts CR

	( serialize )
	serialize-compiled-output
	;
	
\ compiles string and loads words into current interpreter
\
\ *NOTE* caller must delete __main__ before trying to load additional code
\ 		e.g.: '__main__ ,,del
: compile-and-load-string ( string -- )
	string byte-compile-string
	( now load the [ name wordlist ] pairs into interpreter )
	{ dup 1 get swap 0 get make-word } for-each
	;

\ test if filename.b needs to be (re)generated
: check-needs-recompile ( filename )
	@locals [ text ]
	\ see if filename.b exists
	filename ".b" + file-exists? not if >>need-compile 
	\ read .b file and check metadata
	filename ".b" + stream-reader-open-file
	stream-reader-next-line text! drop \ drop stream
	text 0 5 slice "M v1:" != if >>need-compile \ missing metadata or older version; force recompile
	\ check fnv hash
	text 5 -1 slice parse-int 
		filename file-read fnv-1a-32 != if >>need-compile \ hash doesn't match; force recompile 
		
	\ else, .b file is up to date
		\ filename ".b" + " is up to date" + puts-stderr
	false return
	@need-compile 
		\ filename ".b" + " needs to be (re)compiled" + puts-stderr
		true
	;
	
\
\ compile & load the given file. if "filename.b" exists, and filename hasn't changed (based on
\ metadata embedded in filename.b), then it is loaded instead of recompiling filename.
\
\ if "filename.b" does not exist, or filename has changed, then filename is compiled and the 
\ result saved to "filename.b"
\
\ note this does NOT run the resulting __main__ -- it is the caller's responsibility
\ to run __main__ (or not) and to delete __main__ when complete
\
: cached-compile-and-load ( filename -- )
		\ "cached-compile-and-load of: " . dup . CR
	\ see if filename.b exists
	\ filename ".b" + file-exists? not if >>do-compile \ does not exist, must compile filename
		\ ".b file exists" . CR
	\ see if mtime of filename > filename.b (i.e. filename.b out of date)
	\ filename file-mtime filename ".b" + file-mtime ( mtime-filename mtime-bfilename )
	\ 	> if >>do-compile \ .b is out of date, must recompile
		\ ".b file is current" . CR
	filename check-needs-recompile if >>do-compile
	\ else, .b file is current, so load it
	filename ".b" + deserialize return \ load words into interpreter & return

	@do-compile
		 \ "(re) compiling " . dup . CR
		\ compile filename -> filename.b
		filename ".b" + open-as-stdout \ write to filename.b
		filename compile-and-serialize \ compile filename -> filename.b
		void open-as-stdout \ restore stdout to write to the screen
		\ easiest thing to do now is load the serialized file i just created
		filename ".b" + deserialize return
	;
	
