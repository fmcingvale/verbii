(
	Verbii compiler, written in verbii
	
	Copyright (c) 2022 Frank McIngvale, see LICENSE

	*** Read bootstrap/READ-ME-BEFORE-RUNNING.txt before editing this code! ***
	***       Changing this file can easily break the entire system!        ***
)

\ **TODO** change this to use the stream interface

( --- reader interface, used by compiler, but may be generally useful
	usage:
		" ... " reader-open-string
		or
		filename reader-open-file

		then reader-next until it returns null
)

var READER_TEXT 1 ( string )
var READER_TEXT_LEN 1
var READER_POS 1

( note - the reader-open-* functions discard any current input )

: reader-open-string ( string )
	READER_TEXT set!
	READER_TEXT ref length READER_TEXT_LEN set!
	0 READER_POS set!
	;

: reader-open-file ( filename )
	file-read reader-open-string
	;

\
\ general note for below: for consistency, when there is no return value due to EOF,
\ void is returned. although technically only a few places need to distinguish null from void,
\ using void throughout I think will be less confusing in the long run
\

: reader-peek-char ( -- char; get next char [string] from reader without advancing stream )
	READER_POS ref READER_TEXT_LEN ref >= if >>eof
	READER_TEXT ref READER_POS ref get ( char )
	return
	@eof 
		void \ return void on eof
	;

: reader-next-char ( -- char; get next char [string] from reader stream or void on eof )
	READER_POS ref READER_TEXT_LEN ref >= if >>eof
	READER_TEXT ref READER_POS ref get ( char )
	READER_POS ref 1 + READER_POS set! ( char; ++pos )
	return
	@eof
		void
	;

: reader-next-chunk ( -- next string of either all whitespace or non-whitespace )
		\ "reader-next-chunk" . CR
	"" ( string )
	\ see what next chunk starts with ...
	reader-peek-char
	dup void? if >>drop-return
	dup whitespace? if >>ws 
	\ else, non-whitespace
	drop
	@non-ws-loop ( string )
	reader-peek-char ( if next is whitespace, do NOT want to read it )
	dup void? if >>drop-return
	dup whitespace? if >>drop-return
	drop reader-next-char + <<non-ws-loop ( append to string and continue )

	\ read whitespace chunk
	@ws
	drop
	@ws-loop ( string )
	reader-peek-char
	dup void? if >>drop-return
	dup whitespace? not if >>drop-return
	drop reader-next-char + <<ws-loop

	@drop-return ( string char )
		drop return
	;

: reader-next ( -- symbol ; get next word from reader stream, or void on eof )
	"" ( word )
	@skipws ( skip leading whitespace )
		reader-peek-char
		dup void? if >>void-on-read 
		ord 32 > if >>word-loop
		reader-next-char ( word char; ++pos )
		drop
		<<skipws

	@void-on-read ( word void )
		drop >>eof

	@word-loop ( word )
		( i want to preserve any whitespace after word [e.g. for string parsing], so peek first )
		reader-peek-char ( word char )
		dup void? if <<void-on-read
		( check for whitespace )
		dup ord 32 <= if >>space  ( treat anything from ' ' to NUL as whitespace )
		( not whitespace, read char, append and continue )
		drop reader-next-char + <<word-loop

	@space ( word char )
		drop ( fall through to return word below )

	@eof ( word ) 
		( return word, void on end of file )
		dup length 0 == if >>isvoid
		string->symbol return ( return word as symbol )

	@isvoid drop void return
	;

: digit? ( string|symbol -- true|false; is single char a digit? )
	dup string? if >>string
		dup '0 < if >>notdigit
		dup '9 > if >>notdigit
		drop true return  ( symbol match )
	@string
		dup "0" < if >>notdigit
		dup "9" > if >>notdigit
		drop true return
	@notdigit drop false
	;

: any-digits? ( string|symbol -- true|false; does string/symbol contain ANY digits? )
	{ digit? } any?
	;

: ltrim-char ( string char -- if char (single-char string) is at front of string, remove it )
	over length 0 != if >>do-trim
	drop return \ 0-length string, nothing to do
	@do-trim
	>L 0 +get L> == if >>trim
	return
	@trim 1 -1 slice
	;

: ltrim-sign ( string -- string with leading "+" or "-" removed [max 1] )
	dup length 0 != if >>do-trim
	return \ 0-length string
	@do-trim
	0 +get "+" == if >>trim
	0 +get "-" == if >>trim
	return
	@trim 1 -1 slice
	;

: ltrim-digits ( string -- string with leftmost digits removed )
	@loop
		dup length 0 == if >>done
		0 +get digit? not if >>done
		1 -1 slice <<loop
	@done
	;

: int-string? ( string -- true|false if string can be parsed as integer )
	dup any-digits? not if >>nodigits ( must have digits, not just +/- )
	ltrim-sign
	ltrim-digits
	length 0 == return
	@nodigits 
		drop false
	;

: int-symbol? ( like above but for symbols )
	unmake make-string 
	int-string?
	;

: float-string? ( string -- true|false if string can be parsed as float )
	( NOTE - this will ALSO match integers, so use int-string? first to rule those out )
	dup any-digits? not if >>nodigits ( must have digits, not just +/-/./e )
	ltrim-sign
	ltrim-digits
	"." ltrim-char
	ltrim-digits
	"e" ltrim-char
	ltrim-sign
	ltrim-digits
	length 0 == return
	@nodigits 
	drop false
	;

: float-symbol? ( as above but for symbols )
	unmake make-string float-string?
	;

( make literal """ which is not parseable itself )
var TRIPLEQUOTE 1
34 34 34 3 make-symbol TRIPLEQUOTE set!

\ parse next word from input into runnable object
: syntax-next ( -- obj )
	reader-next
		 \ "syntax-next:" . dup . CR
	dup void? if >>void
	dup '( == if >>comment
	dup '\ == if >>line-comment
	dup '{ == if >>lambda
	dup '[ == if >>list
	dup ': == if >>worddef
	dup 'def == if >>worddef ( synonym for ':' )
	dup 'var == if >>var
	dup 'del == if >>del
	dup 'true == if >>true-literal
	dup 'false == if >>false-literal
	dup 'null == if >>null-literal

	( look for triple-quoted string first )
	dup 0 3 slice TRIPLEQUOTE ref == if >>triplestring
	( now single quoted string )
	dup 0 get '" == if >>string ( "... )
	\ test for correct format before passing to parse-int or parse-float since those functions
	\ will happily parse something like "123abc" as 123 )
	dup int-symbol? if >>integer
	dup float-symbol? if >>float
	dup 0 get '# != if >>nomatch dup 1 -1 slice float-symbol? if >>float-literal
	@nomatch
		( leave unprocessed word on stack )
		return
	@void
		return ( leave void on stack )
	@worddef
		drop syntax-define-word return
	@var
		drop syntax-var return
	@del
		drop syntax-del return
	@comment
		drop syntax-comment syntax-next return ( skip comment and return NEXT object )
	@line-comment
		drop syntax-line-comment syntax-next return ( skip comment and return NEXT object )
	@lambda
		drop syntax-lambda return
	@list
		drop syntax-list return
	@triplestring
		( call syntax-triple-string with first piece on stack )
		syntax-triple-string return
	@string
		( call syntax-string with first piece on stack )
		syntax-string return
	@integer
		parse-int return
	@float
		parse-float return
	@float-literal ( #NN.NN form )
		1 -1 slice parse-float return
	@true-literal drop true return
	@false-literal drop false return
	@null-literal drop null return
	;

\ if list is [ ,,inline obj1 .. objN ] then push obj1 .. objN to the stack
\ and remove of list. else leave list alone.
: flatten-if-inline ( list -- list or items )
	dup length 0 == if >>done \ empty list, leave on stack
	dup 0 get ',,inline == if >>flatten
	return \ not ,,inline, leave on stack
	@flatten ( list )
		\ drop ,,inline and push rest of list to stack
		1 -1 slice unmake drop return
	@done ( list )
	;

\ assumes @( was just read, parses until ) as an object list, prepended with ,,declargs
: syntax-parse-decl-arglist
	@locals [ outlist ]
	',,declargs 1 make-list outlist!
	@loop
		syntax-next
		dup void? if >>eof
		dup ') == if >>done
		\ else append object and continue
		outlist swap append outlist! <<loop
	@eof
		drop "End of input inside @(" error
	@done
		drop outlist
	;
	
\ assumes ':' was just read
: syntax-define-word
	@locals [ SP-start name ]
	syntax-next ( name must dbe next )
	dup symbol? not if >>badname
	\ call syntax-next repeatedly until ';' is found. this will leave all parsed
	\ words on stack that i'll then make into a list. easy way to do this is remember
	\ starting value of SP then subtract from SP at end to get # of items parsed.
	name! SP SP-start!
	@loop
	syntax-next ( get next processed object )
	dup void? if >>eof
	dup '@( == if >>arglist \ ) <- freaks out notepad++ styling here
	dup '; == if >>endword
	dup list? if >>list \ lists may need special handling, see below
	<<loop
	@arglist ( obj )
		\ i do not check here to see if i have multiple @( .. ) constructs; that can
		\ be handled at the rewrite stage
		drop
		syntax-parse-decl-arglist <<loop
		
	\ when i get a list i need to see if it is [ ,,inline ... ] and flatten it if so
	@list ( list )
		flatten-if-inline <<loop

	@badname str "Invalid name after ':' : " swap + error
	@eof "Unexpected end of input looking for ';'" error
	@endword
	drop ( drop ; )
	SP-start SP - 1 - ( calc number of items )
	make-list
	( save names & compiled words )
	name save-defined-word
	syntax-next ( save-defined-word has no return value, so return NEXT object )
	;

\ var NAME COUNT -- 'var' was already read
: syntax-var
	syntax-next ( name should be next )
	dup symbol? not if >>badname
	'' swap + ( make quoted name )
	syntax-next ( count should be next )
	dup int? not if >>badcount

	\ general note for here and below -- syntax-next has to return ONE object to
	\ avoid complicating all callers, so when a syntax element expands to multiple
	\ objects, those objects are returned as a list: [ ,,inline obj ... ]. this
	\ list will then be flattened as needed, but intermediate routines can just pass
	\ the list as-is and not worry about it representing multiple objects.
	
	',,inline -rot ( ,,inline name count )
	',,var ( ,,inline ,,var name count ,,var )
	4 make-list
	 \ "SYNTAX VAR MADE:" . .S CR
	return

	@badname str "Bad name in var: " swap + error
	@badcount str "Bad count in var: " swap + error
	;

\ del NAME -- 'del' was already read
: syntax-del
	syntax-next ( name must be next )
	dup symbol? not if >>badname
	'' swap + ( make quoted name )
	\ as with var, i need to return multiple words, so return 
	\ [ ,,inline name ,,del ]
	',,inline swap ( ,,inline name )
	',,del ( ,,inline name ,,del )
	3 make-list 
	return

	@badname str "Bad name in del: " swap + error
	;

: syntax-string ( first string part already on stack *as symbol* )
	( convert first since reader-next-char returns strings )
	symbol->string
		
	( see if first string part ends with " )
	dup -1 get ord 34 == ( use ascii value for " )
		over length 1 >
		and
		if >>endstring ( first part begins and ends with " so string is complete )

	( now switch to character mode to preserve all inner whitespace )
	@loop ( string )
		reader-next-char ( string char )
		dup void? if >>eof ( EOF in string, error )
		dup ord 34 == if >>quote ( test against ASCII value for " to avoid any parsing weirdness )
		( else, append regular char to string )
		+ <<loop
		
	@quote ( string " )
		+ ( append " to string )

		( if whitespace is next, then string is complete )
		reader-peek-char
		dup void? if >>endquote ( EOF ok AFTER end quote )
		dup whitespace? if >>endquote
		( else, keep reading more )
		drop <<loop

	@endquote drop >>endstring

	@eof ( string char ) 
		drop "Unexpected end of input inside string: " swap + error

	@endstring ( string -- string without quotes )
		dup length 2 - 1 swap slice ( remove quotes )
	;
	
: syntax-triple-string ( first-piece-symbol -- string )
	\ convert to string first ...
	symbol->string
	\ special case of only one piece ... """..."""
	dup length 6 >=
	over -3 -1 slice TRIPLEQUOTE ref symbol->string == and if >>return

	\ else, keep first-piece on stack and add more chunks until i find one
	\ that ends in """
	@read-loop
		reader-next-chunk
		dup void? if >>error-eos
		+
		dup -3 -1 slice TRIPLEQUOTE ref symbol->string == if >>return
		<<read-loop

	@error-eos
		"String ended inside triple-quoted string: " swap + error

	@return ( remove triple quotes from both sides )
		dup length 3 swap 6 - slice
	;

: syntax-lambda ( assumes { was just read & dropped )
	0 make-list 
	@loop
		\ note - any inner lambdas will be handled automatically by syntax-next,
		\ so don't have to check for "{" here
		syntax-next
		dup void? if >>eof
		dup '} == if >>closebrace
		append ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside { .. }" error
	@closebrace
		drop make-lambda return
		;

: syntax-list ( assumes [ was just read & dropped )
	0 make-list 
	@loop ( list )
		\ note - any inner lists/lambdas will be handled automatically by syntax-next,
		\ so don't have to check for { or [ here
		syntax-next
		dup void? if >>eof
		dup '] == if >>closelist
		append ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside [ .. ]" error
	@closelist
		drop
		;

: syntax-comment ( assumes open paren just read )
	"" >L 1 >L ( L0 = nesting, L1 = comment text )
	@loop
		reader-next ( puts symbol on stack )
		dup void? if >>eof
		( add to comment text )
		dup symbol->string L1 ref " " + swap + L1 set! 

		dup ') == if >>closeparen
		dup '( == if >>openparen \ ) <- to stop notepad++ highlighter from messing up
		drop <<loop ( discard and continue )
	@closeparen
		LP ref 1 - LP set!
		LP ref 0 == if >>end
		drop <<loop
	@openparen
		LP ref 1 + LP set!
		drop <<loop
	@end
		LP 2 + LP! ( clean up locals )
		drop return
	@eof
		L1 ref 0 40 slice
		"Unexpected end of input inside comment: " swap + error
	;
	
: syntax-line-comment ( assumes "\" was just read )
	( read *characters* until EOL found )
	@loop
		reader-next-char
		( if end of stream, "\n" or "\r", then i'm done )
		dup void? if >>eol
		dup ord 13 == if >>eol
		dup ord 10 == if >>eol
		drop <<loop ( discard char and continue )
	@eol
		drop ( discard char and return )
	;

: serialize-escape-string ( string -- string with whitespace escaped )
	{ 
		( char )
		dup ord 32 == if >>space
		dup ord 37 == if >>percent
		dup ord 9 == if >>tab
		dup ord 10 == if >>lf 
		dup ord 13 == if >>cr 
		\ not a special char - return as-is
		return

		\ note -- "%" cannot appear in the strings here nor the serialize/deserialize
		\ loop - would mess up the replacement strings. so use % == chr(37) instead of "%" )
		@space ( char )
			drop 37 chr "32" + ( "%32" )
			return

		@tab ( char )
			drop 37 chr "09" + ( "%09" )
			return

		@percent ( char )
			drop 37 chr "37" + ( "%37" )
			return
			
		@lf ( char )
			drop 37 chr "10" + ( "%10" )
			return
		@cr 
			drop 37 chr "13" + ( "%13" )
	} map
	;

\ general note: the following is NOT intended to be a general-purpose serialization format.
\ 				its only purpose is to be able to serialize byte-compiled verbii source.
\				primarily it is for compiler.verb and init.verb, but is general enough to
\				serialize any verbii source file.
\
\				as a consequence, there is no need to serialize anything that cannot exist
\				in source form. this includes:
\					* void - no source format (void is a word)
\					* closure - no source format - requires :: at runtime
\					* dict - no source format - requires make-dict or ,,new-dict at runtime
\
\				technically floats are not needed in compiler.verb nor init.verb, however,
\				to allow this to be used for ANY verbii source (i.e. to cache compilations)
\				they are allowed here.

: serialize-object ( obj -- ; serialize obj to stdout )
	dup int? if >>int
	dup float? if >>float
	dup string? if >>string
	dup symbol? if >>symbol
	dup list? if >>list
	dup lambda? if >>lambda
	dup bool? if >>bool
	dup null? if >>null
	repr "Unknown obj in serialize-object:" swap + error
	@int ( i NNN )
		"i" . str puts CR return
	@float ( f NN.NNN )
		"f" . str puts CR return
	@bool ( b true|false )
		"b" . str puts CR return
	@null ( n )
		drop "n" . CR return
	@string ( s SSS )
		"s" . serialize-escape-string puts CR return
	@symbol ( y SSS - symbols cannot contains spaces, \n, etc. so no escaping needed )
		"y" . str puts CR return
	@list ( "L length" then serialized items )
		"L" . dup length str puts CR
		{ serialize-object } for-each ( items )
		return
	@lambda ( "F" then list serialized )
		"F" puts CR
		unmake serialize-object ( serialize list )
		return
		;

: save-defined-word ( list name )
	swap 2 make-list ( [ name list ] )
	COMPILED_NAMELISTS ref swap append drop
	;

\ take a list: [ ,,declargs arg ... -- local ... ]
\ and return lists of [ arg ... ] and [ local ... ]
: compile-split-declargs ( list -- args locals )
	@args [ list ]
	@locals [ i args locals parsing-locals ]
	[ ] args!
	[ ] locals!
	false parsing-locals! \ have i seen the '--' ?
	1 i! \ skip ,,declargs
	@loop
		i list length >= if >>done
		list i get '-- == if >>got-dashes 
		\ else add to either args or locals list
		parsing-locals if >>add-to-locals
		args list i get append args! >>next \ add to args
	@add-to-locals ( obj )
		locals list i get append locals! >>next \ add to locals 
	@got-dashes
		true parsing-locals! \ switch to parsing locals, fall through to next
	@next
		i 1 + i! <<loop
	@done 
		args locals
		;
		
\ takes a compiled objlist and collects:
\	[ ,,declargs arg .. -- local .. ] => args & locals
\		(the compiler generates this from @( arg ... -- local ... )
\	@args [ ... ] => args
\	@locals [ ... ] => locals
\
\ returns rewritten objlist with the @args & @locals removed.
\
\ it is valid to have BOTH @( ... ) and @args/@locals -- the names will be
\ merged into a single args/locals lists
: compile-collect-args-locals ( objlist -- new-objlist args locals )
	@args [ objlist ]
	@locals [ new-objlist args locals i ]
		\ "COMPILE COLLECT ARGS LOCALS:" . .S CR
		\ "	objlist:" . objlist str . CR
	[ ] new-objlist!
	[ ] args!
	[ ] locals!
	0 i!
	@loop
		objlist i get ( objlist[i] )
		dup void? if >>done \ i >= length
		dup list? if >>check-list
		dup '@args == if >>args-list 
		dup '@locals == if >>locals-list
		\ else regular obj, copy to new list
		>>keep-obj
	@check-list ( obj )
		\ see if this is [ ,,declargs ... ]
		dup length 0 == if >>keep-obj
		dup 0 get ',,declargs != if >>keep-obj
		\ it is ,,declargs, so split into args,locals
		compile-split-declargs ( args locals )
		locals swap + locals!  \ append locals & args to my lists 
		args swap + args! >>next
	@keep-obj ( list )
		new-objlist swap append new-objlist! >>next
	@args-list ( obj )
		drop
		\ just saw @args so a list must be next
		i 1 + i!
		objlist i get
		dup void? if >>missing-args \ end of input
		dup list? not if >>missing-args 
		\ add list to anything collected so far from @( .. )
		args swap + args! >>next
	@missing-args
		"Expecting list after @args in:" objlist str + error
	@locals-list ( obj )
		drop
		\ list must be next
		i 1 + i!
		objlist i get
		dup void? if >>missing-locals
		dup list? not if >>missing-locals
		\ add to any existing locals from @( .. )
		locals swap + locals! >>next 
	@missing-locals
		"Expecting list after @locals in:" objlist str + error
	@next
		i 1 + i! <<loop
	@done ( void )
		drop new-objlist args locals
		;
		
\ takes a compiled object list and a list of names 'args' and 'locals'
\
\ rewrites objlist to do:
\	- pop #args from stack into locals
\	- reserve #locals in local stack
\	- for every name N in ARGLIST and LOCALLIST, create
\		mappings:
\			N -> LP i + ref 
\			N! -> LP i + set!
\	- replace all instances of N and N! in objlist with above mappings
: compile-rewrite-args-locals ( objlist args locals -- new-objlist )
	@args [ objlist args locals ]
	@locals [ namemap new-objlist ]
		\ "REWRITE ARGS LOCALS:" . CR
		\	"	objlist:" . objlist . CR
		\	"	args:" . args . CR
		\	"	locals:" . locals . CR
	,,new-dict namemap! \ dict mapping names -> code replacements
	[ ] new-objlist! \ rewritten objlist with names replaced with code sequences
	
	@begin
		\ "Got @args:" . L0 ref . CR
		\ "Got @locals:" . L1 ref . CR
		\ "Code now:" . dup . CR

		\ optimization -- if I have NO @args nor @locals, then do not modify objlist -- no need for
		\ code to setup/teardown frame when no named vars being used
		args length 0 ==
		locals length 0 ==
		and not if >>process
		
		\ no args & locals so output original list
		objlist new-objlist! >>exit

	@process
		\ make locals layout:
		\	N+M-1: locals[M-1]
		\	...
		\	N+1: locals[1]
		\	N: locals[0]
		\	N-1: args[N-1]
		\	...
		\	1: args[1]
		\	0: args[0]
		
		\ process @args first:
		\	for each arg "N" at index i, create two symbols:
		\		"N" -> LP i + ref
		\		"N!" -> LP i + set!
			\ "PROCESS ARGS:" . CR
		args
		{
			( called with: i name ; self bound to mapping dict )
			str 2dup over 'LP swap '+ 'ref 4 make-list ( i name i name [ 'LP i '+ 'ref ] )
			self -rot put ( i name i dict ) drop drop
			over 'LP swap '+ 'set! 4 make-list ( i name [ 'LP i '+ 'set! ] )
			swap "!" + swap ( i name! [ 'LP i '+ 'set! ] )
			self -rot put ( i dict ) drop drop
		} namemap :: ( bind namemap to function )
		for-each-i 
			\ "MAPPINGS after adding @args:" . namemap . CR
		\ basically same thing for locals now, with offset:
		\	for each local "N" at index i, create two symbols:
		\		"N" -> LP i + #args + ref
		\		"N!" -> LP i + #args + set!
		locals
		{
			( called with: i name ; self bound to [ dict #args ] )
			str 2dup over self 1 get + 'LP swap '+ 'ref 4 make-list ( i name i name [ 'LP i+#args '+ 'ref ] )
			self 0 get -rot put ( i name i dict ) drop drop
			over self 1 get + 'LP swap '+ 'set! 4 make-list ( i name [ 'LP i+#args '+ 'set! ] )
			swap "!" + swap ( i name! [ 'LP i+#args '+ 'set! ] )
			self 0 get -rot put ( i dict ) drop drop
		} namemap args length 2 make-list :: ( bind lambda with [ dict #args ] )
		for-each-i 
			\ "MAPPINGS after adding @locals:" . L2 ref . CR
		\ add a mapping with code for 'return' (LP #args+#locals + LP!)
		namemap "return" 'LP args length locals length + '+ 'LP! 'return 5 make-list put namemap!
			\ "MAPPINGS after adding 'return':" . namemap . CR
		\ finally, create new objlist by replacing all mapped symbols
		objlist
		{
			\ called with: ( accum elem ) ; self bound to mapping dict

			\ only process symbols
			dup symbol? not if >>copy \ not symbol, leave it as-is
			self over str get void? if >>copy \ not in mapping dict, copy as-is
			\ replace with mapping
			self swap str get + return

			@copy ( accum elem )
				append return \ append to new list as-is
		} namemap :: ( bind self to mapping dict )
	 	\ "READY TO FOLD:" . .S CR
		\ initial value is stack setup: [ LP #locals - LP! ] then one >L for each @arg
		'LP locals length '- 'LP! 4 make-list
		[ '>L append ] args length repeat
		fold new-objlist!

	@exit
		new-objlist
		;

\ take a parsed objlist, presumably from byte-compile, and perform finalization:
\	* ensure objlist ends with 'return'
\	* transform @args [ .. ] and @locals [ .. ] into code
\
\ returns a new list, does NOT modify objlist
: compile-finalize-word ( objlist -- newlist )
		\ "FINALIZE WORD:" . .S CR
	dup length 0 > if >>not-empty
	\ objlist is empty; newlist is [ return ]
	drop 'return 1 make-list >>transform-args-locals

	@not-empty ( objlist )
		dup -1 get 'return != if >>add-return
		\ already has return at end
		>>transform-args-locals

	@add-return ( objlist )
		deepcopy \ don't modify original
		'return append

	@transform-args-locals ( objlist )
		\ split @( .. ), @args and @locals from objlist
		compile-collect-args-locals ( new-objlist args locals )
			\ "AFTER COLLECTING:" . .S CR
		\ turn names into code sequences
		compile-rewrite-args-locals
			\ "AFTER REWRITING:" . .S CR
	;
	
var COMPILED_NAMELISTS 1

\ take the parsed COMPILED_NAMELISTS and perform finalization on the words.
\ see compiled-finalize-wprd for details. saves finalized lists back to COMPILED_NAMELISTS
: compiler-finalize-all-words ( -- )
		\ "FINALIZE ALL WORDS" . CR
	0
	@loop ( i )
		dup COMPILED_NAMELISTS ref length >= ( i >= #lists ) if >>done 
		COMPILED_NAMELISTS ref over get ( i lists[i] )
			\ "READY FOR PAIR:" . .S CR
		1 get ( i objlist )
			\ "REWRITING OBJLIST:" . dup . CR
		compile-finalize-word ( i new-objlist )
		over COMPILED_NAMELISTS ref swap get ( i newlist LISTS[i] )
			\ "READY TO PUT:" . .S CR
		1 rot put drop ( i )
		1 + <<loop ( ++i )
	@done
		\ "FINAL NAMELISTS:" . COMPILED_NAMELISTS ref . CR
		drop
	;

: byte-compile ( -- names wordlists ; byte-compile source from current reader stream )
	\ do NOT store compiled words into interpreter since that would prevent compiling
	\  any code that contained a name that was already defined -- for example when
	\  compiling this file
	\
	\ instead, store as a list of [name,wordlist] to COMPILED_NAMELISTS

	0 make-list COMPILED_NAMELISTS set!

	\ i need to count the number of parsed words that DID NOT go into COMPILED_NAMELISTS, so
	\ save starting SP so I can count at the end
	SP >L ( L0=SP at start )
	@loop
	( read all parsed objects then make into a list )
	syntax-next
	dup void? if >>done 
	dup list? if >>list
	<<loop
	@list
	\ **TODO** change this to use flatten-if-inline
	\ check for [ ,,inline ... ] and flatten
	dup length 0 == if <<loop
	dup 0 get ',,inline == if >>flatten
	<<loop
	@flatten
		1 -1 slice unmake drop <<loop
	@done
	drop
	( count # items added to stack and make list )
	L> SP - 1 - make-list
	( save this code under __main__ )
	'__main__ save-defined-word
	( perform finalization of all words )
	compiler-finalize-all-words
	( leave list of [ name list ] on stack )
	COMPILED_NAMELISTS ref
	;

: byte-compile-file ( filename -- list of [ name list ] ; byte-compile filename and leave outputs on stack )
	reader-open-file byte-compile
	;

: byte-compile-string ( text -- list of [ name list ] ; byte-compile filename and leave outputs on stack )
	reader-open-string byte-compile
	;

: serialize-compiled-output
	( take output of byte-compile-* and serialize to stdout )

	( each obj is [ name wordlist ] )
	{ "W" . dup 0 get str puts CR 1 get serialize-object } for-each 
	;

( compiles filename and writes serialized form to stdout. does NOT alter interpreter words )
: compile-and-serialize ( filename -- )
	byte-compile-file ( this will be all code other than word definitions )

	( that left list of [ name list ] on stack )

	( this will all be written to a list )
	"L" . dup length str puts CR

	( serialize )
	serialize-compiled-output
	;

( compiles string and loads words into current interpreter )
: compile-and-load-string ( string -- )
	byte-compile-string
	( now load the [ name wordlist ] pairs into interpreter )
	{ dup 1 get swap 0 get make-word } for-each
	;


\
\ compile & load the given file. if "filename.b" exists, and is the same age (or newer), 
\ then it is loaded instead of recompiling filename.
\
\ if "filename.b" does not exist, or is older than filename, then filename is
\ compiled and the result saved to "filename.b"
\
\ note this does NOT run the resulting __main__ -- it is the caller's responsibility
\ to run __main__ (or not) and to delete __main__ when complete
\
: cached-compile-and-load ( filename -- )
		\ "cached-compile-and-load of: " . dup . CR
	\ see if filename.b exists
	dup ".b" + file-exists? not if >>do-compile \ does not exist, must compile filename
		\ ".b file exists" . CR
	\ see if mtime of filename > filename.b (i.e. filename.b out of date)
	dup file-mtime over ".b" + file-mtime ( filename mtime mtime.b )
	> if >>do-compile \ .b is out of date, must recompile
		\ ".b file is current" . CR
	\ .b file is current, so load it
	".b" + deserialize return \ load words into interpreter & return

	@do-compile ( filename )
		 \ "(re) compiling " . dup . CR
		\ compile filename -> filename.b
		dup ".b" + open-as-stdout \ write to filename.b
		dup compile-and-serialize \ compile filename -> filename.b
		void open-as-stdout \ restore stdout to write to the screen
		\ easiest thing to do now is load the serialized file i just created
		".b" + deserialize return
	;
	