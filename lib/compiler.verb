(
	Verbii compiler, written in verbii
	
	Copyright (c) 2022 Frank McIngvale, see LICENSE

	*** Read bootstrap/READ-ME-BEFORE-RUNNING.txt before editing this code! ***
	***       Changing this file can easily break the entire system!        ***
)

( --- reader interface, used by compiler, but may be generally useful
	usage:
		" ... " reader-open-string
		or
		filename reader-open-file

		then reader-next until it returns null
)

var READER_TEXT 1 ( string )
var READER_TEXT_LEN 1
var READER_POS 1

( note - the reader-open-* functions discard any current input )

: reader-open-string ( string )
	READER_TEXT set!
	READER_TEXT ref length READER_TEXT_LEN set!
	0 READER_POS set!
	;

: reader-open-file ( filename )
	read-file reader-open-string
	;

: reader-peek-char ( -- char; get next char [string] from reader without advancing stream )
	READER_POS ref READER_TEXT_LEN ref >= if >>eof
	READER_TEXT ref READER_POS ref get ( char )
	return
	@eof 
		null
	;

: reader-next-char ( -- char; get next char [string] from reader stream or null on eof )
	READER_POS ref READER_TEXT_LEN ref >= if >>eof
	READER_TEXT ref READER_POS ref get ( char )
	READER_POS ref 1 + READER_POS set! ( char; ++pos )
	return
	@eof
		null
	;

: reader-next ( -- word ; get next word from reader stream, or null on eof )
	"" ( word )
	@skipws ( skip leading whitespace )
		reader-peek-char
		dup null? if >>null-on-read 
		ord 32 > if >>word-loop
		reader-next-char ( word char; ++pos )
		drop
		<<skipws

	@null-on-read ( word null )
		drop >>eof

	@word-loop ( word )
		( i want to preserve any whitespace after word [e.g. for string parsing], so peek first )
		reader-peek-char ( word char )
		dup null? if <<null-on-read
		( check for whitespace )
		dup ord 32 <= if >>space  ( treat anything from ' ' to NUL as whitespace )
		( not whitespace, read char, append and continue )
		drop reader-next-char + <<word-loop

	@space ( word char )
		drop ( fall through to return word below )

	@eof ( word ) 
		( return word, null on end of file )
		dup length 0 == if >>isnull
		string->symbol return ( return word as symbol )

	@isnull drop null return
	;

: whitespace? ( string -- bool; is first char of string whitespace? )
	0 get ord ( get as ascii )
	32 <= ( treat everthing <= space as whitespace )
	;

: digit? ( string|symbol -- true|false; is single char a digit? )
	dup string? if >>string
		dup '0 < if >>notdigit
		dup '9 > if >>notdigit
		drop true return  ( symbol match )
	@string
		dup "0" < if >>notdigit
		dup "9" > if >>notdigit
		drop true return
	@notdigit drop false
	;

: any-digits? ( string|symbol -- true|false; does string/symbol contain ANY digits? )
	{ digit? } any
	;

: ltrim-char ( string char -- if char (single-char string) is at front of string, remove it )
	>L 0 +get L> == if >>trim
	return
	@trim 1 -1 slice
	;

: ltrim-sign ( string -- string with leading "+" or "-" removed [max 1] )
	0 +get "+" == if >>trim
	0 +get "-" == if >>trim
	return
	@trim 1 -1 slice
	;

: ltrim-digits ( string -- string with leftmost digits removed )
	@loop
		dup length 0 == if >>done
		0 +get digit? not if >>done
		1 -1 slice <<loop
	@done
	;

: int-string? ( string -- true|false if string can be parsed as integer )
	dup any-digits? not if >>nodigits ( must have digits, not just +/- )
	ltrim-sign
	ltrim-digits
	length 0 == return
	@nodigits 
		drop false
	;

: int-symbol? ( like above but for symbols )
	unmake make-string 
	int-string?
	;

: float-string? ( string -- true|false if string can be parsed as float )
	( NOTE - this will ALSO match integers, so use int-string? first to rule those out )
	dup any-digits? not if >>nodigits ( must have digits, not just +/-/./e )
	ltrim-sign
	ltrim-digits
	"." ltrim-char
	ltrim-digits
	"e" ltrim-char
	ltrim-sign
	ltrim-digits
	length 0 == return
	@nodigits 
	drop false
	;

: float-symbol? ( as above but for symbols )
	unmake make-string float-string?
	;

: syntax-next ( convert next word from input to runnable object )
	reader-next
		( "syntax-next:" . dup . CR )
	dup null? if >>null
	dup '( == if >>comment
	dup '\ == if >>line-comment
	dup '{ == if >>lambda
	dup ': == if >>worddef
	dup 'def == if >>worddef ( synonym for ':' )
	dup 0 get '" == if >>string ( "... )
	( test for correct format before passing to parse-int or parse-float since those functions
	  will happily parse something like "123abc" as 123 )
	dup int-symbol? if >>integer
	dup 0 get '# != if >>nomatch dup 1 -1 slice float-symbol? if >>float
	@nomatch
		( leave unprocessed word on stack )
		return
	@null
		return ( leave null on stack )
	@worddef
		drop syntax-define-word return
	@comment
		drop syntax-comment syntax-next return ( skip comment and return NEXT object )
	@line-comment
		drop syntax-line-comment syntax-next return ( skip comment and return NEXT object )
	@lambda
		drop syntax-lambda return
	@string
		syntax-string return
	@integer
		parse-int return
	@float
		1 -1 slice parse-float return
	;

: syntax-define-word
	syntax-next ( name should be next )
	dup symbol? not if >>badname
	>L SP >L   ( L0=starting SP, L1=name )
	@loop
	syntax-next ( get next processed object - assume it can be more than 1 object )
	dup null? if >>eof
	dup '; == if >>endword
	<<loop
	@badname repr "Invalid name after ':' : " swap + error
	@eof "Unexpected end of input looking for ';'" error
	@endword
	drop ( drop ; )
	L> SP - 1 - ( calc number of items )
	make-list
	L> 
	( save names & compiled words )
	save-defined-word
	syntax-next ( save-defined-word has no return value, so return NEXT object )
	;

: syntax-string ( first string part already on stack *as symbol* )
	( convert first since reader-next-char returns strings )
	symbol->string
		
	( see if first string part ends with " )
	dup -1 get ord 34 == ( use ascii value for " )
		over length 1 >
		and
		if >>endstring ( first part begins and ends with " so string is complete )

	( now switch to character mode to preserve all inner whitespace )
	@loop ( string )
		reader-next-char ( string char )
		dup null? if >>eof ( EOF in string, error )
		dup ord 34 == if >>quote ( test against ASCII value for " to avoid any parsing weirdness )
		( else, append regular char to string )
		+ <<loop
		
	@quote ( string " )
		+ ( append " to string )

		( if whitespace is next, then string is complete )
		reader-peek-char
		dup null? if >>endquote ( EOF ok AFTER end quote )
		dup whitespace? if >>endquote
		( else, keep reading more )
		drop <<loop

	@endquote drop >>endstring

	@eof ( string char ) 
		drop "Unexpected end of input inside string: " swap + error

	@endstring ( string -- string without quotes )
		dup length 2 - 1 swap slice ( remove quotes )
	;
	
: syntax-lambda ( assumes { was just read & dropped )
	0 make-list 
	@loop
		( note - any inner lambdas will be handled automatically by syntax-next,
			so don't have to check for "{" here )
		syntax-next
		dup null? if >>eof
		dup '} == if >>closebrace
		append ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside { .. }" error
	@closebrace
		drop make-lambda return
		;

: syntax-comment ( assumes open paren just read )
	1 >L ( L0 = nesting )
	@loop
		reader-next ( puts symbol on stack )
		dup null? if >>eof
		dup ') == if >>closeparen
		dup '( == if >>openparen
		drop <<loop ( discard and continue )
	@closeparen
		LP ref 1 - LP set!
		LP ref 0 == if >>end
		drop <<loop
	@openparen
		LP ref 1 + LP set!
		drop <<loop
	@end
		LP 1 + LP!
		drop return
	@eof
		"Unexpected end of input inside comment" error
	;
	
: syntax-line-comment ( assumes "\" was just read )
	( read *characters* until EOL found )
	@loop
		reader-next-char
		( if end of stream, "\n" or "\r", then i'm done )
		dup null? if >>eol
		dup ord 13 == if >>eol
		dup ord 10 == if >>eol
		drop <<loop ( discard char and continue )
	@eol
		drop ( discard char and return )
	;

( 
	for-each -- call a lambda on each element of a sequence [any object that supports
   	'length' and 'slice' methods]

	lambda is called with current item of sequence on top of stack. for-each does not
	touch the stack otherwise.
)
: for-each ( object lambda -- call lambda on each object in string,symbol,list )
	>L dup length >L 0 >L ( L0=index, L1=length, L2=lambda )
	@loop
	L0 ref L1 ref >= if >>done
	L0 ref +get L2 ref 
	call ( call lambda with element on stack )
	L0 ref 1 + L0 set! <<loop
	@done drop LP 3 + LP!
	;

: serialize-escape-string ( string -- string with whitespace escaped )
	"" swap  ( escaped string )
	{ 
		( escaped string char )
		unmake drop  ( escaped string charcode )
		dup 32 == if >>space
		dup 37 == if >>percent
		dup 9 == if >>tab
		dup 10 == if >>lf 
		dup 13 == if >>cr 
		1 make-string ( escaped string char )
		rot swap ( string escaped char )
		+ swap ( escaped+char string )
		return

		( note -- "%" cannot appear in the strings here or the serialize/deserialize
		  loop would mess up the replacement strings. so use % == chr(37) instead of "%" )
		@space ( escaped string charcode )
			drop swap 37 chr "32" + + swap ( escaped+%32 string )
			return

		@tab ( escaped string charcode )
			drop swap 37 chr "09" + + swap ( escaped+%9 string )
			return

		@percent ( escape % as %37 )
			drop swap 37 chr "37" + + swap ( escaped+%37 string )
			return
			
		@lf drop swap 37 chr + "10" + swap return ( \n -- %10 )
		@cr drop swap 37 chr + "13" + swap return ( \r -- %13 )
	} for-each
	;

: serialize-object ( obj -- ; serialize obj to stdout )
	dup null? if >>null
	dup int? if >>int
	dup float? if >>float
	dup bool? if >>bool
	dup string? if >>string
	dup symbol? if >>symbol
	dup list? if >>list
	dup lambda? if >>lambda
	repr "Unknown obj in serialize-object:" swap + error
	@null ( n )
		"n" puts CR return
	@int ( i NNN )
		"i" . str puts CR return
	@float ( f NN.NNN )
		"f" . str puts CR return
	@bool ( b true|false )
		"b" . str puts CR return
	@string ( s SSS )
		"s" . serialize-escape-string puts CR return
	@symbol ( y SSS - symbols cannot contains spaces, \n, etc. so no escaping needed )
		"y" . repr puts CR return
	@list ( "L length" then serialized items )
		"L" . dup length str puts CR
		{ serialize-object } for-each ( items )
		return
	@lambda ( "F" then list serialized )
		"F" puts CR
		unmake serialize-object ( serialize list )
		return
		;

: save-defined-word ( list name )
	swap 2 make-list ( [ name list ] )
	COMPILED_NAMELISTS ref swap append drop
	;

: byte-compile ( -- names wordlists ; byte-compile source from current reader stream )
	( do NOT store compiled words into interpreter since that would prevent compiling
	  any code that contained a name that was already defined -- for example when
	  compiling this file

	  instead, store as a list of [name,wordlist]
	)
	var COMPILED_NAMELISTS 1
	0 make-list COMPILED_NAMELISTS set!

	( i need to count the number of parsed words that DID NOT go into COMPILED_NAMELISTS, so
	  save starting SP so I can count at the end )
	SP >L ( L0=SP at start )
	@loop
	( read all parsed objects then make into a list )
	syntax-next
	dup null? if >>done <<loop
	@done
	drop
	( count # items added to stack and make list )
	L> SP - 1 - make-list
	( save this code under __main__ )
	'__main__ save-defined-word
	( leave list of [ name list ] on stack )
	COMPILED_NAMELISTS ref
	( remove vars so compiler can be run again )
	del COMPILED_NAMELISTS
	;

: byte-compile-file ( filename -- list of [ name list ] ; byte-compile filename and leave outputs on stack )
	reader-open-file byte-compile
	;

: byte-compile-string ( text -- list of [ name list ] ; byte-compile filename and leave outputs on stack )
	reader-open-string byte-compile
	;

: serialize-compiled-output
	( take output of byte-compile-* and serialize to stdout )

	( each obj is [ name wordlist ] )
	{ "W" . dup 0 get repr puts CR 1 get serialize-object } for-each 
	;

( compiles filename and writes serialized form to stdout. does NOT alter interpreter words )
: compile-and-serialize ( filename )
	byte-compile-file ( this will be all code other than word definitions )

	( that left list of [ name list ] on stack )

	( this will all be written to a list )
	"L" . dup length str puts CR

	( serialize )
	serialize-compiled-output
	;

( compiles filename and loads words into current interpreter )
: compile-and-load-string ( string )
	byte-compile-string
	( now load the [ name wordlist ] pairs into interpreter )
	{ dup 1 get swap 0 get make-word } for-each
	;
