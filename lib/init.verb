( -- default library, loaded at startup -- )
( -- Copyright (c) 2022 Frank McIngvale, see LICENSE -- )

(
	*** Read bootstrap/READ-ME-BEFORE-RUNNING.txt before editing this code! ***
	***       Changing this file can easily break the entire system!        ***
)

( assume this file is the first thing loaded at startup, so I can track stack
  depth myself instead of relying on a builtin interpreter word )
var SP_EMPTY 1
SP SP_EMPTY set!

: depth SP_EMPTY ref SP - 1 - ;

: . str puts 32 .c ;
: CR ( -- , prints CR LF ) 10 .c ;
: clear ( xn ... x1 -- ) SP depth + 1 - SP! ;

: drop ( a -- ) SP 1 + SP! ; 
: dup ( a -- a a ) SP ref ; 
: dup? ( a -- a a, only if a != 0 ) dup 0 == if >>ZERO dup @ZERO ; 
: swap ( a b -- b a ) over >L >L drop L> L> ;
: pick ( Sn .. S1 i -- Sn .. S1 Si ) SP + ref ; 

: over ( a b -- a b a ) SP 1 + ref ; 
: 2dup ( a b -- a b a b ) over over ; 
: 2drop ( a b -- ) SP 2 + SP! ; 
: 2over ( a b c d -- a b c d a b ) 4 pick 4 pick ; 
: 2swap ( a b c d -- c d a b ) 
    >L >L >L >L  
    LP 2 + ref LP 3 + ref LP ref LP 1 + ref LP 4 + LP! ; 

: ndrop ( xn .. x1 N -- ) SP + 1 + SP! ;
: nip ( a b -- b ) >L drop L> ;
: tuck ( a b -- b a b ) swap 2 pick ;
: rot ( a b c -- b c a ) 3 pick >L >L >L drop L> L> L> ;
: -rot ( b c a -- a b c ) 2 pick >L 3 pick >L >L drop drop L> L> L> ;

: not ( a -- not[a] ) if >>true true return @true false ;
: or ( a b -- a|b ) if >>true1 if >>true2 false return @true1 drop @true2 true ;
: and ( a b -- a&b ) if >>true1 drop false return @true1 if >>true2 false return @true2 true ;

: != ( a b -- a!=b ) == not ;
: >= ( a b -- a>=b ) 2dup > -rot == or ;
: < ( a b -- a<b ) swap > ;
: <= ( a b -- a<=b ) > not ;

: neg ( a -- -a ) dup int? if >>int 0 swap - return @int 0 swap - ;
: max ( a b -- max[a,b] ) 2dup > if >>A nip return @A drop ;
: min ( a b -- min[a,b] ) 2dup > if >>B drop return @B nip ;
: abs ( a -- abs[a] ) dup 0 < if >>neg return @neg neg ;
( 'floor' divide like in Python -- integers only )
: // ( a b -- quotient a/b ) /mod swap drop ;
: mod ( a b -- remainder a/b ) /mod drop ;

: :: make-closure ;

( .S - print stack without affecting it - good for debugging )
: .S "=>" . depth 
@LOOP 
	dup 0 > if >>true >>done @true dup SP + 1 + ref repr puts 32 .c 1 - <<LOOP @done drop CR ;

: .L ( N -- print first N locals .. meant for debugging, like .S )
	0 ( N index )
	"Locals:" .
	@loop
		( N index )
		2dup == if >>done
		dup str "L" swap + ":" + . dup LP + ref repr puts 32 .c
		1 + <<loop
	@done 2drop
	;

\ compiler turns "var NAME COUNT" into ( name count ,,var )
: ,,var ( name count -- ; creates new variable )
	alloc ( name addr )
	( make word that pushes addr onto stack )
	1 make-list ( name [ addr ] )
	swap make-word
	;
	
( shortcuts for addresses of first 10 locals )
: L0 LP ;
: L1 LP 1 + ;
: L2 LP 2 + ;
: L3 LP 3 + ;
: L4 LP 4 + ;
: L5 LP 5 + ;
: L6 LP 6 + ;
: L7 LP 7 + ;
: L8 LP 8 + ;
: L9 LP 9 + ;

: +get ( same as get but leaves obj on stack )
	over swap get ;

: any ( sequence predicate -- true|false if ANY member of sequence satisfies predicate (lambda) )
	>L dup length >L 0 >L ( L0=index, L1=length, L2=predicate )
	@loop ( sequence )
			( 3 .L CR )
		L0 ref L1 ref == if >>noneFound
		L0 ref +get L2 ref call ( get i'th item in sequence and pass to predicate )
		if >>gotTrue ( found a true item, done )
		L0 ref 1 + L0 set! <<loop
	@gotTrue
		drop LP 3 + LP! true return
	@noneFound
		drop LP 3 + LP! false return
	;

: all ( sequence predicate -- true|false if ALL members of sequence satisfy predicate (lambda) )
	>L dup length >L 0 >L ( L0=index, L1=length, L2=predicate )
	@loop ( sequence )
			( 3 .L CR )
		L0 ref L1 ref == if >>allTrue
		L0 ref +get L2 ref call ( get i'th item in sequence and pass to predicate )
		if >>gotTrue 
		( got false item, so result is false )
		drop LP 3 + LP! false return
	@gotTrue
		L0 ref 1 + L0 set! <<loop
	@allTrue
		drop LP 3 + LP! true return
	;

\ this is what I should have named these ...
\ TODO - find all code using these and change so i can remove these eventually
: any? any ;
: all? all ;
: file-read read-file ;

\ ========================================================================
\ String functions
\ ========================================================================

: whitespace? ( string -- bool; is first char of string whitespace? )
	0 get ord ( get as ascii )
	32 <= ( treat everthing <= space as whitespace )
	;

\ return string with any leading whitespace removed
: string-ltrim ( string -- string )
	0
	@loop ( string i )
		2dup swap length >= ( string i i>=len ) if >>empty
		2dup get whitespace? not ( string i !ws?[string[i]] ) if >>endtrim 
		1 + <<loop
	@endtrim ( string i )
		-1 slice return
	@empty ( string i )
		drop drop "" return
	;

\ is string zero length or contain only whitespace?
: string-empty? ( string -- empty? )
	string-ltrim length 0 ==
	;

: string->symbol ( string -- symbol )
	unmake make-symbol
	;

: symbol->string ( symbol -- string )
	unmake make-string
	;

: ord ( string -- ascii ; get ASCII value of first char of string )
	0 get unmake drop
	;

: chr ( ASCII -- string ; turn ASCII character value into single-character string )
	1 make-string
	;

\ ========================================================================
\ Iteration/looping/functional programming
\ ========================================================================

: repeat ( lambda NR -- call lambda NR times )
	\ lambda is allowed to use stack, but not locals, so store my
	\ parameters in locals
	>L >L ( L1 = NR, L0 = lambda )
	@loop
	L1 ref 0 == if >>done ( NR == 0? )
	L0 ref call ( call lambda, now with access to any args that were below it )
	L1 ref 1 - L1 set! ( NR -= 1 ) <<loop
	@done LP 2 + LP! ; ( remove locals )

\	for-each -- call a lambda on each element of a sequence [any object that supports
\  	'length' and 'slice' methods]
\
\	lambda is called with current item of sequence on top of stack. for-each does not
\	touch the stack otherwise.
\
\	*NOTE* lambda CANNOT rely on the state of the stack or locals -- bind with state if 
\	data is needed other than the passed elements
\
: for-each ( seq lambda -- call lambda on each object in string,symbol,list )
	>L dup length >L 0 >L ( L0=index, L1=length, L2=lambda )
	@loop
	L0 ref L1 ref >= if >>done
	L0 ref +get L2 ref 
	call ( call lambda with element on stack )
	L0 ref 1 + L0 set! <<loop
	@done drop LP 3 + LP!
	;

\
\	for-each-reverse -- same as for-each, but starts at the end
\
: for-each-reverse ( seq lambda -- call lambda on each element in string,symbol,list in reverse order )
	>L dup length 1 - >L ( L0=index, L1=lambda )
	@loop
	L0 ref 0 < if >>done
	L0 ref +get L1 ref 
	call ( call lambda with element on stack )
	L0 ref 1 - L0 set! <<loop
	@done drop LP 2 + LP!
	;

\
\ like for-each, except includes index. lambda is called as:
\	: lambda ( i elem -- ) 
\
\ *NOTE* lambda CANNOT rely on the state of the stack or locals -- bind with state if 
\ data is needed other than the passed ( i elem )
\
: for-each-i ( object lambda -- )
 	>L dup length >L 0 >L ( L0=index, L1=length, L2=lambda )
	@loop ( object )
		L0 ref L1 ref >= ( obj index>=length ) if >>done 
		L0 ref +get L0 ref swap L2 ref ( obj index obj[index] lambda )
		call ( call lambda with [index element] on stack )
		L0 ref 1 + L0 set! ( ++index ) <<loop
	@done ( obj )
		drop LP 3 + LP! ( drop object, remove locals )
	;
	
\ fold - left fold
\	func: called with stack [ accum elem ] where accum is the accumulated value and
\		  elem is the next element to be added to the accumulator.
\		  func must leave updated accum on stack
\	init: initial value for accumulator
\
\ 	pseudocode:
\		acc = func(acc, seq[0])
\		acc = func(acc, seq[1])
\		.
\		acc = func(acc, seq[n-1])
: fold ( seq func init )
	\ build closure to run for each element
	\ make func into list
	swap 1 make-list
	\ FUNC will be append to left side of this
	[ self -rot ( now: acc elem FUNC )
		call self! ( make new acc and store )
	]
	+ ( [ FUNC ] + [ above ] )
	\ make into closure & keep a copy
	swap :: dup >L
	for-each
	\ leave end state on stack
	L0 ref unmake nip
	\ clean up locals
	LP 1 + LP!
	;

\
\ map - make new sequence of func[elem] for each elem in sequence
\
\ calls func as:
\	: func ( elem -- new-elem )
\
: map ( seq func )
	over list? if >>map-list
	over string? if >>map-string
	str "Bad sequence in map: " swap + error	

	@map-string
		\ string concatenation operator & initval
		'+ >L "" >L >>run
	@map-list
		\ list concatentation operator & initval
		'append >L 0 make-list >L

	@run ( seq func )
		\ function to pass to fold
		[ FUNC call CONCAT ]
		\ replace FUNC with function
		0 rot put
		\ replace CONCAT with correct operator from above
		2 L1 ref put
		\ initval
		L0 ref fold \ as above don't use [ ] here
		\ clean up locals
		LP 2 + LP!
		return \ leave filtered list on stack
	;

\
\ filter: make new sequence of only elements where func[elem] is true
\
\ calls func with elem on top of stack; func must leave true or false on stack
\
: filter ( seq func ; calls func[seq[i]] for each element )
	over list? if >>filter-list
	over string? if >>filter-string
	str "Bad sequence in filter: " swap + error	

	@filter-string
		\ string concatenation operator & initval
		'+ >L "" >L >>run
	@filter-list
		\ list concatentation operator & initval
		'append >L 0 make-list >L

	@run ( seq func )
		\ function to pass to fold
		[ dup FUNC call if >>keep drop return 
			@keep CONCAT ]
		\ replace FUNC with function
		1 rot put
		\ replace CONCAT with correct operator from above
		8 L1 ref put
		\ initval
		L0 ref fold \ as above don't use [ ] here
		\ clean up locals
		LP 2 + LP!
		return \ leave filtered list on stack
	;

\
\ take a list of tuples and makes a dictionary:
\	[ [ "foo" 123 ] [ "bar" 678 ] ] make-dict
\
: make-dict ( list-of-pairs -- dict )
	\ called as: ( dict [ key val ] )
	{ unmake drop put } ,,new-dict fold
	;

\ ( message -- ) ;  print a debug message along with the stack
: debug . .S CR ;

\ -------------------------------------------------------------------------
\
\ Stream reader
\
\ -------------------------------------------------------------------------

\ create a new stream for reading from string
: stream-reader-open-string ( string -- stream )
	\ state = [ TEXT POSITION ]
	0 2 make-list
	;

\ create a new stream for reading from file
: stream-reader-open-file ( filename -- stream )
	read-file stream-reader-open-string
	;

\ since doing a series of reads is such a common operation,
\ these functions leave the stream on the stack to avoid lots of caller dups
\ and also usually avoids drops here

\ peek next char [as string] from stream or void on eof
: stream-reader-peek-char ( stream -- stream c )
	\ POS >= length?
	dup 1 get over 0 get length >= if >>eof
	\ POS is OK
	dup 0 get over 1 get get return
	
	@eof void
	;

\ read next char [as string] from stream or void on eof
: stream-reader-next-char ( stream -- stream c )
	\ POS >= length?
	dup 1 get over 0 get length >= if >>eof
	\ POS is OK, get char
	dup 0 get over 1 get get ( stream c )
	\ ++POS
	swap dup 1 get 1 + 1 swap put ( c stream )
	swap return 

	@eof void
	;

\ skip all whitespace from current position
: stream-reader-skip-whitespace ( stream -- stream )
	@loop
		stream-reader-peek-char
		dup void? if >>done
		dup whitespace? not if >>done
		drop 
		stream-reader-next-char drop <<loop
	@done
		drop
		;

\ read word (non-whitespace chunk) from current position,
\ skipping any leading whitespace. returns void if no more words.
: stream-reader-next-word ( stream -- stream word )
	stream-reader-skip-whitespace
	"" ( stream word )
	@loop ( stream word )
		over stream-reader-next-char nip ( stream word c )
		dup void? if >>done
		dup whitespace? if >>done
		+ <<loop \ non-ws, append and continue
	@done ( stream word c )
		drop
		dup length 0 == if >>void
		return
	@void
		drop void
	;

\ get next line from reader or void
\ discards any \r or \n line ending so an empty line will return ""
\ returns void if no more lines
: stream-reader-next-line ( stream -- stream line )
	""
	@loop ( stream s )
		\ "@loop:" . .S CR
		over stream-reader-next-char nip ( stream s c )
		dup void? if >>eof
		dup ord 10 == if >>NL \ \n
		dup ord 13 == if >>CR \ \r
		+ <<loop \ normal char - append and contine
	\ this is gross but i want to be portable so check for
	\ any of: \n, \r, \r\n, \n\r
	@NL ( stream s \n )
		drop over stream-reader-peek-char nip ( stream s c )
		dup void? if >>drop-return
		dup ord 13 == if >>skip-next
		>>drop-return
	@CR ( stream s \r )
		drop over stream-reader-peek-char nip ( stream s c )
		dup void? if >>drop-return
		dup ord 10 == if >>skip-next
		>>drop-return
	@drop-return
		\ just \r or \n
		drop return
	@skip-next ( stream s c )
		\ got CR/LF pair
		\ skip next char
		drop over stream-reader-next-char drop drop return
	@eof ( stream s c )
		drop 
		\ need to distinguish eof at end of string vs. eof at start
		dup length 0 == if >>void \ no chars before eof
		return
	@void ( stream s )
		drop void
		;
		
