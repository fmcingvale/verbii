
\
\ verbii bootloader - inits interpreter and launches repl
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\

\ NOTE - only builtin words allowed here, at least in the functions
\ that init the interpreter

\ make a variable with a getter and setter:
\	'name' gets data stored in var
\	'name!' sets data stored in var
: make-var ( name initval )
	@locals [ addr ]
	1 alloc addr! \ alloc storage
	initval addr set! \ save initval
	
	\ make:
	\	name = get data @ addr
	\	name! = set data @ addr
	
	\ make word: : NAME addr ref ;
	addr 'ref 2 make-list name make-word
	\ make word: : NAME! addr set! ;
	addr 'set! 2 make-list name '! + make-word
	;

\ make a variable with only a getter so acts as a constant
\	'name' gets data stored in var
: make-const ( name initval )
	@locals [ addr ]
	1 alloc addr! \ alloc storage
	initval addr set! \ save initval
	
	\ make:
	\	name = get data @ addr
	
	\ make word: : NAME addr ref ;
	addr 'ref 2 make-list name make-word
	;
	
\ safely run currently loaded __main__ and delete it
\ ( -- )
: safe-run-and-delete-main
	\ the __main__ I'm about to run might want to redefine __main__ itself 
	\ (maybe it loads another module, etc.), so do a little trick: 
	\ first dump __main__ to a list, delete __main__, then make the dumped
	\ list into a lambda and run it
	'__main__ .dumpword
	'__main__ ,,del
	make-lambda call
	;
	
\ load .b file, run its __main__, then delete __main__
: deserialize-and-run ( filename -- )
	filename deserialize
	safe-run-and-delete-main
	;
	
'IMPORT-SEARCH-PATHS [ ] make-var

\ search IMPORT-SEARCH-PATHS for filename or fail
: find-filename-module-path ( filename -- fullname )
	@locals [ i ]
	0 i!
	@loop
		IMPORT-SEARCH-PATHS i get void? if >>not-found 
		IMPORT-SEARCH-PATHS i get file-pathsep + filename + fullname!
		fullname file-exists? if >>found 
		i 1 + i! <<loop
		
	@not-found
		"Unable to find module '" filename + "' on path " + IMPORT-SEARCH-PATHS str + error
		
	@found
		fullname
	;
	
\ add some more standard search paths, in addition to any that were passed via -libdir
\ (paths passed with -libdir are already in IMPORT-SEARCH-PATHS)
: add-standard-import-search-paths ( -- )
	@locals [ bootdir ]
	
	\ add VERBII_BOOT (*DEPRECATED* since getenv not reliable across ports ....)
	"VERBII_BOOT" os-getenv bootdir!
	bootdir void? if >>missing-bootdir 
	IMPORT-SEARCH-PATHS bootdir append
	\ add current directory as well
	os-getcwd append
	
	IMPORT-SEARCH-PATHS!
	return
	
	@missing-bootdir
		"VERBII_BOOT must be set" error
	;
	
\ assumes interpreter has just started - get init & compiler loaded
: init-interpreter ( -- )

	\ load precompiled init & compiler libraries
	"init.verb.b" find-filename-module-path deserialize-and-run
	\ "../lib/init.verb.b" deserialize-and-run 
	"compiler.verb.b" find-filename-module-path deserialize-and-run
	\ load patches file -- .verb only for now, add caching later once this is working
	
	"patches.verb" find-filename-module-path file-read
	\ compile & load words into interpreter
	true set-allow-overwrite-words
	compile-and-load-string
	\ run main & delete
	__main__ 
	'__main__ ,,del
	false set-allow-overwrite-words
	;

'*_NOCACHE false make-var

\ load filename, respecting NOCACHE setting
: load-file-maybe-cached ( filename -- )
	*_NOCACHE if >>nocache
	\ do cached load
	filename cached-compile-and-load
	return

	\ ignore any .b file - load source file and compile
	@nocache
		filename file-read
		compile-and-load-string
		;
	
'*_IMPORTED-MODULES ,,new-dict make-var

\ load & import module from either name.verb or name.verb.b
\ TODO:
\	* define library paths & add search 
\	* add way to let modules know they are being imported so they
\	  shouldn't run their main code (unless it's required to init the module of course)
\
\ ( name -- )
: import
	\ see if name has been imported already and don't import again
	*_IMPORTED-MODULES over get void? not if >>already-imported
	\ not yet imported - go ahead and mark as imported - if the below fails then 
	\ the program will crash anyways
	dup *_IMPORTED-MODULES swap true put drop
	\ import module
	".verb" +
	dup file-exists? if >>good
	"Unable to find file:" swap + error
	@good
		load-file-maybe-cached
		\ module may need to init its own globals, etc., so run it
		safe-run-and-delete-main
		return
	@already-imported ( name )
		\ "ALREADY IMPORTED:" . dup . CR
		drop
	;
	
'SCRIPT-ARGS [ ] make-var

: boot-main ( args -- )
	@locals [ i ]
	add-standard-import-search-paths
	
	\ first, must init interpreter for anything else to work
	\ (no userwords are loaded yet .. no compiler, no init lib)
	init-interpreter

		\ "AT INIT INTERPRETER, STACK:" . .S CR

	\ >L ( L1 = cmdline args -- pushed from host )
	\ [ ] >L ( L0 = new script args being built )
	[ ] SCRIPT-ARGS! \ building new script args
	0 i!
	@parse-cmdline
		args i get void? if >>done
		args i get "--" == if >>got-dashdash \ ignore everything after --
		args i get "-nocache" == if >>set-nocache
		\ keep other args
		SCRIPT-ARGS args i get append SCRIPT-ARGS!
		i 1 + i! <<parse-cmdline
	@set-nocache
		true *_NOCACHE! \ forward compat
		i 1 + i! <<parse-cmdline
	@got-dashdash
		\ NOTE: the '--' is KEPT here since repl does its own parsing
		\ so for example:
		\	verbii -nocache compile.verb -- file.verb
		\ will be passed to repl as:
		\	verbii compile.verb -- file.verb
		\ ... which is what repl would expect to see
		SCRIPT-ARGS args i -1 slice + SCRIPT-ARGS! >>done
	@done
		
	\ L> SCRIPT-ARGS!
	\ LP 1 + LP! \ drop cmdline-args from locals

		\ "FILTERED SCRIPT ARGS:" . SCRIPT-ARGS ref . CR

	"repl.verb" find-filename-module-path load-file-maybe-cached 
	safe-run-and-delete-main

	repl-main
	;

\ all code is in words except for this so that anything above can be adjusted via patches.verb
boot-main

