
\
\ Experimental verbii bootloader/repl
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\

\ NOTE - only builtin words allowed here, at least in the functions
\ that init the interpreter

\ safely run currently loaded __main__ and delete it
: safe-run-and-delete-main ( -- )
	\ the __main__ I'm about to run might want to redefine __main__ itself 
	\ (maybe it loads another module, etc.), so do a little trick: 
	\ first dump __main__ to a list, delete __main__, then run the dumped list
	'__main__ .dumpword
	del __main__
	call
	;

\ load .b file, run its __main__, then delete __main__
: deserialize-and-run ( filename -- )
	deserialize
	safe-run-and-delete-main
	;
	
\ assumes interpreter has just started - get init & compiler loaded
: init-interpreter ( -- )

	\ load precompiled init & compiler libraries
	"../lib/init.verb.b" deserialize-and-run 
	"../lib/compiler.verb.b" deserialize-and-run

	\ load patches file -- .verb only for now, add caching later once this is working
	
	"../lib/patches.verb" file-read
	\ compile & load words into interpreter
	true set-allow-overwrite-words
	compile-and-load-string
	\ run main & delete
	__main__ 
	'__main__ ,,del
	false set-allow-overwrite-words
	;
	
\ load filename, respecting NOCACHE setting
: load-file-maybe-cached ( filename -- )
	NOCACHE ref if >>nocache
	\ do cached load
	cached-compile-and-load
	return

	\ ignore any .b file - load source file and compile
	@nocache
		file-read
		compile-and-load-string
		;
	
\ load & import module from either name.verb or name.verb.b
\ TODO:
\	* define library paths & add search 
\	* add way to let modules know they are being imported so they
\	  shouldn't run their main code (unless it's required to init the module of course)
: import ( name -- )
	\ see if name has been imported already and don't import again
	\ (NOTE this is declared below like the other vars since the parser can't handle
	\ seeing it up here)
	IMPORTED_MODULES ref over get void? not if >>already-imported
	\ not yet imported - go ahead and mark as imported - if the below fails then 
	\ the program will crash anyways
	dup IMPORTED_MODULES ref swap true put drop
	\ import module
	".verb" +
	dup file-exists? if >>good
	"Unable to find file:" swap + error
	@good
		load-file-maybe-cached
		\ module may need to init its own globals, etc., so run it
		safe-run-and-delete-main
		return
	@already-imported ( name )
		\ "ALREADY IMPORTED:" . dup . CR
		drop
	;

\ first, must init interpreter for anything else to work
\ (no userwords are loaded yet .. no compiler, no init lib)
init-interpreter

\ this belongs with 'import' but again it cannot be parsed sitting up there
var IMPORTED_MODULES 1
,,new-dict IMPORTED_MODULES set!

\ this belongs with load-file-maybe-cached, but again has to sit here to be parsed
var NOCACHE 1
false NOCACHE set!

var SCRIPT_ARGS 1

[ ] >L ( L0 = new script args being built )
0 
@parse-cmdline ( i )
	dup cmdline-args length >= if >>done 
	cmdline-args over get ( i arg[i] )
		\ "BOOT ARG:" . .S CR
	dup "--" == if >>got-dashdash \ ignore everything after --
	dup "-nocache" == if >>set-nocache
	\ keep other args
	L0 ref swap append L0 set!
	1 + <<parse-cmdline
@set-nocache ( i arg[i] )
	drop
	true NOCACHE set! 1 + <<parse-cmdline
@got-dashdash ( i "--" )
	drop
	cmdline-args swap -1 slice L0 ref swap + L0 set! >>end
@done ( i )
	drop
@end
L> SCRIPT_ARGS set!

\ "FILTERED SCRIPT ARGS:" . SCRIPT_ARGS ref . CR

"../lib/repl.verb" load-file-maybe-cached 
safe-run-and-delete-main

repl-main
