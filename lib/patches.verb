\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
\ TIP: When changing compiler code, always run with -nocache flag,
\      else compiler would never run when finding .b files.

( ------ boot ----------- )
			
( ------ init ----------- )

\ create a new dictionary as one of:
\
\ 	a list of tuples and makes a dictionary:
\		[ [ "foo" 123 ] [ "bar" 678 ] ] make-dict
\		=>
\		{ "bar" => 678 "foo" => 123 }
\
\	a list of lambdas that returns ( key val ):
\		[ { "a" 10 5 + } { "b" 100 200 + } ]
\		=>
\		{ "a" => 15 "b" => 300 }
\
\	The above forms can be mixed together in the same list
\
\ treating this as experimental so not replacing make-dict yet.
: make-dict* ( pairs -- D )
	,,new-dict D!
	pairs
	{ ( item )
		item list? if >>list
		item lambda? if >>lambda
		item bound-lambda? if >>lambda
		"Bad item passed to make-dict: " item str + error
		
		@list
			D item 0 get item 1 get put D! return
		@lambda
			D item call put D! return
	} for-each
	D
	;

\ like . but without trailing space
: .. str puts ;

\ run lambda as long as test is true (test is run BEFORE lambda)
: while ( test lambda )
	@loop
		test call not if >>done
		lambda call <<loop
	@done
	;

\ similar to 'cond' in Scheme
\
\ condexprs is a list of [ { .. test .. } { .. call if true .. } ]
\ with optional element: [ null { .. call if no match .. } ] that ALWAYS matches
: cond ( condexprs -- )
	@locals [ i ]
	0 i!
	@loop
		\ end of condexprs?
		condexprs i get void? if >>nomatch
		\ [ null { ... } ]? 
		condexprs i get 0 get null == if >>match 
		\ else run test and check result
		condexprs i get 0 get call if >>match
		i 1 + i! <<loop
	@nomatch
		return \ or should it be an error to match no clauses?
	@match 
		condexprs i get 1 get call return \ call matching clause
	;
	
( ------ compiler ------- )





