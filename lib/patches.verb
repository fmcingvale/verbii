\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
\ TIP: When changing compiler code, always run with -nocache flag,
\      else compiler would never run when finding .b files.

( ------ boot ----------- )
	
( ------ init ----------- )

\ Implementation note: Many of these are written without argument lists, since they
\ are more compact/faster to write as stack operations.

\ print top of stack + space
:V2 . str puts 32 .c ;

\ actually prints LF but originally named CR so I left it
:V2 CR 10 .c ;

\ clear the stack
:V2 clear SP depth + 1 - SP! ;

\ ( a -- ) 
:V2 drop SP 1 + SP! ; 

\ ( a -- a a ) 
:V2 dup SP ref ; 

\ ( a -- a a, only if a != 0 )
:V2 dup? dup 0 == if >>ZERO dup @ZERO ; 

\ ( a b -- b a )
:V2 swap ( a b ) b a ;

\ *DEPRECATED*
\ ( Sn .. S1 i -- Sn .. S1 Si )
:V2 pick SP + ref ; 

\ ( a b -- a b a ) 
:V2 over SP 1 + ref ;
 
 \ ( a b -- a b a b ) 
:V2 2dup over over ; 

:V2 2drop ( a b -- ) ; 

\ ( a b c d -- a b c d a b ) 
:V2 2over 4 pick 4 pick ; 

\ ==============================================================================
\ FIXME -- many arglists below are gross like ( a b -- B A ) since the current
\ version of the compiler (at the time of writing this) doesn't allow dup names
\ for locals ... once i rebootstrap, fix these 
\ ==============================================================================

:V2 2swap ( a b c d -- C D A B ) c d a b ;

\ ( xn .. x1 N -- ) - drop N items
:V2 ndrop SP + 1 + SP! ;

\ ( a b -- b ) 
:V2 nip >L drop L> ;

:V2 tuck ( a b -- B A _B ) b a b ;

:V2 rot ( a b c -- B C A ) b c a ;

:V2 -rot ( b c a -- A B C ) a b c ;

\ *LOGICAL* not/and/or -- see bit-* functions for bitwise

\ ( a -- not[a] )
:V2 not if >>true true return @true false ;

\ ( a b -- a|b )
:V2 or if >>true1 if >>true2 false return @true1 drop @true2 true ;

\ ( a b -- a&b )
:V2 and if >>true1 drop false return @true1 if >>true2 false return @true2 true ;

\ ( a b -- a!=b ) 
:V2 != == not ;

:V2 >= ( a b -- a>=b ) a b > a b == or ;

:V2 < ( a b -- a<b ) b a > ;
\ ( a b -- a<=b )
:V2 <= > not ;

:V2 neg ( a -- neg[a] ) 0 a - ;
\ implementation note -- there is ZERO runtime overhead for unused locals, so
\ things like the below, where the output is called 'max[a,b]', and is never used,
\ has no performance penalty at all. taking advantage of this can make the arglists
\ more self-documenting
:V2 max ( a b -- max[a,b] ) a b > if >>A b return @A a ;
:V2 min ( a b -- min[a,b] ) a b > if >>B a return @B b ;
:V2 abs ( a -- abs[a] ) a 0 < if >>neg a return @neg a neg ;
\ 'floor' divide like in Python -- integers only )
\ ( a b -- quotient[a/b] )
:V2 // /mod swap drop ;
\ ( a b -- remainder a/b )
:V2 mod /mod drop ;

\ *DEPRECATED*
:V2 :: make-closure ;

\ .S - print stack without affecting it - good for debugging
:V2 .S "=>" . depth 
@LOOP 
	dup 0 > if >>true >>done @true dup SP + 1 + ref repr puts 32 .c 1 - <<LOOP @done drop CR ;

\ ( N -- print first N locals .. meant for debugging, like .S )
:V2 .L 
	0 ( N index )
	"Locals:" .
	@loop
		( N index )
		2dup == if >>done
		dup str "L" swap + ":" + . dup LP + ref repr puts 32 .c
		1 + <<loop
	@done 2drop
	;
	
\ *DEPRECATED* -- use make-var in new code
\ compiler turns "var NAME COUNT" into ( name count ,,var )
\ ( name count -- ; creates new variable )
:V2 ,,var 
	alloc ( name addr )
	( make word that pushes addr onto stack )
	1 make-list ( name [ addr ] )
	swap make-word
	;
	
\ *SEMI-DEPRECATED* -- named variables are much easier to use than locals, so
\ the entire locals stack may eventually go away
( shortcuts for addresses of first 10 locals )
:V2 L0 LP ;
:V2 L1 LP 1 + ;
:V2 L2 LP 2 + ;
:V2 L3 LP 3 + ;
:V2 L4 LP 4 + ;
:V2 L5 LP 5 + ;
:V2 L6 LP 6 + ;
:V2 L7 LP 7 + ;
:V2 L8 LP 8 + ;
:V2 L9 LP 9 + ;

\ same as get but leaves obj on stack
:V2 +get 
	over swap get ;
	
\ true|false if ANY member of sequence satisfies test function
:V2 any? ( sequence test -- anytrue )
	@locals [ i ]
	0 i!
	@loop
		i sequence length >= if >>noneFound \ at end of sequence
		sequence i get test call \ pass i'th item to test
		if >>gotTrue \ found a true item, done
		i 1 + i! <<loop \ else ++i and continue
	@gotTrue
		true return
	@noneFound
		false return
	;

\ true|false if ALL members of sequence satisfy test
:V2 all? ( sequence test -- alltrue )
	@locals [ i ]
	0 i!
	@loop
		i sequence length >= if >>allTrue \ end of sequence, didn't find any false
		sequence i get test call \ pass seq[i] to test
		if >>gotTrue 
		\ got one false item, so result is false
		false return
	@gotTrue
		i 1 + i! <<loop \ got true; ++i and continue
	@allTrue
		true return
	;

\ *SEMI-DEPRECATED* -- this is to support v1 closures
\ copy first nr locals into list [ LP LP+1 LP+2 ... ]
\ ( nr -- list )
:V2 copy-locals-to-list
	\ cannot use @( .. ) params since that would mess up the locals
	[ ]
	0
	@loop ( nr list i )
		dup SP 3 + ref ( nr list i i nr ) >= if >>done
		dup LP + ref ( nr list i Li )
		SP 2 + ref swap ( nr list i list Li ) append drop ( nr list i )
		1 + ( nr list i+1 ) <<loop
	@done ( nr list i )
		drop nip
	;
	
\ ========================================================================
\ String functions
\ ========================================================================

\ *TODO* rewrite more of these to take named arguments

\ *TODO* this should take a char (1-length string) instead of any string

\ ( string -- bool; is first char of string whitespace? )
:V2 whitespace?
	0 get ord ( get as ascii )
	32 <= ( treat everything <= space as whitespace )
	;

\ return string with any leading whitespace removed
\ ( string -- string )
:V2 string-ltrim 
	0
	@loop ( string i )
		2dup swap length >= ( string i i>=len ) if >>empty
		2dup get whitespace? not ( string i !ws?[string[i]] ) if >>endtrim 
		1 + <<loop
	@endtrim ( string i )
		-1 slice return
	@empty ( string i )
		drop drop "" return
	;

\ is string zero length or contain only whitespace?
\ ( string -- empty? )
:V2 string-empty?
	string-ltrim length 0 ==
	;

\ join a list of strings by separator string
\ ( list separator -- string )
:V2 string-join ( list sep )
	list
	::{ ( accum elem )
		accum length 0 == if >>skip \ skip separator before first string
		accum sep + elem + return
		@skip elem return
	} "" fold
	;
	
\ ( string -- symbol )
:V2 string->symbol 
	unmake make-symbol
	;

\ ( symbol -- string )
:V2 symbol->string 
	unmake make-string
	;

\ ( string -- ascii ; get ASCII value of first char of string )
:V2 ord 
	0 get unmake drop
	;

\ ( ASCII -- string ; turn ASCII character value into single-character string )
:V2 chr 
	1 make-string
	;

\ is c an uppercase letter?
:V2 upper? ( c ) 
	c ord 65 >= c ord 90 <= and ;
	
\ is c an uppercase letter?
:V2 lower? ( c )
	c ord 97 >= c ord 122 <= and ;
	
\ convert char c to lowercase, if it is a letter
:V2 tolower ( c -- lowercase )
	c upper? if >>is-upper
	c return \ not uppercase, return c as is
	@is-upper
		c ord 65 - 97 + chr
	;

\ convert char c to uppercase, if it is a letter
:V2 toupper ( c -- uppercase )
	c lower? if >>is-lower
	c return \ not uppercase, return call
	@is-lower
		c ord 97 - 65 + chr
	;
	
\ convert string to lowercase
:V2 string-lower ( s -- lowercase )
	s { tolower } map
	;

\ convert string to uppercase	
:V2 string-upper ( s -- lowercase )
	s { toupper } map
	;
	
\ split text into parts separated by one or more chars from delims (a string or list of chars).
\ any leading/trailing delims are trimmed. this function does NOT make empty parts.
:V2 string-split ( text delims -- parts )
	@locals [ i c piece ]
	[ ] parts!
	0 i!
	"" piece!
	@loop
		text i get c!
		c void? if >>got-end \ end of string
		delims ::{ c == } find void? not if >>got-delim \ found delimiter
		\ not a delim, add to piece
		piece c + piece! >>next
	@got-delim
		\ if i've been building a piece, add to parts and reset piece
		piece length 0 > if >>push-piece
		\ else this in the middle of other delimiters, so just keep going
		>>next
	@push-piece
		parts piece append parts!
		"" piece!
		>>next
	@next
		i 1 + i! <<loop
	@got-end
		\ if i have a piece, add it to parts
		piece length 0 == if >>done 
		parts piece append parts!
	@done
		parts
	;
	
\ ========================================================================
\ Branching
\ ========================================================================

\ calls if-true if cond is true else calls if-false
\ (cond must be a bool)
:V2 ifelse ( cond if-true if-false )
	cond if >>true
	if-false call return
	@true if-true call
	;

\ calls if-true if cond is true, else does nothing
:V2 ifthen ( cond if-true )
	cond if >>true
	return \ nothing to do on false
	@true
		if-true call
	;

( ------ compiler ------- )
	
\ objlist is normally from a [ ,,v2-closure ... ] list (with the ,,v2-closure removed)
\ plain-list is a flag that is true if objlist is from a list or false if objlist is from a lambda
\ (the difference being that plain lists are never bound to a frame since they are never called as code)
:V2 v2-compile-rewrite-args-locals ( objlist outer-env plain-list -- new-objlist nr-rewritten )
	@locals [ argnames localnames env i ]
			
			\ "* V2-rewrite-args-locals" . CR
			\ "OBJLIST:" . objlist . CR
			\ "PLAIN-LIST?:" . plain-list . CR
			
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
		
			\ "ARGS:" . argnames . CR
			\ "LOCALS:" . localnames . CR
			\ "NEW-OBJLIST:" . new-objlist . CR
		
		\ track number of var references i rewrite
		0 nr-rewritten!
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ note: i don't have to reserve space for locals -- interpreter creates frame
		\ with sufficient space, so i only have to pop args into frame ...
		
		\ make code to push args to locals (add to new-objlist)
		\ (pop in reverse order of argnames, so range starts at (#argnames-1)
		::{ ( i )
			new-objlist
				'FRAME-SET 0 i 0 make-opcode
				append drop
		} argnames length 1 - 				\ start index = #argnames-1
			-1 								\ count by -1
				argnames length for-range	\ for argnames args
		
			\ "NEW-OBJLIST:" . new-objlist . CR
		
		\ create an environment to resolve names 
		plain-list if >>make-env-plain-list
		
		\ make environment for new closure, chained to outer-env
		\ -- add args first since those are at lowest indexes
		new-closure-env env!
		\ add args first so they'll get assigned indexes starting at 0
		\ -- arg names are NOT allowed to repeat
		argnames
		::{ ( name )
			\ "ARGNAME:" . name . CR
			env name closure-env-add-name
		} for-each

		\ env argnames closure-env-add-namelist
		
		\ now @locals -- these ARE allowed to duplicate names in arglist, in which
		\ case they are ignored
		\ WHY? it seems fairly common to have arglists like:
		\		( a b -- a )
		\ where the output a is a modified version of a, for example. there is no need
		\ for a second var in these kinds of cases, and allowing the duplicated names
		\ makes function signatures cleaner for a lot of common cases
		
		\ env localnames closure-env-add-namelist
		localnames
		::{ ( name )
			\ "LOCAL NAME:" . name . CR
			env closure-env-dict name str get void? not if >>dup-name 
			\ "LOCAL ADD:" . name . CR
			env name closure-env-add-name
			@dup-name \ not an error, just ignored
		} for-each

		\ .. and chain to my outer scope
		env outer-env closure-env-set-up
		>>begin-rewrite
			\ "ENV NOW:" . env . CR
		
	@make-env-plain-list
		\ i'm rewriting a LIST not code -- list will be flattened (see below) so will
		\ run IN the outer-env, not a new environment
		outer-env env!
		\ IMPORTANT! nothing below here is allowed to modify env since that would modify
		\ outer-env incorrectly
		
	@begin-rewrite
	\ rewrite symbols using environment just created
	0 i!
	@rewrite-loop
		\ i objlist length >= if >>done 
		
			\ "OBJLIST[i]:" . objlist i get . CR
		objlist i get void? if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>list
		\ everything else, copy as-is
	@copy-element
		new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		@locals [ level index sym ]
		objlist i get sym!
		\ see if symbol is in my env or any outer scope
		env sym closure-env-lookup-name index! level!
		index void? if <<copy-element \ not in environment, so copy as is 
		\ turn symbol into get/set opcode (going along with the comment on voids above, this should
		\ never be able to add voids into the lists -- all rewriting does is turns names into
		\ FRAME-GET or FRAME-SET opcodes)
		new-objlist
			sym level index closure-env-make-ref-or-set
			append new-objlist!
		\ increment counter
		nr-rewritten 1 + nr-rewritten!
		>>next 
		
	@list			
		\ look for [ ,,v2-closure ... ] (parsed from ::{ .. })
		objlist i get 0 get ',,v2-closure == if >>rewrite-inner-closure \ got [ ,,v2-closure .. ]
		
		\ else, recurse normal list looking for names to be rewritten
		>>rewrite-inner-plain-list
		
	@rewrite-inner-closure
		@locals [ sub-objlist sub-nr-rewritten ]
			\ "REWRITE SUBLIST:" . CR
		\ call rewrite recursively with my env as the outer scope
		objlist i get 1 -1 slice \ remove ,,v2-closure
		env false v2-compile-rewrite-args-locals sub-nr-rewritten! sub-objlist!
			\ "GOT NEW SUBLIST:" . sub-objlist . CR
			\ "NEW OBJLIST:" . new-objlist . CR
		\ turn new sub-objlist back into lambda now that its rewritten and add to new-objlist
		new-objlist
			sub-objlist make-lambda append new-objlist!
		\ did i rewrite ANY names in inner closure (or any inner closures of that, etc.)
		sub-nr-rewritten 0 == if >>done-rewrite-sub 
		\ i rewrote terms, therefore this lambda needs to be bound to my (runtime) frame,
		\ so add that ...
		new-objlist 'bind-lambda append new-objlist!
		
	@done-rewrite-sub
		\ add # rewritten to my count so i return total of mine + all recursive inner lambdas
		nr-rewritten sub-nr-rewritten + nr-rewritten!
		>>next
		
	@rewrite-inner-plain-list
		@locals [ list-length ]
			\ "PLAIN LIST:" . objlist i get . CR
		\ rewrite vars inside a list without binding frame to it at runtime (since the list will
		\ be expanded, it will be filled from MY frame) -- also see code at beginning that
		\ knows not to create a new env for plain lists
		
		\ remember ORIGINAL length of list i'm about to rewrite. after rewriting i could have something like:
		\	BEFORE: [ a b [ c d [ e f ] ] ]
		\	AFTER: a b c d e f 2 make-list 3 make-list 3 make-list
		\ in other words, the inner lists have been flattened so the literal length is longer, but the
		\ RUNTIME length (i.e. for make-list) is the same -- rewriting is a 1-to-1 replacement of varnames
		\ with a single opcode, so the ending RUNTIME length will be the same.
		objlist i get length list-length!
		\ rewrite list
		objlist i get env true v2-compile-rewrite-args-locals sub-nr-rewritten! sub-objlist!
			\ "SUB RESULT:" . sub-objlist . CR
		\ did I rewrite anything?
		sub-nr-rewritten 0 == if >>plain-list-no-rewrites
		\ else, the rewrites occurred in MY ENV so flatten list so runtime references are correct
		new-objlist
			sub-objlist extend \ flatten sub-objlist into new-objlist
			\ add code to remake list at runtime -- see notes above on the length passed to make-list
			list-length append 'make-list append new-objlist!
		\ add # rewritten to my count so i return total of mine + all recursive inner lambdas
		nr-rewritten sub-nr-rewritten + nr-rewritten!
		>>next 
		
	@plain-list-no-rewrites
		\ nothing rewritten, so leave list as-is and it can be instantiated by deepcopy at runtime
		new-objlist objlist i get append new-objlist!
		
		>>next
		
	@next
		i 1 + i! <<rewrite-loop
		
	@done
		new-objlist nr-rewritten return	
		;
	
	
( ------ misc ------- )
\ "System startup time: " . run-time str . CR
