\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
\ TIP: When changing compiler code, always run with -nocache flag,
\      else compiler would never run when finding .b files.

( ------ boot ----------- )
			
( ------ init ----------- )

\ create a new dictionary as one of:
\
\ 	a list of tuples and makes a dictionary:
\		[ [ "foo" 123 ] [ "bar" 678 ] ] make-dict
\		=>
\		{ "bar" => 678 "foo" => 123 }
\
\	a list of lambdas that returns ( key val ):
\		[ { "a" 10 5 + } { "b" 100 200 + } ]
\		=>
\		{ "a" => 15 "b" => 300 }
\
\	The above forms can be mixed together in the same list
\
\ treating this as experimental so not replacing make-dict yet.
: make-dict* ( pairs -- D )
	,,new-dict D!
	pairs
	{ ( item )
		item list? if >>list
		item lambda? if >>lambda
		item bound-lambda? if >>lambda
		"Bad item passed to make-dict: " item str + error
		
		@list
			D item 0 get item 1 get put D! return
		@lambda
			D item call put D! return
	} for-each
	D
	;

\ ** this is currently named for-range, but I think for-count is more descriptive,
\ and doesn't conflict with e.g. the python idea of range()
\
\ for i=start .. start+incr*(count-1), call fn with args ( i )
\
\ note: count is used instead of an end value to simplify boundary conditions
: for-count ( fn start incr count )
	@locals [ i ]
	
	0 i!
	@loop
		count 0 <= if >>done
		\ call fn with start+i on top of stack
		i start + fn call
		i incr + i!
		count 1 - count!
		<<loop
	@done
	;

\ split text into parts separated by one or more chars from delims (a string or list of chars).
\ any leading/trailing delims are trimmed. this function does NOT make empty parts.
: string-split ( text delims -- parts )
	@locals [ i c piece ]
	[ ] parts!
	0 i!
	"" piece!
	@loop
		text i get c!
		c void? if >>got-end \ end of string
		delims c find-equal void? not if >>got-delim \ found delimiter
		\ not a delim, add to piece
		piece c + piece! >>next
	@got-delim
		\ if i've been building a piece, add to parts and reset piece
		piece length 0 > if >>push-piece
		\ else this in the middle of other delimiters, so just keep going
		>>next
	@push-piece
		parts piece append parts!
		"" piece!
		>>next
	@next
		i 1 + i! <<loop
	@got-end
		\ if i have a piece, add it to parts
		piece length 0 == if >>done 
		parts piece append parts!
	@done
		parts
	;

\ more efficient find for the common case of looking for an exact value
\	rationale: normal uses of 'find' in this case would create a bound lambda in the caller which
\		  	   is avoided by using this hardcoded test instead
\
\ find index of first item in sequence that satisfies test or void if none
: find-equal ( seq value -- index )
	0 index!
	@loop
		index seq length >= if >>not-found
		seq index get value == if >>found 
		index 1 + index! <<loop
	@found index return
	@not-found void
	;
	
\ similar to 'case' in Scheme
\	* more efficient that the more general 'cond' when matching against exact values
\
\ cases is a list of [ { key ... } { .. call if matched .. } ]
\ with optional element: [ else { .. call if no match .. } ] that ALWAYS matches
\
\ if value matches ANY of the keys in a list, then the corresponding lambda is called
\
\ it is NOT an error to not match any values
: case ( value cases -- )
	@locals [ i ]
	0 i!
	@loop
		\ end of cases?
		cases i get void? if >>nomatch
		\ [ else { ... } ]? 
		cases i get 0 get 'else == if >>match 
		\ else see if value is in list
		cases i get 0 get value find-equal void? not if >>match
		\ doesn't match, go onto next case
		i 1 + i! <<loop
	@nomatch
		return \ or should it be an error to match no clauses?
	@match 
		cases i get 1 get call return \ call matching clause
	;

\ some more sequence functions

\ return NR elements from head of sequence (i.e. NR elements starting at left)
: head ( seq nr -- list' )
	seq 0 nr slice
	;
	
\ get NR elements from tail of sequence (ie. NR elements starting at right)
: tail ( seq nr -- list' )
	seq 0 nr - nr slice
	;
	
\ get all EXCEPT the first NR elements from the left
: head-drop ( seq nr -- list' )
	seq nr -1 slice
	;

\ get all EXCEPT the last NR elements from the left	
: tail-drop ( seq nr -- list' )
	seq 0 seq length nr - slice 
	;
	
\ get str of obj with given field width, left padding with spaces and right-truncating as needed
: str.w ( obj width -- string )
	obj str string!
	@pad 
		string length width >= if >>trim
		" " string + string! <<pad
	@trim
		string length width == if >>done 
		string 1 tail-drop string! <<trim
	@done string
	;
	

( ------ compiler ------- )

\ objlist can be from a lambda or list. pass plain-list=true if objlist is from a list; false if from a lambda.
\ (the difference being that plain lists are never bound to a frame since they are never called as code)
: v2-compile-rewrite-args-locals ( objlist outer-env plain-list -- new-objlist nr-rewritten )
	@locals [ argnames localnames env i ]
			
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
		
		\ track number of var references i rewrite
		0 nr-rewritten!
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ note: i don't have to reserve space for locals -- interpreter creates frame
		\ with sufficient space, so i only have to pop args into frame ...
		
		\ make code to push args to locals (add to new-objlist)
		\ (pop in reverse order of argnames, so range starts at (#argnames-1)
		{ ( i )
			new-objlist
				'FRAME-SET 0 i 0 make-opcode
				append drop
		} argnames length 1 - 				\ start index = #argnames-1
			-1 								\ count by -1
				argnames length for-count	\ for argnames args
		
		\ create an environment to resolve names 
		plain-list if >>make-env-plain-list
		
		\ make environment for new closure, chained to outer-env
		\ -- add args first since those are at lowest indexes
		new-closure-env env!
		\ add args first so they'll get assigned indexes starting at 0
		\ -- arg names are NOT allowed to repeat
		argnames
		{ ( name )
			env name closure-env-add-name
		} for-each

		\ env argnames closure-env-add-namelist
		
		\ now @locals -- these ARE allowed to duplicate names in arglist, in which
		\ case they are ignored
		\ WHY? it seems fairly common to have arglists like:
		\		( a b -- a )
		\ where the output a is a modified version of a, for example. there is no need
		\ for a second var in these kinds of cases, and allowing the duplicated names
		\ makes function signatures cleaner for a lot of common cases
		
		\ env localnames closure-env-add-namelist
		localnames
		{ ( name )
			env closure-env-dict name str get void? not if >>dup-name 
			env name closure-env-add-name
			@dup-name \ not an error, just ignored
		} for-each

		\ .. and chain to my outer scope
		env outer-env closure-env-set-up
		>>begin-rewrite
		
	@make-env-plain-list
		\ i'm rewriting a LIST, not code -- list will be flattened (see below) so will
		\ run IN the outer-env, not a new environment
		outer-env env!
		\ IMPORTANT! nothing below here is allowed to modify env since that would modify
		\ outer-env incorrectly
		
	@begin-rewrite
	\ rewrite symbols using environment just created
	0 i!
	@rewrite-loop
		\ i objlist length >= if >>done 
		
		objlist i get void? if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>rewrite-inner-plain-list
		objlist i get lambda? if >>rewrite-inner-lambda
		\ fall through for everyting else, copy as-is
	@copy-element
		\ subtlety here: if i'm working on a plain-list, then, if it contains ANY captures (or any in
		\ ANY nested list/lambda) then it will be flattened and then remade at runtime. this means that every element
		\ in the list will be evaluated -- what i WANT to happen is for everything to be pushed to the stack,
		\ and the only things that should really be evaluated are opcodes that pull values from my frame.
		\ however, i need to quote any symbols so they will be pushed as symbols instead of run. when they are
		\ seen, the outer quoting will be removed, so when make-list runs, they will end up back in the list as
		\ intended. even though I don't know HERE whether a list will be flattened or not,
		\ i can replace them unconditionally since if the list contains no captures, this list will never
		\ be used (see below as well e.g. @plain-list-no-rewrites)
		plain-list not if >>normal-copy-element
		objlist i get symbol? not if >>normal-copy-element
			\ it is a symbol in a plain list, so add a level of quoting
			new-objlist '' objlist i get + append new-objlist! >>next
		@normal-copy-element
			\ not a symbol or not in a plain-list, so just copy as is
			new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		@locals [ level index sym ]
		objlist i get sym!
		\ see if symbol is in my env or any outer scope
		env sym closure-env-lookup-name index! level!
		index void? if <<copy-element \ not in environment, so copy as is 
		\ turn symbol into get/set opcode (tied into the comments below, this never
		\ changes the size of the list -- the symbol & the opcode that replaces it
		\ are both single objects)
		new-objlist
			sym level index closure-env-make-ref-or-set
			append new-objlist!
		\ increment counter
		nr-rewritten 1 + nr-rewritten!
		>>next 
		
	@rewrite-inner-lambda
		@locals [ sub-objlist sub-nr-rewritten ]
		\ call rewrite recursively with my env as the outer scope
		objlist i get unmake \ get lambda as list to pass
		env false v2-compile-rewrite-args-locals sub-nr-rewritten! sub-objlist!
		\ turn new sub-objlist back into lambda now that its rewritten and add to new-objlist
		new-objlist
			sub-objlist make-lambda append new-objlist!
		\ did i rewrite ANY names in inner closure (or any inner closures of that, etc.)
		sub-nr-rewritten 0 == if >>done-rewrite-sub 
		\ i rewrote terms, therefore this lambda needs to be bound to my (runtime) frame,
		\ so add that ...
		new-objlist 'bind-lambda append new-objlist!
		
	@done-rewrite-sub
		\ add # rewritten to my count so i return total of mine + all recursive inner lambdas
		nr-rewritten sub-nr-rewritten + nr-rewritten!
		>>next
		
	@rewrite-inner-plain-list
		@locals [ list-length ]
		\ rewrite vars inside a list without binding frame to it at runtime (since the list will
		\ be expanded, it will be filled from MY frame) -- also see code at beginning that
		\ knows not to create a new env for plain lists
		
		\ remember ORIGINAL length of list i'm about to rewrite. after rewriting i could have something like:
		\	BEFORE: [ a b [ c d [ e f ] ] ]
		\	AFTER: a b c d e f 2 make-list 3 make-list 3 make-list
		\ in other words, the inner lists have been flattened so the literal length is longer, but the
		\ RUNTIME length (i.e. for make-list) is the same -- rewriting is a 1-to-1 replacement of varnames
		\ with a single opcode, so the final RUNTIME length will be the same.
		objlist i get length list-length!
		\ rewrite list
		objlist i get env true v2-compile-rewrite-args-locals sub-nr-rewritten! sub-objlist!
		\ did I rewrite anything?
		sub-nr-rewritten 0 == if >>plain-list-no-rewrites
		\ else, the rewrites occurred in MY ENV so flatten list so runtime references are correct
		new-objlist
			sub-objlist extend \ flatten sub-objlist into new-objlist
			\ add code to remake list at runtime -- see notes above on the length passed to make-list
			list-length append 'make-list append new-objlist!
		\ add # rewritten to my count so i return total of mine + all recursive inner lambdas
		nr-rewritten sub-nr-rewritten + nr-rewritten!
		>>next 
		
	@plain-list-no-rewrites
		\ nothing rewritten, so leave list as-is and it can be instantiated by deepcopy at runtime
		new-objlist objlist i get append new-objlist!
		
		>>next \ just to be clear ...
		
	@next
		i 1 + i! <<rewrite-loop
		
	@done
		new-objlist nr-rewritten return	
		;

	

	
	

	
		 



