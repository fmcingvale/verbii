(
	Patches file, loaded at startup.

	The load order is:
		init.verb.b 
		compiler.verb.b 
		patches.verb 

	The words defined in patches.verb will overwrite any words of the same name
	defined in init.verb.b or compiler.verb.b. (Normally overwriting words is
	not allowed, to avoid subtle bugs.)

	The patches file provides a safe way to modify init.verb/compiler.verb without
	replacing their .b files, which could easily break the entire system. Once changes
	are thoroughly tested via patches.verb, then they can be safely moved into init.verb
	or compiler.verb.

	Copyright (c) 2022 Frank McIngvale, see LICENSE
)

( ------ init ----------- )

( ------ compiler ------- )

\
\ general note for below: for consistency, when there is no return value due to EOF,
\ void is returned. although technically only a few places need to distinguish null from void,
\ using void throughout I think will be less confusing in the long run
\

: reader-peek-char ( -- char; get next char [string] from reader without advancing stream )
	READER_POS ref READER_TEXT_LEN ref >= if >>eof
	READER_TEXT ref READER_POS ref get ( char )
	return
	@eof 
		void \ return void on eof
	;

: reader-next-char ( -- char; get next char [string] from reader stream or void on eof )
	READER_POS ref READER_TEXT_LEN ref >= if >>eof
	READER_TEXT ref READER_POS ref get ( char )
	READER_POS ref 1 + READER_POS set! ( char; ++pos )
	return
	@eof
		void
	;

: reader-next-chunk ( -- next string of either all whitespace or non-whitespace )
		\ "reader-next-chunk" . CR
	"" ( string )
	\ see what next chunk starts with ...
	reader-peek-char
	dup void? if >>drop-return
	dup whitespace? if >>ws 
	\ else, non-whitespace
	drop
	@non-ws-loop ( string )
	reader-peek-char ( if next is whitespace, do NOT want to read it )
	dup void? if >>drop-return
	dup whitespace? if >>drop-return
	drop reader-next-char + <<non-ws-loop ( append to string and continue )

	\ read whitespace chunk
	@ws
	drop
	@ws-loop ( string )
	reader-peek-char
	dup void? if >>drop-return
	dup whitespace? not if >>drop-return
	drop reader-next-char + <<ws-loop

	@drop-return ( string char )
		drop return
	;

: reader-next ( -- symbol ; get next word from reader stream, or void on eof )
	"" ( word )
	@skipws ( skip leading whitespace )
		reader-peek-char
		dup void? if >>void-on-read 
		ord 32 > if >>word-loop
		reader-next-char ( word char; ++pos )
		drop
		<<skipws

	@void-on-read ( word void )
		drop >>eof

	@word-loop ( word )
		( i want to preserve any whitespace after word [e.g. for string parsing], so peek first )
		reader-peek-char ( word char )
		dup void? if <<void-on-read
		( check for whitespace )
		dup ord 32 <= if >>space  ( treat anything from ' ' to NUL as whitespace )
		( not whitespace, read char, append and continue )
		drop reader-next-char + <<word-loop

	@space ( word char )
		drop ( fall through to return word below )

	@eof ( word ) 
		( return word, void on end of file )
		dup length 0 == if >>isvoid
		string->symbol return ( return word as symbol )

	@isvoid drop void return
	;

: syntax-next ( convert next word from input to runnable object )
	reader-next
		\ "syntax-next:" . dup . CR
	dup void? if >>void
	dup '( == if >>comment
	dup '\ == if >>line-comment
	dup '{ == if >>lambda
	dup '[ == if >>list
	dup ': == if >>worddef
	dup 'def == if >>worddef ( synonym for ':' )
	dup 'var == if >>var
	dup 'del == if >>del
	dup 'true == if >>true-literal
	dup 'false == if >>false-literal
	\ don't do null yet since null is used as a meaninful return value -- need
	\ to change those to use void instead

	( look for triple-quoted string first )
	dup 0 3 slice TRIPLEQUOTE ref == if >>triplestring
	( now single quoted string )
	dup 0 get '" == if >>string ( "... )
	( test for correct format before passing to parse-int or parse-float since those functions
	  will happily parse something like "123abc" as 123 )
	dup int-symbol? if >>integer
	dup float-symbol? if >>float
	dup 0 get '# != if >>nomatch dup 1 -1 slice float-symbol? if >>float-literal
	@nomatch
		( leave unprocessed word on stack )
		return
	@void
		return ( leave void on stack )
	@worddef
		drop syntax-define-word return
	@var
		drop syntax-var return
	@del
		drop syntax-del return
	@comment
		drop syntax-comment syntax-next return ( skip comment and return NEXT object )
	@line-comment
		drop syntax-line-comment syntax-next return ( skip comment and return NEXT object )
	@lambda
		drop syntax-lambda return
	@list
		drop syntax-list return
	@triplestring
		( call syntax-triple-string with first piece on stack )
		syntax-triple-string return
	@string
		( call syntax-string with first piece on stack )
		syntax-string return
	@integer
		parse-int return
	@float
		parse-float return
	@float-literal ( #NN.NN form )
		1 -1 slice parse-float return
	@true-literal parse-bool return
	@false-literal parse-bool return
	;

: syntax-define-word
	syntax-next ( name should be next )
	dup symbol? not if >>badname
	>L SP >L   ( L0=starting SP, L1=name )
	@loop
	syntax-next ( get next processed object - assume it can be more than 1 object )
	dup void? if >>eof
	dup '; == if >>endword
	<<loop
	@badname str "Invalid name after ':' : " swap + error
	@eof "Unexpected end of input looking for ';'" error
	@endword
	drop ( drop ; )
	L> SP - 1 - ( calc number of items )
	make-list
	L> 
	( save names & compiled words )
	save-defined-word
	syntax-next ( save-defined-word has no return value, so return NEXT object )
	;

: syntax-string ( first string part already on stack *as symbol* )
	( convert first since reader-next-char returns strings )
	symbol->string
		
	( see if first string part ends with " )
	dup -1 get ord 34 == ( use ascii value for " )
		over length 1 >
		and
		if >>endstring ( first part begins and ends with " so string is complete )

	( now switch to character mode to preserve all inner whitespace )
	@loop ( string )
		reader-next-char ( string char )
		dup void? if >>eof ( EOF in string, error )
		dup ord 34 == if >>quote ( test against ASCII value for " to avoid any parsing weirdness )
		( else, append regular char to string )
		+ <<loop
		
	@quote ( string " )
		+ ( append " to string )

		( if whitespace is next, then string is complete )
		reader-peek-char
		dup void? if >>endquote ( EOF ok AFTER end quote )
		dup whitespace? if >>endquote
		( else, keep reading more )
		drop <<loop

	@endquote drop >>endstring

	@eof ( string char ) 
		drop "Unexpected end of input inside string: " swap + error

	@endstring ( string -- string without quotes )
		dup length 2 - 1 swap slice ( remove quotes )
	;

: syntax-triple-string ( first-piece-symbol -- string )
	\ convert to string first ...
	symbol->string
	\ special case of only one piece ... """..."""
	dup length 6 >=
	over -3 -1 slice TRIPLEQUOTE ref symbol->string == and if >>return

	\ else, keep first-piece on stack and add more chunks until i find one
	\ that ends in """
	@read-loop
		reader-next-chunk
		dup void? if >>error-eos
		+
		dup -3 -1 slice TRIPLEQUOTE ref symbol->string == if >>return
		<<read-loop

	@error-eos
		"String ended inside triple-quoted string: " swap + error

	@return ( remove triple quotes from both sides )
		dup length 3 swap 6 - slice
	;

: syntax-lambda ( assumes { was just read & dropped )
	0 make-list 
	@loop
		\ note - any inner lambdas will be handled automatically by syntax-next,
		\ so don't have to check for "{" here
		syntax-next
		dup void? if >>eof
		dup '} == if >>closebrace
		append ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside { .. }" error
	@closebrace
		drop make-lambda return
		;

: syntax-list ( assumes [ was just read & dropped )
	0 make-list 
	@loop ( list )
		\ note - any inner lists/lambdas will be handled automatically by syntax-next,
		\ so don't have to check for { or [ here
		syntax-next
		dup void? if >>eof
		dup '] == if >>closelist
		append ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside [ .. ]" error
	@closelist
		drop
		;

: syntax-comment ( assumes open paren just read )
	"" >L 1 >L ( L0 = nesting, L1 = comment text )
	@loop
		reader-next ( puts symbol on stack )
		dup void? if >>eof
		( add to comment text )
		dup symbol->string L1 ref " " + swap + L1 set! 

		dup ') == if >>closeparen
		dup '( == if >>openparen
		drop <<loop ( discard and continue )
	@closeparen
		LP ref 1 - LP set!
		LP ref 0 == if >>end
		drop <<loop
	@openparen
		LP ref 1 + LP set!
		drop <<loop
	@end
		LP 2 + LP! ( clean up locals )
		drop return
	@eof
		L1 ref 0 40 slice
		"Unexpected end of input inside comment: " swap + error
	;
	
: syntax-line-comment ( assumes "\" was just read )
	( read *characters* until EOL found )
	@loop
		reader-next-char
		( if end of stream, "\n" or "\r", then i'm done )
		dup void? if >>eol
		dup ord 13 == if >>eol
		dup ord 10 == if >>eol
		drop <<loop ( discard char and continue )
	@eol
		drop ( discard char and return )
	;

: byte-compile ( -- names wordlists ; byte-compile source from current reader stream )
	( do NOT store compiled words into interpreter since that would prevent compiling
	  any code that contained a name that was already defined -- for example when
	  compiling this file
	
	  instead, store as a list of [name,wordlist]
	)
	\ var COMPILED_NAMELISTS 1
	0 make-list COMPILED_NAMELISTS set!

	( i need to count the number of parsed words that DID NOT go into COMPILED_NAMELISTS, so
	  save starting SP so I can count at the end )
	SP >L ( L0=SP at start )
	@loop
	( read all parsed objects then make into a list )
	syntax-next
	dup void? if >>done 
	dup list? if >>list
	<<loop
	@list
	\ check for [ ,,inline ... ] and flatten
	dup length 0 == if <<loop
	dup 0 get ',,inline == if >>flatten
	<<loop
	@flatten
		1 -1 slice unmake drop <<loop
	@done
	drop
	( count # items added to stack and make list )
	L> SP - 1 - make-list
	( save this code under __main__ )
	'__main__ save-defined-word
	( leave list of [ name list ] on stack )
	COMPILED_NAMELISTS ref
	( remove vars so compiler can be run again )
	\ del COMPILED_NAMELISTS
	;

( ------ misc ------- )
\ "System startup time: " . run-time str . CR