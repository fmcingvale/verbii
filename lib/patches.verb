\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
\ TIP: When changing compiler code, always run with -nocache flag,
\      else compiler would never run when finding .b files.

( ------ boot ----------- )
	
( ------ init ----------- )
	
\ is first char of string whitespace?
: whitespace? ( c -- result )
	IF c string? c symbol? or THEN
		c 0 get ord \ get as ascii 
		32 <= \ treat everything <= space as whitespace )
	ELSE
		false \ non-string, void, etc.
	END
	;

( ------ compiler ------- )

\ get next char [string] from reader without advancing stream
: reader-peek-char ( -- char )
	IF READER-POS READER-TEXT-LEN >= THEN
		void \ return void on eof
	ELSE
		READER-TEXT READER-POS get \ return char on stack
	END
	;
	
\ get next char [string] from reader stream or void on eof
: reader-next-char ( -- char )
	IF READER-POS READER-TEXT-LEN >= THEN
		void \ return void on eof
	ELSE
		READER-TEXT READER-POS get \ return char on stack
		READER-POS 1 + READER-POS!
	END
	;
	
\ get next string of either all whitespace -OR- non-whitespace
: reader-next-chunk ( -- chunk )
		\ "reader-next-chunk" . CR
	@locals [ c ]
	"" chunk!
	\ see what next chunk starts with ...
	reader-peek-char c!
	IF c void? THEN
		void return
	ELIF c whitespace? THEN
		\ read whitespace chunk
		WHILE true DO
			reader-peek-char c!
			\ if next is non-whitespace or void, then end whitespace chunk and return
			IF c void? c whitespace? not or THEN
				chunk return
			\ else append char to chunk and continue
			ELSE
				chunk reader-next-char + chunk!
			END
		END
	\ else, read non-whitespace chunk
	ELSE
		WHILE true DO
			reader-peek-char c!
			\ if next is whitespace or void, then end whitespace chunk and return
			IF c void? c whitespace? or THEN
				chunk return
			\ else append char to chunk and continue
			ELSE
				chunk reader-next-char + chunk!
			END
		END
	END
	;

\ skip any whitespace from current position in reader input
: reader-skip-whitespace ( -- )
	@locals [ c ]
	WHILE true DO
		reader-peek-char c!
		IF c void? THEN return
		ELIF c ord 32 > THEN return \ non-whitespace is next char
		ELSE reader-next-char drop
		END
	END
	;
	
\ get next non-whitespace chunk from reader stream (as a symbol), or void on eof
: reader-next ( -- symbol )
	@locals [ c ]
	\ skip leading whitespace
	reader-skip-whitespace
	\ get next non-whitespace chunk
	"" symbol!
	WHILE true DO
		\ i want to preserve any whitespace after word [e.g. for string parsing], so peek first
		reader-peek-char c!
		IF c void? THEN >>return-chunk
		ELIF c ord 32 <= THEN >>return-chunk
		\ not whitespace/EOF, append char to chunk and continue
		ELSE symbol reader-next-char + symbol!
		END
	END
	
	@return-chunk
		\ "RETURN-NEXT RETURNS:" . symbol . CR
		IF symbol length 0 == THEN void return \ got no input, so treat as EOF
		ELSE symbol string->symbol return
		END
	;

\ is single char (string|symbol) a digit?
: digit? ( char -- result )
	IF char string? THEN char "0" >= char "9" <= and return
	ELIF char symbol? THEN char '0 >= char '9 <= and return
	ELSE "digit? requires string or symbol but got:" char str + error
	END
	;
	
\ if char is at start of string, remove it
: ltrim-char ( string char -- string )
	IF string 0 get char == THEN
		string 1 -1 slice
	ELSE
		string
	END
	;
	
\ remove "+" or "-" from start of string (max 1 removal)
: ltrim-sign ( string -- string )
	IF string 0 get "+" == string 0 get "-" == or THEN
		string 1 -1 slice
	ELSE
		string
	END
	;
	
\ remove all leftmost digits from string
: ltrim-digits ( string -- string )
	WHILE string length 0 > DO
		IF string 0 get digit? not THEN string return \ no more digits on left side
		ELSE string 1 -1 slice string! \ remove first char (which is a digit) and continue
		END
	END
	string return \ empty string
	;
	
\ true|false if string can be parsed as integer (i.e. a call to parse-int would succeed)
: int-string? ( string -- result )
	IF string any-digits? not THEN false return \ no digits in string, so cannot be an int
	ELSE
		string ltrim-sign
			ltrim-digits \ chain operations
			length 0 == return \ if removing +/- then digits yields an empty string, then it is an integer
	END
	;
	
\ true|false if string can be parsed as float (i.e. a call to parse-float would succeed)
: float-string? ( string -- result )
	\ NOTE - this will ALSO match integers, so use int-string? first to rule those out
	IF string any-digits? not THEN false return \ must have digits, not just +/-/./e
	ELSE
		\ remove expected portions then see if i end up with an empty string
		string ltrim-sign
			ltrim-digits
			"." ltrim-char
			ltrim-digits
			"e" ltrim-char
			"E" ltrim-char
			ltrim-sign
			ltrim-digits
			length 0 == return
	END
	;
	
\ unused function, can remove
'dict-add-indexed-names ,,del

\ ( first-piece-symbol -- string )
: syntax-triple-string ( piece -- out )
	@locals [ chunk ]
		\ "SYNTAX-TRIPLE-STRING - INIT:" . piece . CR
	\ convert to string first ...
	piece symbol->string piece!
	\ special case of only one piece ... """..."""
	IF 	piece length 6 >=
		piece -3 -1 slice TRIPLEQUOTE symbol->string == and THEN
		\ "\ GOT SINGLE CHUNK" . CR
		>>return
	END
	\ else, add chunks until i find one that ends in """
	WHILE true DO
		reader-next-chunk chunk!
			\ "GOT NEXT CHUNK:" . chunk . CR
		IF chunk void? THEN
			"String ended inside triple-quoted string: " piece str + error
		ELSE
			piece chunk + piece!
		END
		\ does piece end with """ now?
		IF piece -3 -1 slice TRIPLEQUOTE symbol->string == THEN
			>>return
		END
	END
	
	@return ( remove triple quotes from both sides )
		piece piece length 3 swap 6 - slice
	;

\ assumes [ was just read & dropped
: syntax-list
	0 make-list 
	@loop ( list )
		\ note - any inner lists/lambdas will be handled automatically by syntax-next,
		\ so don't have to check for { or [ here
		syntax-next
			\ "SYNTAX-LIST GOT NEXT:" . dup . CR
		dup void? if >>eof
		dup '] == if >>closelist
		dup is-inline-list? if >>inline-list 
		\ anything else, append to list and continue
		append <<loop
	@eof ( list void )
		"Unexpected end of input inside [ .. ]" error
	@inline-list ( list inline-list )
		\ got [ ,,inline elem ... ] -- add elements inline instead of appending as a list 
		\ remove ,,inline 
		1 -1 slice extend <<loop
	@closelist ( list '] )
		drop
		;

\ parse next word from input into runnable object
: syntax-next ( -- obj )
	@locals [ word ]
	reader-next word!
		\ "syntax-next word:" . word . CR
	IF word void? THEN void return
	ELIF word '( == THEN \ ) <- to fix syntax highlighting here
		syntax-comment syntax-next return \ skip comment and return NEXT object
	ELIF word '\ == THEN
		syntax-line-comment syntax-next return \ skip comment and return NEXT object
	ELIF word '{ == THEN
		syntax-v2-closure return
	ELIF word '[ == THEN
		syntax-list return
	ELIF word '#op( == THEN \ )
		syntax-opcode return
	ELIF word ': == THEN
		v2-syntax-define-word return
	ELIF word 'del == THEN
		syntax-del return
	ELIF word 'true == THEN 
		true return
	ELIF word 'false == THEN
		false return
	ELIF word 'null == THEN
		null return
	ELIF word 'WHILE == THEN
		syntax-while return
	ELIF word 'IF == THEN
		syntax-if return
	( look for triple-quoted string first )
	ELIF word 0 3 slice TRIPLEQUOTE == THEN
		\ "GOT TRIPLEQUOTE START:" . word . CR
		\ call syntax-triple-string with first piece on stack
		word syntax-triple-string return
	( now single quoted string )
	ELIF word 0 get '" == THEN \ "... <- fix syntax highlighting here
		( call syntax-string with first piece on stack )
		word syntax-string return
	\ test for correct format before passing to parse-int or parse-float since those functions
	\ may (depending on platform) happily parse something like "123abc" as 123 
	ELIF word int-symbol? THEN
		word parse-int return
	ELIF word float-symbol? THEN
		word parse-float return
	ELIF word 0 get '# ==
			word 1 -1 slice float-symbol? and THEN
		word 1 -1 slice parse-float return
	ELSE
		\ "RET PLAIN WORD:" . word . CR
		\ no match, return unprocessed word
		word return
	END
	;

\ objlist can be from a lambda or list. pass plain-list=true if objlist is from a list; false if from a lambda.
\ (the difference being that plain lists are never bound to a frame since they are never called as code)
\
\ max-frame-level is the maximum frame level (from i.e. OP-FRAME-GET) that is required to resolve rewritten
\ references. so i.e. if max-level == 0, then the rewritten objlist only accesses its only locals and doesn't
\ need to be bound to an outer frame at runtime.
\
\ *NOTE* a value of -1 for max-frame-level means NOTHING was rewritten.
: v2-compile-rewrite-args-locals ( objlist outer-env plain-list -- new-objlist max-frame-level )
	@locals [ argnames localnames env i ]
			
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
		
		\ track max frame level required (set to -1 so i can tell later if i rewrote anything)
		-1 max-frame-level!
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ note: i don't have to reserve space for locals -- interpreter creates frame
		\ with sufficient space, so i only have to pop args into frame ...
		
		\ make code to push args to locals (add to new-objlist)
		\ (pop in reverse order of argnames, so range starts at (#argnames-1)
		{ ( i )
			new-objlist
				'FRAME-SET 0 i 0 make-opcode
				append drop
		} argnames length 1 - 				\ start index = #argnames-1
			-1 								\ count by -1
				argnames length for-count	\ for argnames args
		
		\ create an environment to resolve names 
		plain-list if >>make-env-plain-list
		
		\ make environment for new closure, chained to outer-env
		\ -- add args first since those are at lowest indexes
		new-closure-env env!
		\ add args first so they'll get assigned indexes starting at 0
		\ -- arg names are NOT allowed to repeat
		argnames
		{ ( name )
			env name closure-env-add-name
		} for-each

		\ env argnames closure-env-add-namelist
		
		\ now @locals -- these ARE allowed to duplicate names in arglist, in which
		\ case they are ignored
		\ WHY? it seems fairly common to have arglists like:
		\		( a b -- a )
		\ where the output a is a modified version of a, for example. there is no need
		\ for a second var in these kinds of cases, and allowing the duplicated names
		\ makes function signatures cleaner for a lot of common cases
		
		\ env localnames closure-env-add-namelist
		localnames
		{ ( name )
			env closure-env-dict name str get void? not if >>dup-name 
			env name closure-env-add-name
			@dup-name \ not an error, just ignored
		} for-each

		\ .. and chain to my outer scope
		env outer-env closure-env-set-up
		>>begin-rewrite
		
	@make-env-plain-list
		\ i'm rewriting a LIST, not code -- list will be flattened (see below) so will
		\ run IN the outer-env, not a new environment
		outer-env env!
		\ IMPORTANT! nothing below here is allowed to modify env since that would modify
		\ outer-env incorrectly
		
	@begin-rewrite
	\ rewrite symbols using environment just created
	0 i!
	@rewrite-loop
		\ i objlist length >= if >>done 
		
		objlist i get void? if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>rewrite-inner-plain-list
		objlist i get lambda? if >>rewrite-inner-lambda
		\ fall through for everyting else, copy as-is
	@copy-element
		\ subtlety here: if i'm working on a plain-list, then, if it contains ANY captures (or any in
		\ ANY nested list/lambda) then it will be flattened and then remade at runtime. this means that every element
		\ in the list will be evaluated -- what i WANT to happen is for everything to be pushed to the stack,
		\ and the only things that should really be evaluated are opcodes that pull values from my frame.
		\ however, i need to quote any symbols so they will be pushed as symbols instead of run. when they are
		\ seen, the outer quoting will be removed, so when make-list runs, they will end up back in the list as
		\ intended. even though I don't know HERE whether a list will be flattened or not,
		\ i can replace them unconditionally since if the list contains no captures, this list will never
		\ be used (see below as well e.g. @plain-list-no-rewrites)
		plain-list not if >>normal-copy-element
		objlist i get symbol? not if >>normal-copy-element
			\ it is a symbol in a plain list, so add a level of quoting
			new-objlist '' objlist i get + append new-objlist! >>next
		@normal-copy-element
			\ not a symbol or not in a plain-list, so just copy as is
			new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		@locals [ level index sym ]
		objlist i get sym!
		\ see if symbol is in my env or any outer scope
		env sym closure-env-lookup-name index! level!
		index void? if <<copy-element \ not in environment, so copy as is 
		\ turn symbol into get/set opcode (tied into the comments below, this never
		\ changes the size of the list -- the symbol & the opcode that replaces it
		\ are both single objects)
		new-objlist
			sym level index closure-env-make-ref-or-set
			append new-objlist!
		\ remember max level so i can tell at the end if I need to be bound to an outer frame
		max-frame-level level max max-frame-level!
		>>next 
		
	@rewrite-inner-lambda
		@locals [ sub-objlist sub-max-frame-level ]
		\ call rewrite recursively with my env as the outer scope
		objlist i get unmake \ get lambda as list to pass
		env false v2-compile-rewrite-args-locals sub-max-frame-level! sub-objlist!
		\ turn new sub-objlist back into lambda now that its rewritten and add to new-objlist
		new-objlist
			sub-objlist make-lambda append new-objlist!
		\ does rewritten code require any vars from my (or higher) frames? 
		sub-max-frame-level 0 <= if >>done-rewrite-sub \ max level == 0 means it only needs its locals (-1 means it needs NO vars)
		\ this lambda requires values from my (or higher) frames, so needs to be bound to my
		\ runtime frame ...
		new-objlist 'bind-lambda append new-objlist!
		
	@done-rewrite-sub
		\ several subtleties here -- i might never use any values from a higher frame, but have a sub-lambda that does so,
		\ so i need to take sub-max-frame into account. NOTE -- since i am 1 level up, i subtract 1 from sub-max-level 
		\ (i.e. a sub-lambda requiring a value 2 frames up is only 1 frame up for me, so should be counted that way ... 
		\ so if sub-max is 1 for example, *I* do not need to be bound to an outer frame since those are my locals.
		\
		\ HOWEVER, once the level is >= 0, NEVER decrease it below 0 since that would then be mistaken for meaning nothing was
		\ rewritten -- in the case of lists, that would mean the original lists are deepcopied instead of the replacement
		\ list being used, so lambdas inside a list would never be transformed correctly.
		\
		\ note that this does not harm the optimization at all, since level=0 means only locals are used, so this does not
		\ cause any lambdas to be bound unnecessarily.
		IF sub-max-frame-level 0 > THEN
			max-frame-level sub-max-frame-level 1 - max max-frame-level!
		ELSE
			max-frame-level sub-max-frame-level max max-frame-level!
		END
		>>next
		
	@rewrite-inner-plain-list
		@locals [ list-length ]
		\ rewrite vars inside a list without binding frame to it at runtime (since the list will
		\ be expanded, it will be filled from MY frame) -- also see code at beginning that
		\ knows not to create a new env for plain lists
		
		\ remember ORIGINAL length of list i'm about to rewrite. after rewriting i could have something like:
		\	BEFORE: [ a b [ c d [ e f ] ] ]
		\	AFTER: a b c d e f 2 make-list 3 make-list 3 make-list
		\ in other words, the inner lists have been flattened so the literal length is longer, but the
		\ RUNTIME length (i.e. for make-list) is the same -- rewriting is a 1-to-1 replacement of varnames
		\ with a single opcode, so the final RUNTIME length will be the same.
		objlist i get length list-length!
		\ rewrite list
		objlist i get env true v2-compile-rewrite-args-locals sub-max-frame-level! sub-objlist!
		\ did I rewrite anything?
		sub-max-frame-level 0 < if >>plain-list-no-rewrites
		\ else, the rewrites occurred in MY ENV so flatten list so runtime references are correct
		new-objlist
			sub-objlist extend \ flatten sub-objlist into new-objlist
			\ add code to remake list at runtime -- see notes above on the length passed to make-list
			list-length append 'make-list append new-objlist!
		\ like above, i need to account for sub-max-frame-level in my max-frame-level.
		\ *UNLIKE* above, the rewrites occurred in MY frame, so I do NOT subtract 1 as i did above
		max-frame-level sub-max-frame-level max max-frame-level!
		>>next 
		
	@plain-list-no-rewrites
		\ nothing rewritten, so leave list as-is and it can be instantiated by deepcopy at runtime
		new-objlist objlist i get append new-objlist!
		
		>>next \ just to be clear ...
		
	@next
		i 1 + i! <<rewrite-loop
		
	@done
		new-objlist max-frame-level return	
		;
		
\ take a parsed objlist, presumably from byte-compile, and perform finalization:
\	* transform @args [ .. ] and @locals [ .. ] into code and handles closure creation
\
\ returns a new list, does NOT modify objlist
: compile-finalize-word ( objlist -- newlist )
	\ always a toplevel function - no outer environment
	objlist void false v2-compile-rewrite-args-locals
	drop \ don't need max-frame-level here; top level functions cannot have outer frames by definition
	\ now that all the rewriting above is done, can replace << and >> with jump opcodes
	compiler-optimize-jumps
	return \ return new objlist
	;
