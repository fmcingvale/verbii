\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
( ------ boot ----------- )

: boot-main
	\ first, must init interpreter for anything else to work
	\ (no userwords are loaded yet .. no compiler, no init lib)
	init-interpreter

		\ "AT INIT INTERPRETER, STACK:" . .S CR

	\ *VERY BAD VERBII STYLE HERE* ... out of necessity
	\ (1) vars should not be declared inside a function
	\		* since boot-main only runs once, it's ok here
	\ (2) they are out of place .. see below

	\ this belongs with 'import' but again it cannot be parsed sitting up there
	var IMPORTED_MODULES 1
	,,new-dict IMPORTED_MODULES set!

	\ this belongs with load-file-maybe-cached, but again has to sit here to be parsed
	var NOCACHE 1
	false NOCACHE set!

	\ args that get passed to repl (and on to other scripts after that)
	var SCRIPT-ARGS 1

	>L ( L1 = cmdline args -- pushed from host )
	[ ] >L ( L0 = new script args being built )
	0 
	@parse-cmdline ( i )
		dup LP 1 + ref length >= if >>done 
		LP 1 + ref over get ( i arg[i] )
			\ "BOOT ARG:" . .S CR
		dup "--" == if >>got-dashdash \ ignore everything after --
		dup "-nocache" == if >>set-nocache
		\ keep other args
		LP ref swap append LP set!
		1 + <<parse-cmdline
	@set-nocache ( i arg[i] )
		drop
		true NOCACHE set! 1 + <<parse-cmdline
	@got-dashdash ( i "--" )
		drop
		LP 1 + ref swap -1 slice LP ref swap + LP set! >>end
	@done ( i )
		drop
	@end
	L> SCRIPT-ARGS set!
	LP 1 + LP! \ drop cmdline-args from locals

		\ "FILTERED SCRIPT ARGS:" . SCRIPT-ARGS ref . CR

	"../lib/repl.verb" load-file-maybe-cached 
	safe-run-and-delete-main

	repl-main
	;

( ------ init ----------- )

( ------ compiler ------- )
	

\ parse ( ... ) comment, with nesting. assumes "(" was just read.
: syntax-comment
	@locals [ nesting comment-text ]
	"" comment-text!
	1 nesting!
	@loop
		reader-next ( puts symbol on stack )
		dup void? if >>eof
		( add to comment text )
		dup symbol->string comment-text " " + swap + comment-text! 

		dup ') == if >>closeparen
		dup '( == if >>openparen \ ) <- to stop notepad++ highlighter from messing up
		drop <<loop ( discard and continue )
	@closeparen
		nesting 1 - nesting!
		nesting 0 == if >>end
		drop <<loop
	@openparen
		nesting 1 + nesting!
		drop <<loop
	@end
		drop return
	@eof
		comment-text 0 40 slice
		"Unexpected end of input inside comment: " swap + error
	;
	
: byte-compile ( -- names wordlists ; byte-compile source from current reader stream )
	\ do NOT store compiled words into interpreter since that would prevent compiling
	\  any code that contained a name that was already defined -- for example when
	\  compiling this file
	\
	\ instead, store as a list of [name,wordlist] to COMPILED_NAMELISTS

	0 make-list COMPILED_NAMELISTS set!

	\ i need to count the number of parsed words that DID NOT go into COMPILED_NAMELISTS, so
	\ save starting SP so I can count at the end
	SP >L ( L0=SP at start )
	@loop
	( read all parsed objects then make into a list )
	syntax-next
	dup void? if >>done 
	dup list? if >>list
	<<loop
	@list
	\ **TODO** change this to use flatten-if-inline
	\ check for [ ,,inline ... ] and flatten
	flatten-if-inline <<loop
	@done
	drop
	( count # items added to stack and make list )
	L> SP - 1 - make-list
	( save this code under __main__ )
	'__main__ save-defined-word
	( perform finalization of all words )
	compiler-finalize-all-words
	( leave list of [ name list ] on stack )
	COMPILED_NAMELISTS ref
	;
	
( ------ misc ------- )
\ "System startup time: " . run-time str . CR
