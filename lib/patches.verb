(
	Patches file, loaded at startup.

	The load order is:
		init.verb.b 
		compiler.verb.b 
		patches.verb 

	The words defined in patches.verb will overwrite any words of the same name
	defined in init.verb.b or compiler.verb.b. (Normally overwriting words is
	not allowed, to avoid subtle bugs.)

	The patches file provides a safe way to modify init.verb/compiler.verb without
	replacing their .b files, which could easily break the entire system. Once changes
	are thoroughly tested via patches.verb, then they can be safely moved into init.verb
	or compiler.verb.

	Copyright (c) 2022 Frank McIngvale, see LICENSE
)

( ------ init ----------- )

\ this is what I should have named these ...
: any? any ;
: all? all ;

'get ,,del  \ remove userword since this is a builtin now
\ : get nget ;

\ fold - left fold
\	func: called with stack [ accum elem ] where accum is the accumulated value and
\		  elem is the next element to be added to the accumulator.
\		  func must leave updated accum on stack
\	init: initial value for accumulator
\
\ 	pseudocode:
\		acc = func(acc, seq[0])
\		acc = func(acc, seq[1])
\		.
\		acc = func(acc, seq[n-1])
: fold ( seq func init )
	\ build closure to run for each element
	\ make func into list
	swap 1 make-list
	\ FUNC will be append to left side of this
	[ self -rot ( now: acc elem FUNC )
		call self! ( make new acc and store )
	]
	+ ( [ FUNC ] + [ above ] )
	\ make into closure & keep a copy
	swap :: dup >L
	for-each
	\ leave end state on stack
	L0 ref unmake nip
	\ clean up locals
	LP 1 + LP!
	;

: make-dict ( list-of-pairs -- dict )
	\ called as: ( dict [ key val ] )
	{ unmake drop put } ,,new-dict fold
	;

\
\ map - make new sequence of func[elem] for each elem in sequence
\
\ calls func with elem on top of stack; func must leave new element on stack
\
: map ( seq func )
	over list? if >>map-list
	over string? if >>map-string
	str "Bad sequence in map: " swap + error	

	@map-string
		\ string concatenation operator & initval
		'+ >L "" >L >>run
	@map-list
		\ list concatentation operator & initval
		'append >L 0 make-list >L

	@run ( seq func )
		\ function to pass to fold
		[ FUNC call CONCAT ]
		\ replace FUNC with function
		0 rot put
		\ replace CONCAT with correct operator from above
		2 L1 ref put
		\ initval
		L0 ref fold \ as above don't use [ ] here
		\ clean up locals
		LP 2 + LP!
		return \ leave filtered list on stack
	;

\
\ filter: make new sequence of only elements where func[elem] is true
\
\ calls func with elem on top of stack; func must leave true or false on stack
\
: filter ( seq func ; calls func[seq[i]] for each element )
	over list? if >>filter-list
	over string? if >>filter-string
	str "Bad sequence in filter: " swap + error	

	@filter-string
		\ string concatenation operator & initval
		'+ >L "" >L >>run
	@filter-list
		\ list concatentation operator & initval
		'append >L 0 make-list >L

	@run ( seq func )
		\ function to pass to fold
		[ dup FUNC call if >>keep drop return 
			@keep CONCAT ]
		\ replace FUNC with function
		1 rot put
		\ replace CONCAT with correct operator from above
		8 L1 ref put
		\ initval
		L0 ref fold \ as above don't use [ ] here
		\ clean up locals
		LP 2 + LP!
		return \ leave filtered list on stack
	;
	
( ------ compiler ------- )

: ltrim-char ( string char -- if char (single-char string) is at front of string, remove it )
	over length 0 != if >>do-trim
	drop return \ 0-length string, nothing to do
	@do-trim
	>L 0 +get L> == if >>trim
	return
	@trim 1 -1 slice
	;

: ltrim-sign ( string -- string with leading "+" or "-" removed [max 1] )
	dup length 0 != if >>do-trim
	return \ 0-length string
	@do-trim
	0 +get "+" == if >>trim
	0 +get "-" == if >>trim
	return
	@trim 1 -1 slice
	;

( ------ misc ------- )
\ "System startup time: " . run-time str . CR