(
	Patches file, loaded at startup.

	The load order is:
		init.verb.b 
		compiler.verb.b 
		patches.verb 

	The words defined in patches.verb will overwrite any words of the same name
	defined in init.verb.b or compiler.verb.b. (Normally overwriting words is
	not allowed, to avoid subtle bugs.)

	The patches file provides a safe way to modify init.verb/compiler.verb without
	replacing their .b files, which could easily break the entire system. Once changes
	are thoroughly tested via patches.verb, then they can be safely moved into init.verb
	or compiler.verb.

	Copyright (c) 2022 Frank McIngvale, see LICENSE
)

( ------ init ----------- )

\ return string with any leading whitespace removed
: string-ltrim ( string -- string )
	0
	@loop ( string i )
		2dup swap length >= ( string i i>=len ) if >>empty
		2dup get whitespace? not ( string i !ws?[string[i]] ) if >>endtrim 
		1 + <<loop
	@endtrim ( string i )
		-1 slice return
	@empty ( string i )
		drop drop "" return
	;

\ is string zero length or contain only whitespace?
: string-empty? ( string -- empty? )
	string-ltrim length 0 ==
	;

\ -------------------------------------------------------------------------
\
\ Stream reader
\
\ -------------------------------------------------------------------------

\ create a new stream for reading from string
: stream-reader-open-string ( string -- stream )
	\ state = [ TEXT POSITION ]
	0 2 make-list
	;

\ create a new stream for reading from file
: stream-reader-open-file ( filename -- stream )
	read-file stream-reader-open-string
	;

\ since doing a series of reads is such a common operation,
\ these functions leave the stream on the stack to avoid lots of caller dups
\ and also usually avoids drops here

\ peek next char [as string] from stream or void on eof
: stream-reader-peek-char ( stream -- stream c )
	\ POS >= length?
	dup 1 get over 0 get length >= if >>eof
	\ POS is OK
	dup 0 get over 1 get get return
	
	@eof void
	;

\ read next char [as string] from stream or void on eof
: stream-reader-next-char ( stream -- stream c )
	\ POS >= length?
	dup 1 get over 0 get length >= if >>eof
	\ POS is OK, get char
	dup 0 get over 1 get get ( stream c )
	\ ++POS
	swap dup 1 get 1 + 1 swap put ( c stream )
	swap return 

	@eof void
	;

\ skip all whitespace from current position
: stream-reader-skip-whitespace ( stream -- stream )
	@loop
		stream-reader-peek-char
		dup void? if >>done
		dup whitespace? not if >>done
		drop 
		stream-reader-next-char drop <<loop
	@done
		drop
		;

\ read word (non-whitespace chunk) from current position,
\ skipping any leading whitespace. returns void if no more words.
: stream-reader-next-word ( stream -- stream word )
	stream-reader-skip-whitespace
	"" ( stream word )
	@loop ( stream word )
		over stream-reader-next-char nip ( stream word c )
		dup void? if >>done
		dup whitespace? if >>done
		+ <<loop \ non-ws, append and continue
	@done ( stream word c )
		drop
		dup length 0 == if >>void
		return
	@void
		drop void
	;

\ get next line from reader or void
\ discards any \r or \n line ending so an empty line will return ""
\ returns void if no more lines
: stream-reader-next-line ( stream -- stream line )
	""
	@loop ( stream s )
		\ "@loop:" . .S CR
		over stream-reader-next-char nip ( stream s c )
		dup void? if >>eof
		dup ord 10 == if >>NL \ \n
		dup ord 13 == if >>CR \ \r
		+ <<loop \ normal char - append and contine
	\ this is gross but i want to be portable so check for
	\ any of: \n, \r, \r\n, \n\r
	@NL ( stream s \n )
		drop over stream-reader-peek-char nip ( stream s c )
		dup void? if >>drop-return
		dup ord 13 == if >>skip-next
		>>drop-return
	@CR ( stream s \r )
		drop over stream-reader-peek-char nip ( stream s c )
		dup void? if >>drop-return
		dup ord 10 == if >>skip-next
		>>drop-return
	@drop-return
		\ just \r or \n
		drop return
	@skip-next ( stream s c )
		\ got CR/LF pair
		\ skip next char
		drop over stream-reader-next-char drop drop return
	@eof ( stream s c )
		drop 
		\ need to distinguish eof at end of string vs. eof at start
		dup length 0 == if >>void \ no chars before eof
		return
	@void ( stream s )
		drop void
		;
		


( ------ compiler ------- )

\ if list is [ ,,inline obj1 .. objN ] then push obj1 .. objN to the stack
\ and remove of list. else leave list alone.
: flatten-if-inline ( list -- list or items )
	dup length 0 == if >>done \ empty list, leave on stack
	dup 0 get ',,inline == if >>flatten
	return \ not ,,inline, leave on stack
	@flatten ( list )
		\ drop ,,inline and push rest of list to stack
		1 -1 slice unmake drop return
	@done ( list )
	;

: syntax-define-word
	syntax-next ( name should be next )
	dup symbol? not if >>badname
	\ call syntax-next repeatedly until ';' is found. this will leave all parsed
	\ words on stack that i'll then make into a list. easy way to do this is remember
	\ starting value of SP then subtract from SP at end to get # of items parsed.
	>L SP >L   ( L0=starting SP, L1=name )
	@loop
	syntax-next ( get next processed object )
	dup void? if >>eof
	dup '; == if >>endword
	dup list? if >>list \ lists may need special handling, see below
	<<loop
	\ when i get a list i need to see if it is [ ,,inline ... ] and flatten it if so
	@list ( list )
		flatten-if-inline <<loop

	@badname str "Invalid name after ':' : " swap + error
	@eof "Unexpected end of input looking for ';'" error
	@endword
	drop ( drop ; )
	L> SP - 1 - ( calc number of items )
	make-list
	L> 
	( save names & compiled words )
	save-defined-word
	syntax-next ( save-defined-word has no return value, so return NEXT object )
	;

( ------ misc ------- )
\ "System startup time: " . run-time str . CR