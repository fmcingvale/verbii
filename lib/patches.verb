\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
( ------ boot ----------- )

\ make a variable with a getter and setter:
\	'name' gets data stored in var
\	'name!' sets data stored in var
: make-var @( name initval )
	@locals [ addr ]
	1 alloc addr! \ alloc storage
	initval addr set! \ save initval
	
	\ make:
	\	name = get data @ addr
	\	name! = set data @ addr
	
	\ make word: : NAME addr ref ;
	addr 'ref 2 make-list name make-word
	\ make word: : NAME! addr set! ;
	addr 'set! 2 make-list name '! + make-word
	;
	
( ------ init ----------- )

\ is c an uppercase letter?
: upper? @( c ) 
	c ord 65 >= c ord 90 <= and ;
	
\ is c an uppercase letter?
: lower? @( c )
	c ord 97 >= c ord 122 <= and ;
	
\ convert char c to lowercase, if it is a letter
: tolower @( c -- lowercase )
	c upper? if >>is-upper
	c return \ not uppercase, return c as is
	@is-upper
		c ord 65 - 97 + chr
	;

\ convert char c to uppercase, if it is a letter
: toupper @( c -- uppercase )
	c lower? if >>is-lower
	c return \ not uppercase, return call
	@is-lower
		c ord 97 - 65 + chr
	;
	
\ convert string to lowercase
: string-lower @( s -- lowercase )
	s { tolower } map
	;

\ convert string to uppercase	
: string-upper @( s -- lowercase )
	s { toupper } map
	;
	
\ split text into parts separated by one or more chars from delims (a string or list of chars).
\ any leading/trailing delims are trimmed. this function does NOT make empty parts.
: string-split @( text delims -- parts )
	@locals [ i c piece ]
	[ ] parts!
	0 i!
	"" piece!
	@loop
		text i get c!
		c void? if >>got-end \ end of string
		delims @{ c == } find void? not if >>got-delim \ found delimiter
		\ not a delim, add to piece
		piece c + piece! >>next
	@got-delim
		\ if i've been building a piece, add to parts and reset piece
		piece length 0 > if >>push-piece
		\ else this in the middle of other delimiters, so just keep going
		>>next
	@push-piece
		parts piece append parts!
		"" piece!
		>>next
	@next
		i 1 + i! <<loop
	@got-end
		\ if i have a piece, add it to parts
		piece length 0 == if >>done 
		parts piece append parts!
	@done
		parts
	;
	
\ for i=start .. start+incr*(count-1), call fn with args ( i )
\
\ note: count is used instead of an end value to simplify boundary conditions
: for-range @( fn start incr count )
	@locals [ i ]
	
	0 i!
	@loop
		count 0 <= if >>done
		\ call fn with start+i on top of stack
		i start + fn call
		i incr + i!
		count 1 - count!
		<<loop
	@done
	;
	
\ find index of first item in sequence that satisfies test or void if none 
: find @( seq test -- index )
	0 index!
	@loop
		index seq length >= if >>not-found
		seq index get test call if >>found 
		index 1 + index! <<loop
	@found index return
	@not-found void
	;

( ------ compiler ------- )

\ rewrites an objlist to translate arg/local names including capturing outer vars (closures)
\
\ selfmap should be set to an empty dict at the toplevel
\
\ ASSUMPTIONS:
\	1. objlist must come from a lambda, not a plain list (rewriting ensures a return is at the end 
\	   	of new objlist, so has to be assumed to be code)
\	2. closures must be marked with @{ ... } ; will NOT transform unmarked lambdas since they might
\		be used in other binding constructs
\	3. does NOT (yet) rewrite lists so dynamic code cannot use @args/@lists nor create closures
\		(user code can manually do closures with :: of course)
\
\ does these things:
\	1. scans objlist (non-recursively) for @args, @locals, and/or [ ,,declargs ... ]
\	2. if NO names found in above search, then objlist is returned as-is and changed=false
\		(no names at THIS level, means no captures can happen here or anywhere underneath)
\	3. rewrite objlist to do:
\		a. alloc locals (LP nr - LP!)
\		b. pop args (L> L> ...)
\		c. rewrite symbols to their code sequences:
\			(i) if name in args/locals, rewrite to (LP i + ref) or (LP i + set!)
\			(ii) if name in selfmap, rewrite to (self i get) or (self i rot put drop)
\		d. if an inner lambda is found ( @{ ... } -- @ is required for backward compat with { .. } obj :: code )
\			(i) recursively rewrite lambda, passing selfmap + my args+locals as its selfmap
\			(ii) add binding of selfmap + my locals as self for inner lambda
: compile-rewrite-args-locals @( objlist selfmap -- new-objlist )
	@locals [ argnames localnames local-refmap local-setmap i self-setmap ]
		\ "1 REWRITE-ARGS-LOCALS OBJLIST:" . objlist . CR
		\ "2 SELFMAP:" . selfmap . CR
		
	\ ensure objlist ends with a 'return', or add one
	objlist -1 get 'return == if >>scan-args-locals
	objlist deepcopy ( don't modify original ) 'return append objlist!
	
	@scan-args-locals
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
			\ "AFTER COLLECT: ARGS=" . argnames . "LOCALS=" . localnames . "OBJLIST=" . new-objlist . CR

		\ note: even if i have no @args/@locals, i can still have names that resolve to selfmap
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ make preamble code to:
		\	1. alloc spaces for @locals
		\	2. pop args to locals
		\ note this will put args starting at LP and locals starting at LP + #args
		
		\ 1. alloc locals (LP #localnames - LP!)
		localnames length 0 == if >>popargs \ omit code if no locals
		'LP localnames length '- 'LP! 4 make-list new-objlist!
	@popargs
		\ 2. push args to locals (adding code to new-objlist)
		argnames { ( accum elem ) drop '>L append } new-objlist fold new-objlist! 
		
		\ make a map of arg|local name -> index into locals
		[ ] make-dict argnames localnames + dict-add-indexed-names local-refmap!
			\ "MADE NAMEMAP:" . local-refmap . CR
		\ map a map of name! as well to replace setters
		[ ] make-dict 
			argnames { str "!" + } map 
			localnames { str "!" + } map 
			+ dict-add-indexed-names local-setmap!
			\ "MADE SETTER MAP:" . local-setmap . CR
		
		\ for each name in selfmap, make name! in self-setmap with same index
		[ ] make-dict self-setmap!
			\ "2.1 BEFORE FOR-EACH-DICT SELFMAP = " . selfmap . CR
		selfmap
		{
			( key val ; self self-setmap )
			self -rot swap "!" + swap put drop
		} self-setmap :: for-each-dict
			\ "2.2 AFTER FOR-EACH-DICT SELFMAP = " . selfmap . CR
			\ "SET-SETMAP:" . self-setmap . CR
		
	\ rewrite objlist replacing arg|local symbols with appropriate code sequences and creating
	\ closures as needed
	0 i!
	@rewrite-loop
			\ "REWRITE LOOP, NEW NOW:" . new-objlist . CR
			\ "REWRITE LOOP STACK:" . .S CR
		i objlist length >= if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>list
		\ everything else, copy as-is
	@copy-element
		new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		objlist i get 'return == if >>rewrite-return
		\ NOTE: local scope is checked BEFORE outer scope so that the inner scope can redefine
		\ names and see the intended (local) value instead of the outer one
		\ example:
		\		: fn @( n ) @{ @args [ n ] <- here, n and n! should see the LOCAL names not the outer n, n! }
		
		\ is symbol (as string) in local-refmap?
		local-refmap objlist i get str get void? not if >>rewrite-local-ref
		\ check for local setter
		local-setmap objlist i get str get void? not if >>rewrite-local-set
		\ is symbol (as string) in selfmap?
		selfmap objlist i get str get void? not if >>rewrite-self-ref
		\ check for self setter
		self-setmap objlist i get str get void? not if >>rewrite-self-set
		
		\ else not in either list, keep as-is
		<<copy-element
		
	@rewrite-local-ref
		\ add (LP i + ref) to new-objlist
		new-objlist
		'LP local-refmap objlist i get str get '+ 'ref 4 make-list
		+ new-objlist! >>next
		
	@rewrite-local-set
		\ add (LP i + set!) to new-objlist
		new-objlist
		'LP local-setmap objlist i get str get '+ 'set! 4 make-list
		+ new-objlist! >>next
	
	@rewrite-self-ref
		\ add (self i get) to new-objlist
		new-objlist
		'self selfmap objlist i get str get 'get 3 make-list
		+ new-objlist! >>next
	
	@rewrite-self-set
		\ add (self i rot put drop) to new-objlist
		new-objlist
		'self self-setmap objlist i get str get 'rot 'put 'drop 5 make-list
		+ new-objlist! >>next
		
	@rewrite-return
			\ "******* REWRITE RETURN ************" . CR
		
		\ if no args/locals then skip -- no frame to remove
		argnames length localnames length + 0 == if >>simple-return
		
		\ replace return with code to remove local frame
		new-objlist
		'LP argnames length localnames length + '+ 'LP! 'return 5 make-list
		+ new-objlist! >>next
		
	@simple-return
		\ no frame, so just keep return
		new-objlist 'return append new-objlist! >>next
		
	@list
		\ look for [ ,,closure ... ] (parsed from @{ .. })
		objlist i get length 2 < if <<copy-element \ list too short, can't be closure
		objlist i get 0 get ',,closure != if <<copy-element \ not [ ,,closure .. ] so just copy element
		\ recursively parse list, passing a selfmap that is my selfmap + my locals
			\ "2.3 SELFMAP BEFORE DEEPCOPY:" . selfmap . CR
		selfmap deepcopy \ don't alter my selfmap
			\ "2.4 SELFMAP AFTER DEEPCOPY:" . selfmap . CR
		( inner-selfmap )
			\ "GOT ,,closure -- argnames = " . argnames . CR
		argnames dict-add-indexed-names \ add arg names first -- they are first on locals stack
		localnames dict-add-indexed-names \ .. then locals
		( inner-selfmap )
		objlist i get 1 -1 slice \ remove ,,closure
		swap ( objlist inner-selfmap )
			\ "** PARSE INNER LAMBDA:" . CR
			\ "3 BEFORE INNER REWRITE, SELFMAP = " . selfmap . CR
		compile-rewrite-args-locals ( new-objlist )
			\ "4 AFTER INNER REWRITE, SELFMAP = " . selfmap . CR
			\ "** INNER REWROTE:" . over . CR
		make-lambda \ turn new-objlist back into lambda
		new-objlist swap append new-objlist! \ add lambda to new-objlist
		\ now create code to make runtime binding for new lambda
		\ want self = [ self0 .. selfN arg0 .. argN local0 .. localN ]
		\ so code will be:
		\	[ ] self + ( shallow-copy self )
		\	#args #locals + copy-locals-to-list + ( self + locals ) ::
		
			
		\ NOTE! have to check for empty selfmap since referencing a non-existent self is an error
		selfmap length 0 == if >>no-selfmap
		
		\ case 1: my self is bound so concatenate my locals to self
		0 'make-list 'self '+ argnames length localnames length + 'copy-locals-to-list '+ '::
		8 make-list new-objlist swap + new-objlist! \ add self-making code to new-objlist
		>>next
		
	@no-selfmap
		\ case 2: no selfmap so just pass on my locals
		argnames length localnames length + 'copy-locals-to-list '::
		3 make-list new-objlist swap + new-objlist! \ add self-making code to new-objlist
		>>next
		
	@next
		i 1 + i! <<rewrite-loop
	
	@done
		new-objlist return
	;

( ------ misc ------- )
\ "System startup time: " . run-time str . CR
