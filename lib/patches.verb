\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
\ TIP: When changing compiler code, always run with -nocache flag,
\      else compiler would never run when finding .b files.

( ------ boot ----------- )
			
( ------ init ----------- )

\ create a new dictionary as one of:
\
\ 	a list of tuples and makes a dictionary:
\		[ [ "foo" 123 ] [ "bar" 678 ] ] make-dict
\		=>
\		{ "bar" => 678 "foo" => 123 }
\
\	a list of lambdas that returns ( key val ):
\		[ { "a" 10 5 + } { "b" 100 200 + } ]
\		=>
\		{ "a" => 15 "b" => 300 }
\
\	The above forms can be mixed together in the same list
\
\ treating this as experimental so not replacing make-dict yet.
: make-dict* ( pairs -- D )
	,,new-dict D!
	pairs
	{ ( item )
		item list? if >>list
		item lambda? if >>lambda
		item bound-lambda? if >>lambda
		"Bad item passed to make-dict: " item str + error
		
		@list
			D item 0 get item 1 get put D! return
		@lambda
			D item call put D! return
	} for-each
	D
	;

\ like . but without trailing space
: .. str puts ;

\ run lambda as long as test is true (test is run BEFORE lambda)
: while ( test lambda )
	@loop
		test call not if >>done
		lambda call <<loop
	@done
	;

\ similar to 'cond' in Scheme
\
\ condexprs is a list of [ { .. test .. } { .. call if true .. } ]
\ with optional element: [ null { .. call if no match .. } ] that ALWAYS matches
: cond ( condexprs -- )
	@locals [ i ]
	0 i!
	@loop
		\ end of condexprs?
		condexprs i get void? if >>nomatch
		\ [ null { ... } ]? 
		condexprs i get 0 get null == if >>match 
		\ else run test and check result
		condexprs i get 0 get call if >>match
		i 1 + i! <<loop
	@nomatch
		return \ or should it be an error to match no clauses?
	@match 
		condexprs i get 1 get call return \ call matching clause
	;
	
( ------ compiler ------- )

\ objlist can be from a lambda or list. pass plain-list=true if objlist is from a list; false if from a lambda.
\ (the difference being that plain lists are never bound to a frame since they are never called as code)
: v2-compile-rewrite-args-locals ( objlist outer-env plain-list -- new-objlist nr-rewritten )
	@locals [ argnames localnames env i ]
			
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
		
		\ track number of var references i rewrite
		0 nr-rewritten!
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ note: i don't have to reserve space for locals -- interpreter creates frame
		\ with sufficient space, so i only have to pop args into frame ...
		
		\ make code to push args to locals (add to new-objlist)
		\ (pop in reverse order of argnames, so range starts at (#argnames-1)
		{ ( i )
			new-objlist
				'FRAME-SET 0 i 0 make-opcode
				append drop
		} argnames length 1 - 				\ start index = #argnames-1
			-1 								\ count by -1
				argnames length for-range	\ for argnames args
		
		\ create an environment to resolve names 
		plain-list if >>make-env-plain-list
		
		\ make environment for new closure, chained to outer-env
		\ -- add args first since those are at lowest indexes
		new-closure-env env!
		\ add args first so they'll get assigned indexes starting at 0
		\ -- arg names are NOT allowed to repeat
		argnames
		{ ( name )
			env name closure-env-add-name
		} for-each

		\ env argnames closure-env-add-namelist
		
		\ now @locals -- these ARE allowed to duplicate names in arglist, in which
		\ case they are ignored
		\ WHY? it seems fairly common to have arglists like:
		\		( a b -- a )
		\ where the output a is a modified version of a, for example. there is no need
		\ for a second var in these kinds of cases, and allowing the duplicated names
		\ makes function signatures cleaner for a lot of common cases
		
		\ env localnames closure-env-add-namelist
		localnames
		{ ( name )
			env closure-env-dict name str get void? not if >>dup-name 
			env name closure-env-add-name
			@dup-name \ not an error, just ignored
		} for-each

		\ .. and chain to my outer scope
		env outer-env closure-env-set-up
		>>begin-rewrite
		
	@make-env-plain-list
		\ i'm rewriting a LIST, not code -- list will be flattened (see below) so will
		\ run IN the outer-env, not a new environment
		outer-env env!
		\ IMPORTANT! nothing below here is allowed to modify env since that would modify
		\ outer-env incorrectly
		
	@begin-rewrite
	\ rewrite symbols using environment just created
	0 i!
	@rewrite-loop
		\ i objlist length >= if >>done 
		
		objlist i get void? if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>rewrite-inner-plain-list
		objlist i get lambda? if >>rewrite-inner-lambda
		\ fall through for everyting else, copy as-is
	@copy-element
		\ subtlety here: if i'm working on a plain-list, then, if it contains ANY captures (or any in
		\ ANY nested list/lambda) then it will be flattened and then remade at runtime. this means that every element
		\ in the list will be evaluated -- what i WANT to happen is for everything to be pushed to the stack,
		\ and the only things that should really be evaluated are opcodes that pull values from my frame.
		\ however, i need to quote any symbols so they will be pushed as symbols instead of run. when they are
		\ seen, the outer quoting will be removed, so when make-list runs, they will end up back in the list as
		\ intended. even though I don't know HERE whether a list will be flattened or not,
		\ i can replace them unconditionally since if the list contains no captures, this list will never
		\ be used (see below as well e.g. @plain-list-no-rewrites)
		plain-list not if >>normal-copy-element
		objlist i get symbol? not if >>normal-copy-element
			\ it is a symbol in a plain list, so add a level of quoting
			new-objlist '' objlist i get + append new-objlist! >>next
		@normal-copy-element
			\ not a symbol or not in a plain-list, so just copy as is
			new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		@locals [ level index sym ]
		objlist i get sym!
		\ see if symbol is in my env or any outer scope
		env sym closure-env-lookup-name index! level!
		index void? if <<copy-element \ not in environment, so copy as is 
		\ turn symbol into get/set opcode (tied into the comments below, this never
		\ changes the size of the list -- the symbol & the opcode that replaces it
		\ are both single objects)
		new-objlist
			sym level index closure-env-make-ref-or-set
			append new-objlist!
		\ increment counter
		nr-rewritten 1 + nr-rewritten!
		>>next 
		
	@rewrite-inner-lambda
		@locals [ sub-objlist sub-nr-rewritten ]
		\ call rewrite recursively with my env as the outer scope
		objlist i get unmake \ get lambda as list to pass
		env false v2-compile-rewrite-args-locals sub-nr-rewritten! sub-objlist!
		\ turn new sub-objlist back into lambda now that its rewritten and add to new-objlist
		new-objlist
			sub-objlist make-lambda append new-objlist!
		\ did i rewrite ANY names in inner closure (or any inner closures of that, etc.)
		sub-nr-rewritten 0 == if >>done-rewrite-sub 
		\ i rewrote terms, therefore this lambda needs to be bound to my (runtime) frame,
		\ so add that ...
		new-objlist 'bind-lambda append new-objlist!
		
	@done-rewrite-sub
		\ add # rewritten to my count so i return total of mine + all recursive inner lambdas
		nr-rewritten sub-nr-rewritten + nr-rewritten!
		>>next
		
	@rewrite-inner-plain-list
		@locals [ list-length ]
		\ rewrite vars inside a list without binding frame to it at runtime (since the list will
		\ be expanded, it will be filled from MY frame) -- also see code at beginning that
		\ knows not to create a new env for plain lists
		
		\ remember ORIGINAL length of list i'm about to rewrite. after rewriting i could have something like:
		\	BEFORE: [ a b [ c d [ e f ] ] ]
		\	AFTER: a b c d e f 2 make-list 3 make-list 3 make-list
		\ in other words, the inner lists have been flattened so the literal length is longer, but the
		\ RUNTIME length (i.e. for make-list) is the same -- rewriting is a 1-to-1 replacement of varnames
		\ with a single opcode, so the final RUNTIME length will be the same.
		objlist i get length list-length!
		\ rewrite list
		objlist i get env true v2-compile-rewrite-args-locals sub-nr-rewritten! sub-objlist!
		\ did I rewrite anything?
		sub-nr-rewritten 0 == if >>plain-list-no-rewrites
		\ else, the rewrites occurred in MY ENV so flatten list so runtime references are correct
		new-objlist
			sub-objlist extend \ flatten sub-objlist into new-objlist
			\ add code to remake list at runtime -- see notes above on the length passed to make-list
			list-length append 'make-list append new-objlist!
		\ add # rewritten to my count so i return total of mine + all recursive inner lambdas
		nr-rewritten sub-nr-rewritten + nr-rewritten!
		>>next 
		
	@plain-list-no-rewrites
		\ nothing rewritten, so leave list as-is and it can be instantiated by deepcopy at runtime
		new-objlist objlist i get append new-objlist!
		
		>>next \ just to be clear ...
		
	@next
		i 1 + i! <<rewrite-loop
		
	@done
		new-objlist nr-rewritten return	
		;
		 



