\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
( ------ boot ----------- )

( ------ init ----------- )

( ------ compiler ------- )

\ take a list: [ ,,declargs arg ... -- local ... ]
\ and return lists of [ arg ... ] and [ local ... ]
: compile-split-declargs ( list -- args locals )
	@args [ list ]
	@locals [ i args locals parsing-locals ]
	[ ] args!
	[ ] locals!
	false parsing-locals! \ have i seen the '--' ?
	1 i! \ skip ,,declargs
	@loop
		i list length >= if >>done
		list i get '-- == if >>got-dashes 
		\ else add to either args or locals list
		parsing-locals if >>add-to-locals
		args list i get append args! >>next \ add to args
	@add-to-locals ( obj )
		locals list i get append locals! >>next \ add to locals 
	@got-dashes
		true parsing-locals! \ switch to parsing locals, fall through to next
	@next
		i 1 + i! <<loop
	@done 
		args locals
		;
		

\ takes a compiled objlist and collects:
\	[ ,,declargs arg .. -- local .. ] => args & locals
\		(the compiler generates this from @( arg ... -- local ... )
\	@args [ ... ] => args
\	@locals [ ... ] => locals
\
\ returns rewritten objlist with the @args & @locals removed.
\
\ it is valid to have BOTH @( ... ) and @args/@locals -- the names will be
\ merged into a single args/locals lists
: compile-collect-args-locals ( objlist -- new-objlist args locals )
	@args [ objlist ]
	@locals [ new-objlist args locals i ]
		\ "COMPILE COLLECT ARGS LOCALS:" . .S CR
		\ "	objlist:" . objlist str . CR
	[ ] new-objlist!
	[ ] args!
	[ ] locals!
	0 i!
	@loop
		objlist i get ( objlist[i] )
		dup void? if >>done \ i >= length
		dup list? if >>check-list
		dup '@args == if >>args-list 
		dup '@locals == if >>locals-list
		\ else regular obj, copy to new list
		>>keep-obj
	@check-list ( obj )
		\ see if this is [ ,,declargs ... ]
		dup length 0 == if >>keep-obj
		dup 0 get ',,declargs != if >>keep-obj
		\ it is ,,declargs, so split into args,locals
		compile-split-declargs ( args locals )
		locals swap + locals!  \ append locals & args to my lists 
		args swap + args! >>next
	@keep-obj ( list )
		new-objlist swap append new-objlist! >>next
	@args-list ( obj )
		drop
		\ just saw @args so a list must be next
		i 1 + i!
		objlist i get
		dup void? if >>missing-args \ end of input
		dup list? not if >>missing-args 
		\ add list to anything collected so far from @( .. )
		args swap + args! >>next
	@missing-args
		"Expecting list after @args in:" objlist str + error
	@locals-list ( obj )
		drop
		\ list must be next
		i 1 + i!
		objlist i get
		dup void? if >>missing-locals
		dup list? not if >>missing-locals
		\ add to any existing locals from @( .. )
		locals swap + locals! >>next 
	@missing-locals
		"Expecting list after @locals in:" objlist str + error
	@next
		i 1 + i! <<loop
	@done ( void )
		drop new-objlist args locals
		;
	
\ assumes @( was just read, parses until ) as an object list, prepended with ,,declargs
: syntax-parse-decl-arglist
	@locals [ outlist ]
	',,declargs 1 make-list outlist!
	@loop
		syntax-next
		dup void? if >>eof
		dup ') == if >>done
		\ else append object and continue
		outlist swap append outlist! <<loop
	@eof
		drop "End of input inside @(" error
	@done
		drop outlist
	;

\ assumes ':' was just read
: syntax-define-word
	@locals [ SP-start name ]
	syntax-next ( name must dbe next )
	dup symbol? not if >>badname
	\ call syntax-next repeatedly until ';' is found. this will leave all parsed
	\ words on stack that i'll then make into a list. easy way to do this is remember
	\ starting value of SP then subtract from SP at end to get # of items parsed.
	name! SP SP-start!
	@loop
	syntax-next ( get next processed object )
	dup void? if >>eof
	dup '@( == if >>arglist \ ) <- freaks out notepad++ styling here
	dup '; == if >>endword
	dup list? if >>list \ lists may need special handling, see below
	<<loop
	@arglist ( obj )
		\ i do not check here to see if i have multiple @( .. ) constructs; that will
		\ be handled at the rewrite stage
		drop
		syntax-parse-decl-arglist <<loop
		
	\ when i get a list i need to see if it is [ ,,inline ... ] and flatten it if so
	@list ( list )
		flatten-if-inline <<loop

	@badname str "Invalid name after ':' : " swap + error
	@eof "Unexpected end of input looking for ';'" error
	@endword
	drop ( drop ; )
	SP-start SP - 1 - ( calc number of items )
	make-list
	( save names & compiled words )
	name save-defined-word
	syntax-next ( save-defined-word has no return value, so return NEXT object )
	;
	
\ takes a compiled object list and a list of names 'args' and 'locals'
\
\ rewrites objlist to do:
\	- pop #args from stack into locals
\	- reserve #locals in local stack
\	- for every name N in ARGLIST and LOCALLIST, create
\		mappings:
\			N -> LP i + ref 
\			N! -> LP i + set!
\	- replace all instances of N and N! in objlist with above mappings
: compile-rewrite-args-locals ( objlist args locals -- new-objlist )
	@args [ objlist args locals ]
	@locals [ namemap new-objlist ]
		\ "REWRITE ARGS LOCALS:" . CR
		\	"	objlist:" . objlist . CR
		\	"	args:" . args . CR
		\	"	locals:" . locals . CR
	,,new-dict namemap! \ dict mapping names -> code replacements
	[ ] new-objlist! \ rewritten objlist with names replaced with code sequences
	
	@begin
		\ "Got @args:" . L0 ref . CR
		\ "Got @locals:" . L1 ref . CR
		\ "Code now:" . dup . CR

		\ optimization -- if I have NO @args nor @locals, then do not modify objlist -- no need for
		\ code to setup/teardown frame when no named vars being used
		args length 0 ==
		locals length 0 ==
		and not if >>process
		
		\ no args & locals so output original list
		objlist new-objlist! >>exit

	@process
		\ make locals layout:
		\	N+M-1: locals[M-1]
		\	...
		\	N+1: locals[1]
		\	N: locals[0]
		\	N-1: args[N-1]
		\	...
		\	1: args[1]
		\	0: args[0]
		
		\ process @args first:
		\	for each arg "N" at index i, create two symbols:
		\		"N" -> LP i + ref
		\		"N!" -> LP i + set!
			\ "PROCESS ARGS:" . CR
		args
		{
			( called with: i name ; self bound to mapping dict )
			str 2dup over 'LP swap '+ 'ref 4 make-list ( i name i name [ 'LP i '+ 'ref ] )
			self -rot put ( i name i dict ) drop drop
			over 'LP swap '+ 'set! 4 make-list ( i name [ 'LP i '+ 'set! ] )
			swap "!" + swap ( i name! [ 'LP i '+ 'set! ] )
			self -rot put ( i dict ) drop drop
		} namemap :: ( bind namemap to function )
		for-each-i 
			\ "MAPPINGS after adding @args:" . namemap . CR
		\ basically same thing for locals now, with offset:
		\	for each local "N" at index i, create two symbols:
		\		"N" -> LP i + #args + ref
		\		"N!" -> LP i + #args + set!
		locals
		{
			( called with: i name ; self bound to [ dict #args ] )
			str 2dup over self 1 get + 'LP swap '+ 'ref 4 make-list ( i name i name [ 'LP i+#args '+ 'ref ] )
			self 0 get -rot put ( i name i dict ) drop drop
			over self 1 get + 'LP swap '+ 'set! 4 make-list ( i name [ 'LP i+#args '+ 'set! ] )
			swap "!" + swap ( i name! [ 'LP i+#args '+ 'set! ] )
			self 0 get -rot put ( i dict ) drop drop
		} namemap args length 2 make-list :: ( bind lambda with [ dict #args ] )
		for-each-i 
			\ "MAPPINGS after adding @locals:" . L2 ref . CR
		\ add a mapping with code for 'return' (LP #args+#locals + LP!)
		namemap "return" 'LP args length locals length + '+ 'LP! 'return 5 make-list put namemap!
			\ "MAPPINGS after adding 'return':" . namemap . CR
		\ finally, create new objlist by replacing all mapped symbols
		objlist
		{
			\ called with: ( accum elem ) ; self bound to mapping dict

			\ only process symbols
			dup symbol? not if >>copy \ not symbol, leave it as-is
			self over str get void? if >>copy \ not in mapping dict, copy as-is
			\ replace with mapping
			self swap str get + return

			@copy ( accum elem )
				append return \ append to new list as-is
		} namemap :: ( bind self to mapping dict )
	 	\ "READY TO FOLD:" . .S CR
		\ initial value is stack setup: [ LP #locals - LP! ] then one >L for each @arg
		'LP locals length '- 'LP! 4 make-list
		[ '>L append ] args length repeat
		fold new-objlist!

	@exit
		new-objlist
		;
	
\ take a parsed objlist, presumably from byte-compile, and perform finalization:
\	* ensure objlist ends with 'return'
\	* transform @args [ .. ] and @locals [ .. ] into code
\
\ returns a new list, does NOT modify objlist
: compile-finalize-word ( objlist -- newlist )
		\ "FINALIZE WORD:" . .S CR
	dup length 0 > if >>not-empty
	\ objlist is empty; newlist is [ return ]
	drop 'return 1 make-list >>transform-args-locals

	@not-empty ( objlist )
		dup -1 get 'return != if >>add-return
		\ already has return at end
		>>transform-args-locals

	@add-return ( objlist )
		deepcopy \ don't modify original
		'return append

	@transform-args-locals ( objlist )
		\ split @( .. ), @args and @locals from objlist
		compile-collect-args-locals ( new-objlist args locals )
			\ "AFTER COLLECTING:" . .S CR
		\ turn names into code sequences
		compile-rewrite-args-locals
			\ "AFTER REWRITING:" . .S CR
	;
	
( ------ misc ------- )
\ "System startup time: " . run-time str . CR
