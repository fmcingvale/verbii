(
	Patches file, loaded at startup.

	The load order is:
		init.verb.b 
		compiler.verb.b 
		patches.verb 

	The words defined in patches.verb will overwrite any words of the same name
	defined in init.verb.b or compiler.verb.b. (Normally overwriting words is
	not allowed, to avoid subtle bugs.)

	The patches file provides a safe way to modify init.verb/compiler.verb without
	replacing their .b files, which could easily break the entire system. Once changes
	are thoroughly tested via patches.verb, then they can be safely moved into init.verb
	or compiler.verb.

	Copyright (c) 2022 Frank McIngvale, see LICENSE
)

( ------ init ----------- )
: :: make-closure ;

: repeat ( lambda NR -- call lambda NR times )
	\ lambda is allowed to use stack, but not locals, so store my
	\ parameters in locals
	>L >L ( L1 = NR, L0 = lambda )
	@loop
	L1 ref 0 == if >>done ( NR == 0? )
	L0 ref call ( call lambda, now with access to any args that were below it )
	L1 ref 1 - L1 set! ( NR -= 1 ) <<loop
	@done LP 2 + LP! ; ( remove locals )
	
( ------ compiler ------- )
\
\	for-each-reverse -- same as for-each, but starts at the end
\
: for-each-reverse ( object lambda -- call lambda on each object in string,symbol,list in reverse order )
	>L dup length 1 - >L ( L0=index, L1=lambda )
	@loop
	L0 ref 0 < if >>done
	L0 ref +get L1 ref 
	call ( call lambda with element on stack )
	L0 ref 1 - L0 set! <<loop
	@done drop LP 2 + LP!
	;

: reader-next-chunk ( -- next string of either all whitespace or non-whitespace )
		\ "reader-next-chunk" . CR
	"" ( string )
	\ see what next chunk starts with ...
	reader-peek-char
	dup null? if >>drop-return
	dup whitespace? if >>ws 
	\ else, non-whitespace
	drop
	@non-ws-loop ( string )
	reader-peek-char ( if next is whitespace, do NOT want to read it )
	dup null? if >>drop-return
	dup whitespace? if >>drop-return
	drop reader-next-char + <<non-ws-loop ( append to string and continue )

	\ read whitespace chunk
	@ws
	drop
	@ws-loop ( string )
	reader-peek-char
	dup null? if >>drop-return
	dup whitespace? not if >>drop-return
	drop reader-next-char + <<ws-loop

	@drop-return ( string char )
		drop return

	;

: syntax-lambda ( assumes { was just read & dropped )
	0 make-list 
	@loop
		\ note - any inner lambdas will be handled automatically by syntax-next,
		\ so don't have to check for "{" here
		syntax-next
		dup null? if >>eof
		dup '} == if >>closebrace
		append ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside { .. }" error
	@closebrace
		drop make-lambda return
		;

: syntax-list ( assumes [ was just read & dropped )
	0 make-list 
	@loop ( list )
		\ note - any inner lists/lambdas will be handled automatically by syntax-next,
		\ so don't have to check for { or [ here
		syntax-next
		dup null? if >>eof
		dup '] == if >>closelist
		append ( else append to list and continue ) <<loop
	@eof
		"Unexpected end of input inside [ .. ]" error
	@closelist
		drop
		;

( make literal """ which is not parseable itself )
var TRIPLEQUOTE 1
34 34 34 3 make-symbol TRIPLEQUOTE set!

: syntax-next ( convert next word from input to runnable object )
	reader-next
		\ "syntax-next:" . dup . CR
	dup null? if >>null
	dup '( == if >>comment
	dup '\ == if >>line-comment
	dup '{ == if >>lambda
	dup '[ == if >>list
	dup ': == if >>worddef
	dup 'def == if >>worddef ( synonym for ':' )
	( look for triple-quoted string first )
	dup 0 3 slice TRIPLEQUOTE ref == if >>triplestring
	( now single quoted string )
	dup 0 get '" == if >>string ( "... )
	( test for correct format before passing to parse-int or parse-float since those functions
	  will happily parse something like "123abc" as 123 )
	dup int-symbol? if >>integer
	dup 0 get '# != if >>nomatch dup 1 -1 slice float-symbol? if >>float
	@nomatch
		( leave unprocessed word on stack )
		return
	@null
		return ( leave null on stack )
	@worddef
		drop syntax-define-word return
	@comment
		drop syntax-comment syntax-next return ( skip comment and return NEXT object )
	@line-comment
		drop syntax-line-comment syntax-next return ( skip comment and return NEXT object )
	@lambda
		drop syntax-lambda return
	@list
		drop syntax-list return
	@triplestring
		( call syntax-triple-string with first piece on stack )
		syntax-triple-string return
	@string
		( call syntax-string with first piece on stack )
		syntax-string return
	@integer
		parse-int return
	@float
		1 -1 slice parse-float return
	;

: syntax-triple-string ( first-piece-symbol -- string )
	\ convert to string first ...
	symbol->string
	\ special case of only one piece ... """..."""
	dup length 6 >=
	over -3 -1 slice TRIPLEQUOTE ref symbol->string == and if >>return

	\ else, keep first-piece on stack and add more chunks until i find one
	\ that ends in """
	@read-loop
		reader-next-chunk
		dup null? if >>error-eos
		+
		dup -3 -1 slice TRIPLEQUOTE ref symbol->string == if >>return
		<<read-loop

	@error-eos
		"String ended inside triple-quoted string: " swap + error

	@return ( remove triple quotes from both sides )
		dup length 3 swap 6 - slice
	;

: syntax-comment ( assumes open paren just read )
	"" >L 1 >L ( L0 = nesting, L1 = comment text )
	@loop
		reader-next ( puts symbol on stack )
		dup null? if >>eof
		( add to comment text )
		dup symbol->string L1 ref " " + swap + L1 set! 

		dup ') == if >>closeparen
		dup '( == if >>openparen
		drop <<loop ( discard and continue )
	@closeparen
		LP ref 1 - LP set!
		LP ref 0 == if >>end
		drop <<loop
	@openparen
		LP ref 1 + LP set!
		drop <<loop
	@end
		LP 2 + LP! ( clean up locals )
		drop return
	@eof
		L1 ref 0 40 slice
		"Unexpected end of input inside comment: " swap + error
	;