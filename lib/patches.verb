\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
\ TIP: When changing compiler code, always run with -nocache flag,
\      else compiler would never run when finding .b files.

( ------ boot ----------- )
			
( ------ init ----------- )

\ create a new dictionary as one of:
\
\ 	a list of tuples and makes a dictionary:
\		[ [ "foo" 123 ] [ "bar" 678 ] ] make-dict
\		=>
\		{ "bar" => 678 "foo" => 123 }
\
\	a list of lambdas that returns ( key val ):
\		[ { "a" 10 5 + } { "b" 100 200 + } ]
\		=>
\		{ "a" => 15 "b" => 300 }
\
\	The above forms can be mixed together in the same list
\
\ treating this as experimental so not replacing make-dict yet.
: make-dict* ( pairs -- D )
	,,new-dict D!
	pairs
	{ ( item )
		item list? if >>list
		item lambda? if >>lambda
		item bound-lambda? if >>lambda
		"Bad item passed to make-dict: " item str + error
		
		@list
			D item 0 get item 1 get put D! return
		@lambda
			D item call put D! return
	} for-each
	D
	;

( ------ compiler ------- )

\ is obj a list like: [ ,,inline ... ]
: is-inline-list? ( obj -- result )
	obj list? not if >>no 
	obj length 0 == if >>no \ must be at least [ ,,inline ]
	obj 0 get ',,inline != if >>no
	true return 
	@no false return
	;

\ assumes [ was just read & dropped
: syntax-list
	0 make-list 
	@loop ( list )
		\ note - any inner lists/lambdas will be handled automatically by syntax-next,
		\ so don't have to check for { or [ here
		syntax-next
		dup void? if >>eof
		dup '] == if >>closelist
		dup is-inline-list? if >>inline-list 
		\ anything else, append to list and continue
		append <<loop
	@eof ( list void )
		"Unexpected end of input inside [ .. ]" error
	@inline-list ( list inline-list )
		\ got [ ,,inline elem ... ] -- add elements inline instead of appending as a list 
		\ remove ,,inline 
		1 -1 slice extend <<loop
	@closelist ( list '] )
		drop
		;
	
\ parses { .. } into a lambda (will potentially be converted to a closure (bound-lambda)
\ during finalization)
\
\ assumes { was just read, parses until } as an object list
: syntax-v2-closure
	@locals [ outlist ]
	[ ] outlist!
	
	\ see if there is a ( .. ) next -- if so treat it as declargs
	reader-peek-next '( == if >>read-arglist \ )
	>>loop \ no arglist, peeked symbol will be read again below
	
	@read-arglist
	\ read ( ... ) as arglist
	reader-next drop \ read the ( now \ )
	syntax-parse-decl-arglist 
	outlist swap append outlist! \ fall through to loop
	
	@loop
		syntax-next
		dup void? if >>eof
		dup '} == if >>done
		dup is-inline-list? if >>inline-list
		\ else append object and continue
		outlist swap append outlist! <<loop
	@eof
		drop "End of input inside { .. }" error
	@inline-list
		\ got [ ,,inline elem .. ] -- elements should be added inline instead of appending as list
		\ remove ,,inline
		1 -1 slice outlist swap extend drop <<loop
	@done
		drop \ drop '}
		outlist make-lambda
	;

\ assumes ':' was just read
\
\ TODO --- there should be a common routine to parse functions & lambdas since they
\ are so similar ... 
\	: name ( args ) STUFF ... ;
\ vs
\	{ ( args ) STUFF ... }
: v2-syntax-define-word
	@locals [ SP-start name outlist ]
		\ "define word" . CR
	syntax-next ( name must be next )
	dup symbol? not if >>badname
	name!
	
	\ now this is syntax-v2-closure
	[ ] outlist!
	
	\ see if there is a ( .. ) next -- if so treat it as declargs
	reader-peek-next '( == if >>read-arglist \ )
	>>loop \ no arglist, peeked symbol will be read again below
	
	@read-arglist
	\ read ( ... ) as arglist
	reader-next drop \ read the ( now \ )
	syntax-parse-decl-arglist 
	outlist swap append outlist! \ fall through to loop
		\ "AFTER ARGLIST:" . outlist . CR
	
	@loop
		syntax-next
		dup void? if >>eof
		\ just ; instead of } like in syntax-v2-closure
		dup '; == if >>done
		dup is-inline-list? if >>inline-list
		\ else append object and continue
		outlist swap append outlist! <<loop
	@eof
		drop "End of input inside : ... ;" error
	@inline-list ( inline-list )
		\ got [ ,,inline elem .. ] where elements should be inlined instead of appended as a list
		\ remove ,,inline and extend list
		1 -1 slice outlist swap extend drop <<loop
	@done
		drop \ drop '}
		
	@finish
		( save names & compiled words )
		outlist name save-defined-word
		syntax-next ( save-defined-word has no return value, so return NEXT object )
	;
