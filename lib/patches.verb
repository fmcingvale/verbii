\ Patches file, loaded at startup.
\
\ To keep this small (since it is parsed on every startup), docs are
\ in bootstrap/READ-ME-BEFORE-RUNNING.txt. MAKE SURE to read that before
\ editing any of the files in lib/
\	
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\
( ------ boot ----------- )

( ------ init ----------- )

\ copy first nr locals into list [ LP LP+1 LP+2 ... ]
: copy-locals-to-list ( nr -- list )
	\ cannot use @( .. ) params since that would mess up the locals
	[ ]
	0
	@loop ( nr list i )
		dup SP 3 + ref ( nr list i i nr ) >= if >>done
		dup LP + ref ( nr list i Li )
		SP 2 + ref swap ( nr list i list Li ) append drop ( nr list i )
		1 + ( nr list i+1 ) <<loop
	@done ( nr list i )
		drop nip
	;	
	

\ variant of for-each that calls func with ( key val )
: for-each-dict @( dict func -- )
	@locals [ i keylist ]
	dict keys keylist!
	0 i!
	@loop
		i keylist length >= if >>done 
		keylist i get dup dict swap get func call
		i 1 + i! <<loop
	@done 
		;
		
( ------ compiler ------- )

\ add each name to dict with value set to size of dict at time name was added
\ (i.e. adding [ "a" "b" "c" ] to an empty dict gives a=0, b=1, c=2)
\ note: symbols are accepted and converted to strings
: dict-add-indexed-names @( dict names -- dict-out )
	@locals [ i ]
	0 i!
	@loop
		i names length >= if >>done 
		dict names i get str dict length put drop \ dict[name[i]] = len(dict)
		i 1 + i! <<loop
	@done
		dict
	;
	
\ parses @{ .. } into [ ,,closure ... ]
\
\ assumes @{ was just read, parses until } as an object list, prepended with ,,closure
: syntax-closure
	@locals [ outlist ]
	',,closure 1 make-list outlist!
	@loop
		syntax-next
		dup void? if >>eof
		dup '} == if >>done
		\ else append object and continue
		outlist swap append outlist! <<loop
	@eof
		drop "End of input inside @{" error
	@done
		drop outlist
	;
	

\ rewrites an objlist to translate arg/local names including capturing outer vars (closures)
\
\ selfmap should be set to an empty dict at the toplevel
\
\ ASSUMPTIONS:
\	1. objlist must come from a lambda, not a plain list (rewriting ensures a return is at the end 
\	   	of new objlist, so has to be assumed to be code)
\	2. closures must be marked with @{ ... } ; will NOT transform unmarked lambdas since they might
\		be used in other binding constructs
\	3. does NOT (yet) rewrite lists so dynamic code cannot use @args/@lists nor create closures
\		(user code can manually do closures with :: of course)
\
\ does these things:
\	1. scans objlist (non-recursively) for @args, @locals, and/or [ ,,declargs ... ]
\	2. if NO names found in above search, then objlist is returned as-is and changed=false
\		(no names at THIS level, means no captures can happen here or anywhere underneath)
\	3. rewrite objlist to do:
\		a. alloc locals (LP nr - LP!)
\		b. pop args (L> L> ...)
\		c. rewrite symbols to their code sequences:
\			(i) if name in args/locals, rewrite to (LP i + ref) or (LP i + set!)
\			(ii) if name in selfmap, rewrite to (self i get) or (self i rot put)
\		d. if an inner lambda is found ( @{ ... } -- @ is required for backward compat with { .. } obj :: code )
\			(i) recursively rewrite lambda, passing selfmap + my args+locals as its selfmap
\			(ii) add binding of selfmap + my locals as self for inner lambda
: compile-rewrite-args-locals @( objlist selfmap -- new-objlist )
	@locals [ argnames localnames local-refmap local-setmap new-objlist i self-setmap ]
		\ "REWRITE-ARGS-LOCALS OBJLIST:" . objlist . CR
		\ "SELFMAP:" . selfmap . CR
		
	\ ensure objlist ends with a 'return', or add one
	objlist -1 get 'return == if >>scan-args-locals
	objlist deepcopy ( don't modify original ) 'return append objlist!
	
	@scan-args-locals
		\ scan objlist for , @( ... ), @args, @locals
		objlist
		compile-collect-args-locals localnames! argnames! new-objlist!
			\ "AFTER COLLECT: ARGS=" . argnames . "LOCALS=" . localnames . "OBJLIST=" . new-objlist . CR

		\ note: even if i have no @args/@locals, i can still have names that resolve to selfmap
		
		\ set objlist to rewritten list without @args/@locals
		new-objlist objlist!
		\ clear new-objlist now
		[ ] new-objlist!
		
		\ make preamble code to:
		\	1. alloc spaces for @locals
		\	2. pop args to locals
		\ note this will put args starting at LP and locals starting at LP + #args
		
		\ 1. alloc locals (LP #localnames - LP!)
		localnames length 0 == if >>popargs \ omit code if no locals
		'LP localnames length '- 'LP! 4 make-list new-objlist!
	@popargs
		\ 2. push args to locals (adding code to new-objlist)
		argnames { ( accum elem ) drop '>L append } new-objlist fold new-objlist! 
		
		\ make a map of arg|local name -> index into locals
		[ ] make-dict argnames localnames + dict-add-indexed-names local-refmap!
			\ "MADE NAMEMAP:" . local-refmap . CR
		\ map a map of name! as well to replace setters
		[ ] make-dict 
			argnames { str "!" + } map 
			localnames { str "!" + } map 
			+ dict-add-indexed-names local-setmap!
			\ "MADE SETTER MAP:" . local-setmap . CR
		
		\ for each name in selfmap, make name! in self-setmap with same index
		[ ] make-dict self-setmap!
		selfmap
		{
			( key val ; self self-setmap )
			self -rot swap "!" + swap put drop
		} self-setmap :: for-each-dict
			\ "SET-SETMAP:" . self-setmap . CR
		
	\ rewrite objlist replacing arg|local symbols with appropriate code sequences and creating
	\ closures as needed
	0 i!
	@rewrite-loop
			\ "REWRITE LOOP, NEW NOW:" . new-objlist . CR
			\ "REWRITE LOOP STACK:" . .S CR
		i objlist length >= if >>done 
		objlist i get symbol? if >>symbol
		objlist i get list? if >>list
		\ everything else, copy as-is
	@copy-element
		new-objlist objlist i get append new-objlist! >>next
		
	@symbol
		objlist i get 'return == if >>rewrite-return
		\ is symbol (as string) in local-refmap?
		local-refmap objlist i get str get void? not if >>rewrite-local-ref
		\ is symbol (as string) in selfmap?
		selfmap objlist i get str get void? not if >>rewrite-self-ref
		\ check for local setter
		local-setmap objlist i get str get void? not if >>rewrite-local-set
		\ check for self setter
		self-setmap objlist i get str get void? not if >>rewrite-self-set
		
		\ else not in either list, keep as-is
		<<copy-element
		
	@rewrite-local-ref
		\ add (LP i + ref) to new-objlist
		new-objlist
		'LP local-refmap objlist i get str get '+ 'ref 4 make-list
		+ new-objlist! >>next
		
	@rewrite-local-set
		\ add (LP i + set!) to new-objlist
		new-objlist
		'LP local-setmap objlist i get str get '+ 'set! 4 make-list
		+ new-objlist! >>next
	
	@rewrite-self-ref
		\ add (self i get) to new-objlist
		new-objlist
		'self selfmap objlist i get str get 'get 3 make-list
		+ new-objlist! >>next
	
	@rewrite-self-set
		\ add (self i rot put) to new-objlist
		new-objlist
		'self self-setmap objlist i get str get 'rot 'put 4 make-list
		+ new-objlist! >>next
		
	@rewrite-return
			\ "******* REWRITE RETURN ************" . CR
		
		\ if no args/locals then skip -- no frame to remove
		argnames length localnames length + 0 == if >>simple-return
		
		\ replace return with code to remove local frame
		new-objlist
		'LP argnames length localnames length + '+ 'LP! 'return 5 make-list
		+ new-objlist! >>next
		
	@simple-return
		\ no frame, so just keep return
		new-objlist 'return append new-objlist! >>next
		
	@list
		\ look for [ ,,closure ... ] (parsed from @{ .. })
		objlist i get length 2 < if <<copy-element \ list too short, can't be closure
		objlist i get 0 get ',,closure != if <<copy-element \ not [ ,,closure .. ] so just copy element
		\ recursively parse list, passing a selfmap that is my selfmap + my locals
		selfmap deepcopy \ don't alter my selfmap
		( inner-selfmap )
		argnames dict-add-indexed-names \ add arg names first -- they are first on locals stack
		localnames dict-add-indexed-names \ .. then locals
		( inner-selfmap )
		objlist i get 1 -1 slice \ remove ,,closure
		swap ( objlist inner-selfmap )
			\ "** PARSE INNER LAMBDA:" . CR
		compile-rewrite-args-locals ( new-objlist )
			\ "** INNER REWROTE:" . over . CR
		make-lambda \ turn new-objlist back into lambda
		new-objlist swap append new-objlist! \ add lambda to new-objlist
		\ now create code to make runtime binding for new lambda
		\ want self = [ self0 .. selfN arg0 .. argN local0 .. localN ]
		\ so code will be:
		\	[ ] self + ( shallow-copy self )
		\	#args #locals + copy-locals-to-list + ( self + locals ) ::
		
		\ NOTE! have to check for empty selfmap since referencing a non-existent self is an error
		selfmap length 0 == if >>no-selfmap
		
		\ case 1: my self is bound so concatenate my locals to self
		0 'make-list 'self '+ argnames length localnames length + 'copy-locals-to-list '+ '::
		8 make-list new-objlist swap + new-objlist! \ add self-making code to new-objlist
		>>next
		
	@no-selfmap
		\ case 2: no selfmap so just pass on my locals
		argnames length localnames length + 'copy-locals-to-list '::
		3 make-list new-objlist swap + new-objlist! \ add self-making code to new-objlist
		>>next
		
	@next
		i 1 + i! <<rewrite-loop
	
	@done
		new-objlist return
	;
	
\ take a parsed objlist, presumably from byte-compile, and perform finalization:
\	* ensure objlist ends with 'return'
\	* transform @args [ .. ] and @locals [ .. ] into code and handles closure creation
\
\ returns a new list, does NOT modify objlist
: compile-finalize-word ( objlist -- newlist )
		\ "FINALIZE WORD:" . .S CR
	\ dup length 0 > if >>not-empty
	\ objlist is empty; newlist is [ return ]
	\ drop 'return 1 make-list >>transform-args-locals

	\ @not-empty ( objlist )
	\ 	dup -1 get 'return != if >>add-return
		\ already has return at end
	\ 	>>transform-args-locals

	\ @add-return ( objlist )
	\ 	deepcopy \ don't modify original
	\ 	'return append

	@transform-args-locals ( objlist )
		\ turn names into code sequences
		[ ] make-dict ( toplevel has empty selfmap ) compile-rewrite-args-locals
			\ "AFTER REWRITING:" . .S CR
	;
	
\ parse next word from input into runnable object
: syntax-next ( -- obj )
	reader-next
		 \ "syntax-next:" . dup . CR
	dup void? if >>void
	dup '( == if >>comment
	dup '\ == if >>line-comment
	dup '{ == if >>lambda
	dup '@{ == if >>closure
	dup '[ == if >>list
	dup ': == if >>worddef
	dup 'def == if >>worddef ( synonym for ':' )
	dup 'var == if >>var
	dup 'del == if >>del
	dup 'true == if >>true-literal
	dup 'false == if >>false-literal
	dup 'null == if >>null-literal

	( look for triple-quoted string first )
	dup 0 3 slice TRIPLEQUOTE ref == if >>triplestring
	( now single quoted string )
	dup 0 get '" == if >>string ( "... )
	\ test for correct format before passing to parse-int or parse-float since those functions
	\ will happily parse something like "123abc" as 123 )
	dup int-symbol? if >>integer
	dup float-symbol? if >>float
	dup 0 get '# != if >>nomatch dup 1 -1 slice float-symbol? if >>float-literal
	@nomatch
		( leave unprocessed word on stack )
		return
	@void
		return ( leave void on stack )
	@worddef
		drop syntax-define-word return
	@var
		drop syntax-var return
	@del
		drop syntax-del return
	@comment
		drop syntax-comment syntax-next return ( skip comment and return NEXT object )
	@line-comment
		drop syntax-line-comment syntax-next return ( skip comment and return NEXT object )
	@lambda
		drop syntax-lambda return
	@closure
		drop syntax-closure return
	@list
		drop syntax-list return
	@triplestring
		( call syntax-triple-string with first piece on stack )
		syntax-triple-string return
	@string
		( call syntax-string with first piece on stack )
		syntax-string return
	@integer
		parse-int return
	@float
		parse-float return
	@float-literal ( #NN.NN form )
		1 -1 slice parse-float return
	@true-literal drop true return
	@false-literal drop false return
	@null-literal drop null return
	;
	
( ------ misc ------- )
\ "System startup time: " . run-time str . CR
