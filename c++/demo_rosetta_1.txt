( 	
	demos based on rosetta code tasks -- not necessarily the complete solutions for each, just
	the parts I found interesting 

	Copyright (c) 2022 Frank McIngvale, see LICENSE
)

( https://rosettacode.org/wiki/Fibonacci_sequence )

def fibonacci ( nr -- print first nr numbers of fibonacci sequence )
0 . 1 - ( print 0 first )
0 1 ( N 0 1 )
@loop
( N a b )
2dup + rot drop dup . ( N b a+b )
rot 1 - dup 0 == if >>end ( b a+b N-1 )
-rot <<loop 
@end drop drop drop ;

"First 20 fibonacci numbers:" .
20 fibonacci CR

( https://rosettacode.org/wiki/Sum_digits_of_an_integer )

def sumDigits ( nr -- sum of digits )
0 swap ( sum nr )
@loop 
dup 10 /mod >L rot + swap drop L> ( rem+sum quot )
dup? 0 == if >>end <<loop
@end ;

"Sum digits: 6982 (25) --" . 6982 sumDigits . CR
"Sum digits: 48395019 (39) --" . 48395019 sumDigits . CR
"Sum digits: 1073741823 (36) --" . 1073741823 sumDigits . CR

( https://rosettacode.org/wiki/Proper_divisors )

def printProperDivisors ( n -- prints proper divisors of n )
( special case ) dup 1 == if >>eq1
( start divisor at 1 )
1 ( n d )
@loop
2dup mod 0 == if >>proper >>recur ( n d )
@proper ( n d ) 
dup .
@recur
1 + 2dup swap 2 / > ( n d+1 d+1>n/2 ) ( can stop at n/2 )
if >>done <<loop
@done drop drop
@eq1 ;

"Proper divisors of 100:" . 100 printProperDivisors CR
"Proper divisors of 256:" . 256 printProperDivisors CR

( https://rosettacode.org/wiki/Pi )

( -- translated from Python version -- )
var Q 1 
var R 1
var T 1
var K 1
var N 1
var L 1
var NR 1
var NN 1
1 Q set!
0 R set!
1 T set!
1 K set!
3 N set!
3 L set!
0 NR set!
0 NN set!

def calcPI ( NRDIGITS -- prints digits )
( NRDIGITS )
@loop
4 Q ref * R ref + T ref -
N ref T ref * < ( 4*q+r-t < n*t )
if >>true >>false
@true
	N ref .
	( NRDIGITS )
	1 - dup? 0 == if >>done
	R ref
	N ref T ref * - 10 * NR set! ( nr = 10*(r-n*t) )
	3 Q ref * R ref + 10 * T ref // N ref 10 * - N set! ( n = ((10*(3*q+r))//t)-10*n )
	Q ref 10 * Q set! ( q *= 10 )
	NR ref R set! ( r = nr )
	<<loop
@false
	Q ref 2 * R ref + L ref * NR set! ( nr = (2*q+r)*l )
	K ref 7 * Q ref * 2 + R ref L ref * + T ref L ref * // NN set! ( nn = (q*(7*k)+2+(r*l))//(t*l) )
	Q ref K ref * Q set! ( q *= k )
	T ref L ref * T set! ( t *= l )
	L ref 2 + L set! ( l += 2 )
	K ref 1 + K set! ( k += 1 )
	NN ref N set! ( n = nn )
	NR ref R set! ( r = nr )
	<<loop
@done ;
( -- this above method can only reach 3 digits of PI without bignum support -- )
"3 digits of PI ..." . 3 calcPI CR

del Q del R del T del K del N del L del NR del NN

( -- https://rosettacode.org/wiki/Anonymous_recursion -- )

( --- this seemed like a good one to add, after adding lambdas to the language. note the 
		rosetta task says to calculate the fibonacci sequence, but since i already 
		did that above, i'm doing a countdown instead -- )

( -- this is true anonymous recursion, no names are defined ... 
		done in Y-combinator-ish fashion where the lambda passes itself as 
		an argument to itself -- )
		
"Print 20 .. 1, with anonymous recursion:" .
{ ( lambda N -- ) dup? 0 == if >>done dup . 1 - over call @done }
20 over call CR

( --- tasks I want to do but haven't done yet and/or language missing features to make them easier/possible --- )

( https://rosettacode.org/wiki/Safe_primes_and_unsafe_primes )


( https://rosettacode.org/wiki/N-queens_problem )

( -- prime numbers -- )

( -- some experiments .. need to categorize these later -- )

( -- it sort of depends on the definition, but 'currying' isn't really
	applicable in the sense that without formal argument lists, there is
	no such thing as partial function application.

	however, currying in the sense of making a function that creates a wrapped
	version of another function can done -- )

( -- for example, builtin functions like +, and even user-defined words, cannot
	be passed to functions expecting a lambda. however, it is trivial to wrap those
	functions in a lambda to make it work .. i.e. { + } makes the builtin function +
	into a lambda that can be passed -- )

: make-add-10 { 10 + } ; ( function returning a wrapped function )

var adder 1 ( can save to a variable and call )
make-add-10 adder set!

"Expect 110:" . 100 adder ref call . CR

{ 20 + } adder set! ( or just create it directly without make-add-10 )
"Expect 120:" . 100 adder ref call . CR

( shortcut local names )
: L0 LP ;
: L1 LP 1 + ;

: repeat ( lambda NR -- call lambda NR times )
	( caller might have args to lambda stashed below lambda OR lambda might affect stack,
  	so store my params in locals -- a correctly written lambda won't disturb my locals )
	>L >L ( L1 = NR, L0 = lambda )
	@loop
	L1 ref 0 == if >>done ( NR == 0? )
	L0 ref call ( call lambda, now with access to any args that were below it )
	L1 ref 1 - L1 set! ( NR -= 1 ) <<loop
	@done LP 2 + LP! ; ( remove locals )

: nmax ( xn ... x1 NR -- max of NR numbers )
	{ max } swap 1 - repeat ; ( call 'max' NR-1 times )

"Expect 50:" .
5 10 50 30 -20 8 19 41 0 12 10 nmax . CR

( calculate all factors of an integer )
	
: factors ( N -- print factors )
	1 ( N i )
	@loop
	2dup >= ( N i N>=i )
	if >>check >>done
		@check 2dup mod 0 == ( N i N%i==0 )
			if >>isfactor >>recur 
			@isfactor
				dup . 
			@recur ( N i )
			1 + <<loop

	@done ;

"Factors of 200:" . 200 factors CR
"Factors of 1000:" . 1000 factors CR
"Factors of 41*107:" . 41 107 * factors CR

( -- mutually recursive functions -- )
: even? ( n -- is even? )
	dup? 0 == 
	if >>even 1 - odd? return 
	@even true ;

: odd? ( n -- is odd? )
	dup? 0 == if >>even 1 - even? return @even false ;

"Expect true true false false:" . 100 even? . 64 even? . 31 even? . 151 even? . CR
"Expect false false true true:" . 200 odd? . 44 odd? . 181 odd? . 211 odd? . CR

( -- countdown that only prints numbers that pass a test -- )
: countdown-test ( N test -- print countdown of N where test is true )
	@loop
		over 0 < if >>done
		2dup call if >>true >>recur
		@true
			over .
		@recur
			swap 1 - swap <<loop @done ;

"Count by 1:" . 20 { drop true } countdown-test CR
"Count by evens:" . 40 { even? } countdown-test CR
"Count by odds:" . 40 { odd? } countdown-test CR
"Count by 5s:" . 100 { 5 mod 0 == } countdown-test CR

( -- non-rosetta tasks -- )


( -- compute other functions like cos, sin, tan -- )

( local refs, convenience )
: L0 LP ;
: L1 LP 1 + ;
: L2 LP 2 + ;
: L3 LP 3 + ;

( -- there are no builtin control structures in the language, other than >> and <<,
	so you can invent whichever ones you like.

	this is like a combination of a (for ..) and a (while ..)
	-- )

( for-while: loop that begins at start, increments by given value each time,
			and stops when cond-while evaluates to false. cond-while and lambda
			are called with current counter on top of stack.
			cond-while is checked at the START of each loop. )
: for-while ( start increment cond-whilend lambda )
>L >L >L >L ( L3: lambda, L2: cond-while, L1: increment, L0: current )
@loop
L0 ref L2 ref call if >>continue >>end ( cond-end true|false for current counter? )
@continue
L0 ref L3 ref call ( call lambda with current value )
L0 ref L1 ref + L0 set! ( current += increment )
<<loop
@end
LP 4 + LP! ( clean up locals )
;

"Count 1 .. 10:" . 1 1 { 10 <= } { . } for-while CR
"Count 20 .. 0, by 4's:" . 20 -4 { 0 >= } { . } for-while CR

( -- https://rosettacode.org/wiki/Multiplication_tables -- )

: .cn ( c n -- print char n times )
	@loop
	dup? 0 == if >>done
	swap dup .c swap 1 - <<loop
	@done drop ;

: spaces ( n -- print n spaces ) 32 swap .cn ;

: .w ( obj width -- print obj with minimum width, left padded )
	swap str dup length rot swap - ( str width-len )
	dup 0 > if >>dopad
	drop >>done
	@dopad spaces
	@done . ;

"Upper triangle of stars ..." . CR 
15 -1 { 0 > } { { 42 .c 32 .c } swap repeat CR } for-while 

"Multiplication table ..." . CR
clear
1 1 { 10 < } { 
	dup . ( print row label )
	1 1 { 10 < } {
		( stack is: outer-counter inner-counter -- i can't destroy outer counter
		  because it is only refreshed after all inner loops are finished, so copy
		  it over to multiply ) 
		over ( outer inner outer )
		2dup <  if >>skip ( only print upper triangle )
		* 4 .w >>done ( print width=4 ) 
		@skip drop drop 5 spaces @done
		} for-while CR
} for-while

( -- https://rosettacode.org/wiki/100_doors -- )

var DOORS 101 ( numbering these 1..100 since 0 as increment would infinite loop )
( -- set all to zero (closed) -- )
1 1 { 100  <= } { 0 swap DOORS + set! } for-while

: toggle ( n=1,0 -- 0,1 )
1 == if >>zero 1 return @zero 0 ;

( -- for i={1..100} visit in loop with increment=i, toggling doors )
1 1 { 100 <= } {
	( outer-count )
	dup { 100 <= } ( outer outer .. -- start at outer with increment of outer )
	{
		( inner )
		dup DOORS + ref ( inner DOORS[inner] )
		toggle swap DOORS + set! ( DOORS[inner] = toggled )
	} for-while
} for-while

." Opened doors ... "
1 1 { 100 <= } { 
	( outer )
	dup DOORS + ref ( outer DOORS[outer] )
	0 == if >>skip
	. @skip } for-while CR
	
del DOORS 
