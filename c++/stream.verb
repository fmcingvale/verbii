\
\ Stream reader
\
\ Copyright (c) 2022 Frank McIngvale, see LICENSE
\

\ return string with any leading whitespace removed
: string-ltrim ( string -- string )
	0
	@loop ( string i )
		2dup swap length >= ( string i i>=len ) if >>empty
		2dup get whitespace? not ( string i !ws?[string[i]] ) if >>endtrim 
		1 + <<loop
	@endtrim ( string i )
		-1 slice return
	@empty ( string i )
		drop drop "" return
	;

\ is string zero length or contain only whitespace?
: string-empty? ( string -- empty? )
	string-ltrim length 0 ==
	;

\ create a new stream for reading from string
: stream-reader-open-string ( string -- stream )
	\ state = [ TEXT POSITION ]
	0 2 make-list
	;

\ create a new stream for reading from file
: stream-reader-open-file ( filename -- stream )
	read-file stream-reader-open-string
	;

\ since doing a series of reads is such a common operation,
\ these functions leave the stream on the stack to avoid lots of caller dups
\ and also usually avoids drops here

\ peek next char [as string] from stream or void on eof
: stream-reader-peek-char ( stream -- stream c )
	\ POS >= length?
	dup 1 get over 0 get length >= if >>eof
	\ POS is OK
	dup 0 get over 1 get get return
	
	@eof void
	;

\ read next char [as string] from stream or void on eof
: stream-reader-next-char ( stream -- stream c )
	\ POS >= length?
	dup 1 get over 0 get length >= if >>eof
	\ POS is OK, get char
	dup 0 get over 1 get get ( stream c )
	\ ++POS
	swap dup 1 get 1 + 1 swap put ( c stream )
	swap return 

	@eof void
	;

\ skip all whitespace from current position
: stream-reader-skip-whitespace ( stream -- stream )
	@loop
		stream-reader-peek-char
		dup void? if >>done
		dup whitespace? not if >>done
		drop 
		stream-reader-next-char drop <<loop
	@done
		drop
		;

\ read word (non-whitespace chunk) from current position,
\ skipping any leading whitespace. returns void if no more words.
: stream-reader-next-word ( stream -- stream word )
	stream-reader-skip-whitespace
	"" ( stream word )
	@loop ( stream word )
		over stream-reader-next-char nip ( stream word c )
		dup void? if >>done
		dup whitespace? if >>done
		+ <<loop \ non-ws, append and continue
	@done ( stream word c )
		drop
		dup length 0 == if >>void
		return
	@void
		drop void
	;

\ get next line from reader or void
\ discards any \r or \n line ending so an empty line will return ""
\ returns void if no more lines
: stream-reader-next-line ( stream -- stream line )
	""
	@loop ( stream s )
		\ "@loop:" . .S CR
		over stream-reader-next-char nip ( stream s c )
		dup void? if >>eof
		dup ord 10 == if >>NL \ \n
		dup ord 13 == if >>CR \ \r
		+ <<loop \ normal char - append and contine
	\ this is gross but i want to be portable so check for
	\ any of: \n, \r, \r\n, \n\r
	@NL ( stream s \n )
		drop over stream-reader-peek-char nip ( stream s c )
		dup void? if >>drop-return
		dup ord 13 == if >>skip-next
		>>drop-return
	@CR ( stream s \r )
		drop over stream-reader-peek-char nip ( stream s c )
		dup void? if >>drop-return
		dup ord 10 == if >>skip-next
		>>drop-return
	@drop-return
		\ just \r or \n
		drop return
	@skip-next ( stream s c )
		\ got CR/LF pair
		\ skip next char
		drop over stream-reader-next-char drop drop return
	@eof ( stream s c )
		drop 
		\ need to distinguish eof at end of string vs. eof at start
		dup length 0 == if >>void \ no chars before eof
		return
	@void ( stream s )
		drop void
		;
		

